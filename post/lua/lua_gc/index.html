<!doctype html><html lang=zh-cn>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta property="og:site_name" content="Xun's Blog">
<meta property="og:type" content="article">
<meta property="og:image" content="https://fallingxun.github.io//">
<meta property="twitter:image" content="https://fallingxun.github.io//">
<meta name=title content="Lua篇 — 垃圾回收">
<meta property="og:title" content="Lua篇 — 垃圾回收">
<meta property="twitter:title" content="Lua篇 — 垃圾回收">
<meta name=description content>
<meta property="og:description" content>
<meta property="twitter:description" content>
<meta property="twitter:card" content="summary">
<meta name=keyword content>
<link rel="shortcut icon" href=/img/favicon.ico>
<title>Lua篇 — 垃圾回收-</title>
<link rel=canonical href=/post/lua/lua_gc/>
<link rel=stylesheet href=/css/iDisqus.min.css>
<link rel=stylesheet href=/css/bootstrap.min.css>
<link rel=stylesheet href=/css/hugo-theme-cleanwhite.min.css>
<link rel=stylesheet href=/css/zanshang.css>
<link href=//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css rel=stylesheet type=text/css>
<script src=/js/jquery.min.js></script>
<script src=/js/bootstrap.min.js></script>
<script src=/js/hux-blog.min.js></script>
</head>
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
<div class=container-fluid>
<div class="navbar-header page-scroll">
<button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=/>Xun's Blog</a>
</div>
<div id=huxblog_navbar>
<div class=navbar-collapse>
<ul class="nav navbar-nav navbar-right">
<li>
<a href=/>Home</a>
</li>
<li>
<a href=/categories/googleplay%E7%B3%BB%E5%88%97>googleplay系列</a>
</li>
<li>
<a href=/categories/lua%E7%B3%BB%E5%88%97>lua系列</a>
</li>
<li>
<a href=/categories/tmp%E7%B3%BB%E5%88%97>tmp系列</a>
</li>
<li>
<a href=/categories/unity%E7%B3%BB%E5%88%97>unity系列</a>
</li>
<li>
<a href=/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%B3%BB%E5%88%97>图形学系列</a>
</li>
<li>
<a href=/categories/%E6%B8%B2%E6%9F%93%E7%B3%BB%E5%88%97>渲染系列</a>
</li>
<li>
<a href=/categories/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97>算法系列</a>
</li>
</ul>
</div>
</div>
</div>
</nav>
<script>var $body=document.body,$toggle=document.querySelector('.navbar-toggle'),$navbar=document.querySelector('#huxblog_navbar'),$collapse=document.querySelector('.navbar-collapse');$toggle.addEventListener('click',handleMagic);function handleMagic(a){$navbar.className.indexOf('in')>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf('in')<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script>
<style type=text/css>header.intro-header{background-image:url('/')}</style>
<header class=intro-header>
<div class=container>
<div class=row>
<div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
<div class=post-heading>
<div class=tags>
<a class=tag href=/tags/lua title=Lua>
Lua
</a>
</div>
<h1>Lua篇 — 垃圾回收</h1>
<h2 class=subheading></h2>
<span class=meta>
Posted by
Xun
on
Tuesday, November 7, 2023
</span>
</div>
</div>
</div>
</div>
</header>
<article>
<div class=container>
<div class=row>
<div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container">
<p>垃圾回收（GC）是程序运行中必不可少的一环，lua 内部则实现了一套垃圾回收流程。</p>
<h3 id=简介>简介</h3>
<ul>
<li>在游戏项目中，lua 的主要优势，在于能进行热更新，能及时修复线上运行过程中出现的问题，尽可能地缩短流程时长。另一方面，对于开发者来讲，lua 的另一个优势，即其内部实现了一套垃圾回收流程，可以自动进行垃圾回收，不需要开发者进行主动管理，为开发者提供了较大的便利。</li>
<li>尽管 lua 有垃圾回收机制，但如果不了解其内部实现，就不知道需要注意的地方。为了做好内存管理，还是需要进一步了解掌握 lua 的垃圾回收机制。</li>
</ul>
<h3 id=初始化>初始化</h3>
<ul>
<li>lua 初始化的方法如下：</li>
</ul>
<pre tabindex=0><code>// lstate.c

LUA_API lua_State *lua_newstate (lua_Alloc f, void *ud) {
  int i;
  lua_State *L;
  global_State *g;
  LG *l = cast(LG *, (*f)(ud, NULL, LUA_TTHREAD, sizeof(LG)));
  if (l == NULL) return NULL;
  L = &amp;l-&gt;l.l;
  g = &amp;l-&gt;g;
  L-&gt;tt = LUA_VTHREAD;
  g-&gt;currentwhite = bitmask(WHITE0BIT);
  L-&gt;marked = luaC_white(g);
  preinit_thread(L, g);
  g-&gt;allgc = obj2gco(L);  /* by now, only object is the main thread */
  L-&gt;next = NULL;
  g-&gt;Cstacklimit = L-&gt;nCcalls = LUAI_MAXCSTACK + CSTACKERR;
  incnny(L);  /* main thread is always non yieldable */
  g-&gt;frealloc = f;
  g-&gt;ud = ud;
  g-&gt;warnf = NULL;
  g-&gt;ud_warn = NULL;
  g-&gt;mainthread = L;
  g-&gt;seed = luai_makeseed(L);
  g-&gt;gcrunning = 0;  /* no GC while building state */
  g-&gt;strt.size = g-&gt;strt.nuse = 0;
  g-&gt;strt.hash = NULL;
  setnilvalue(&amp;g-&gt;l_registry);
  g-&gt;panic = NULL;
  g-&gt;gcstate = GCSpause;
  g-&gt;gckind = KGC_INC;
  g-&gt;gcemergency = 0;
  g-&gt;finobj = g-&gt;tobefnz = g-&gt;fixedgc = NULL;
  g-&gt;firstold1 = g-&gt;survival = g-&gt;old1 = g-&gt;reallyold = NULL;
  g-&gt;finobjsur = g-&gt;finobjold1 = g-&gt;finobjrold = NULL;
  g-&gt;sweepgc = NULL;
  g-&gt;gray = g-&gt;grayagain = NULL;
  g-&gt;weak = g-&gt;ephemeron = g-&gt;allweak = NULL;
  g-&gt;twups = NULL;
  g-&gt;totalbytes = sizeof(LG);
  g-&gt;GCdebt = 0;
  g-&gt;lastatomic = 0;
  setivalue(&amp;g-&gt;nilvalue, 0);  /* to signal that state is not yet built */
  setgcparam(g-&gt;gcpause, LUAI_GCPAUSE);
  setgcparam(g-&gt;gcstepmul, LUAI_GCMUL);
  g-&gt;gcstepsize = LUAI_GCSTEPSIZE;
  setgcparam(g-&gt;genmajormul, LUAI_GENMAJORMUL);
  g-&gt;genminormul = LUAI_GENMINORMUL;
  for (i=0; i &lt; LUA_NUMTAGS; i++) g-&gt;mt[i] = NULL;
  if (luaD_rawrunprotected(L, f_luaopen, NULL) != LUA_OK) {
    /* memory allocation error: free partial state */
    close_state(L);
    L = NULL;
  }
  return L;
}
</code></pre><ul>
<li>其中，gc 相关的参数也进行了初始化状态，主要参数有：
<ul>
<li>currentwhite
<ul>
<li>当前 gc 过程的白色类型，包括 WHITE0BIT 、WHITE1BIT ，通过两种类型交替使用，来表示对象是上一轮还是当前轮 gc 处理的对象。</li>
</ul>
</li>
<li>allgc
<ul>
<li>所有需要 gc 的对象链表。</li>
</ul>
</li>
<li>gcstate
<ul>
<li>当前 gc 过程所处的状态，有以下状态：
<ul>
<li>GCSpropagate ：扫描标记状态。</li>
<li>GCSenteratomic ：准备进入原子处理的状态。</li>
<li>GCSatomic ：原子处理状态。</li>
<li>GCSswpallgc ：清除 allgc 列表状态。</li>
<li>GCSswpfinobj ：清除 finobj 列表状态。</li>
<li>GCSswptobefnz ：清除 tobefnz 列表状态。</li>
<li>GCSswpend ：清除完成状态。</li>
<li>GCScallfin ：执行析构方法状态。</li>
<li>GCSpause ：暂停状态（初始化时的默认状态）。</li>
</ul>
</li>
</ul>
</li>
<li>gckind
<ul>
<li>gc 类型，有两种类型：
<ul>
<li>KGC_INC ：增量式 gc（初始化时的默认状态）。</li>
<li>KGC_GEN ：分代式 gc 。</li>
</ul>
</li>
</ul>
</li>
<li>gcemergency
<ul>
<li>紧急 gc 标记，如果不为 0 ，则会跳过一些操作，避免某些操作（如执行析构方法、缩小数据结构等）在非预期的情况下，更改解释器状态。</li>
</ul>
</li>
<li>finobj
<ul>
<li>带析构方法的对象列表。</li>
</ul>
</li>
<li>tobefnz
<ul>
<li>userdata 对象列表。</li>
</ul>
</li>
<li>sweepgc
<ul>
<li>当前清除对象列表。</li>
</ul>
</li>
<li>gray
<ul>
<li>灰色对象列表（用于记录当前灰色对象，和对象的 gclist 组合使用）。</li>
</ul>
</li>
<li>grayagain
<ul>
<li>需要进行原子处理遍历的对象列表。</li>
</ul>
</li>
<li>weak
<ul>
<li>弱值（value）类型 table 列表。</li>
</ul>
</li>
<li>ephemeron
<ul>
<li>弱键（key）类型 table 列表。</li>
</ul>
</li>
<li>allweak
<ul>
<li>弱键值（key-value）类型 table 列表。</li>
</ul>
</li>
<li>GCdebt
<ul>
<li>已经申请且还没被收集器补偿的内存字节数，用于管理 gc 启动的时机，当大于 0 时才会开启 gc 。创建新对象时增加，释放时减少。</li>
</ul>
</li>
<li>totalbytes
<ul>
<li>已经申请且被收集器补偿的内存字节数，和 GCdebt 相加表示真正申请的总内存。</li>
</ul>
</li>
<li>gcpause
<ul>
<li>默认为 200（LUAI_GCPAUSE）。</li>
</ul>
</li>
<li>gcstepsize
<ul>
<li>每一步处理的大小，以 2 为底的对数表示，默认为 13（LUAI_GCSTEPSIZE），即 8 KB 。</li>
</ul>
</li>
<li>gcstepmul
<ul>
<li>每一步处理的大小的放大倍数，默认为 100（LUAI_GCMUL）。</li>
</ul>
</li>
<li>GCestimate
<ul>
<li>使用中的内存估计大小。</li>
</ul>
</li>
</ul>
</li>
<li>所有需要 gc 的对象，最终都通过 luaC_newobj 方法创建。</li>
</ul>
<pre tabindex=0><code>// lgc.c

GCObject *luaC_newobj (lua_State *L, int tt, size_t sz) {
  global_State *g = G(L);
  GCObject *o = cast(GCObject *, luaM_newobject(L, novariant(tt), sz));
  o-&gt;marked = luaC_white(g);
  o-&gt;tt = tt;
  o-&gt;next = g-&gt;allgc;
  g-&gt;allgc = o;
  return o;
}
</code></pre><ul>
<li>创建一个新对象，会将其标记为当前的白色，并且会将该对象设置到 g->allgc 列表上，用于后续 gc 处理时进行遍历。
<img src="/img/Lua/GC/allgc.png?raw=true" alt=allgc.png>
</li>
</ul>
<h3 id=算法流程>算法流程</h3>
<ul>
<li>标记清除算法的主要流程为：
<ul>
<li>所有对象创建的时候标记为白色。</li>
<li>gc 开始后，遍历检查所有对象，如果还有引用的，就标记为黑色。</li>
<li>标记完成后，所有标记为白色的对象，表示对象没有引用，直接清除。</li>
<li>清除完成后，将所有黑色的对象重新标记为白色，等待下一次 gc 。</li>
</ul>
</li>
<li>由于需要检查完所有对象进行标记，再对所有对象进行处理，执行一次 gc 的耗时相对较长。因此，lua 的 gc 加入了分步的概念，每次处理都有上限数量，将整个过程切分成多个小步骤循环执行，主要流程为：
<ul>
<li>设置当前白色为白色 1 ，所有对象创建的时候标记为白色 1 。</li>
<li>gc 开始后，遍历检查所有对象，如果还有引用的，就标记为灰色，加入灰色列表。</li>
<li>取出灰色列表的对象，将其标记为黑色，并将其引用的所有对象标记为灰色，加入灰色列表。</li>
<li>所有对象标记完成后，设置当前白色为白色 2 。</li>
<li>遍历所有需要 gc 的对象，如果为白色 1 ，则该对象没有引用，直接清除。如果不为白色 1 ，则将该对象标记为白色 2 。</li>
<li>所有对象清除完成后，本轮 gc 结束。下轮 gc 则对白色 2 对象进行处理，两种白色交替使用。
<img src="/img/Lua/GC/GC_1.gif?raw=true" alt=GC_1.gif>
</li>
</ul>
</li>
<li>如上图所示，检查引用从栈和全局表开始，红色箭头表示栈引用的对象，黄色箭头表示全局表引用的对象，绿色箭头表示对象引用的其他对象。</li>
<li>标记开始时，引用的对象会被标记为灰色，然后下一步处理时变成黑色，并将其引用的对象标记为灰色。循环上面过程，直到将所有引用的对象标记完成。然后遍历 allgc 列表，白色的对象清除，其他对象则重新设置为白色。</li>
<li>简单来说，lua 的 gc 流程就如图中所示。实际上，lua 的 gc 过程分为几个阶段，具体实现中有许多细节内容。</li>
</ul>
<h3 id=gc-阶段>gc 阶段</h3>
<ul>
<li>初始化后，gcstate 为 GCSpause 状态，每个状态下 gc 执行步骤的代码为：</li>
</ul>
<pre tabindex=0><code>// lgc.c

static lu_mem singlestep (lua_State *L) {
  global_State *g = G(L);
  switch (g-&gt;gcstate) {
    case GCSpause: {
      restartcollection(g);
      g-&gt;gcstate = GCSpropagate;
      return 1;
    }
    case GCSpropagate: {
      if (g-&gt;gray == NULL) {  /* no more gray objects? */
        g-&gt;gcstate = GCSenteratomic;  /* finish propagate phase */
        return 0;
      }
      else
        return propagatemark(g);  /* traverse one gray object */
    }
    case GCSenteratomic: {
      lu_mem work = atomic(L);  /* work is what was traversed by 'atomic' */
      entersweep(L);
      g-&gt;GCestimate = gettotalbytes(g);  /* first estimate */;
      return work;
    }
    case GCSswpallgc: {  /* sweep &quot;regular&quot; objects */
      return sweepstep(L, g, GCSswpfinobj, &amp;g-&gt;finobj);
    }
    case GCSswpfinobj: {  /* sweep objects with finalizers */
      return sweepstep(L, g, GCSswptobefnz, &amp;g-&gt;tobefnz);
    }
    case GCSswptobefnz: {  /* sweep objects to be finalized */
      return sweepstep(L, g, GCSswpend, NULL);
    }
    case GCSswpend: {  /* finish sweeps */
      checkSizes(L, g);
      g-&gt;gcstate = GCScallfin;
      return 0;
    }
    case GCScallfin: {  /* call remaining finalizers */
      if (g-&gt;tobefnz &amp;&amp; !g-&gt;gcemergency) {
        int n = runafewfinalizers(L, GCFINMAX);
        return n * GCFINALIZECOST;
      }
      else {  /* emergency mode or no more finalizers */
        g-&gt;gcstate = GCSpause;  /* finish collection */
        return 0;
      }
    }
    default: lua_assert(0); return 0;
  }
}
</code></pre><h4 id=启动阶段gcspause---gcspropagate>启动阶段（GCSpause -> GCSpropagate）</h4>
<ul>
<li>启动阶段主要执行的代码如下：</li>
</ul>
<pre tabindex=0><code>// lgc.c

static void restartcollection (global_State *g) {
  cleargraylists(g);
  markobject(g, g-&gt;mainthread);
  markvalue(g, &amp;g-&gt;l_registry);
  markmt(g);
  markbeingfnz(g);  /* mark any finalizing object left from previous cycle */
}
</code></pre><ul>
<li>启动阶段也是 gc 循环开始的阶段，主要是将 lua 对象引用的起点进行标记，其步骤为：
<ul>
<li>清除 gc 循环过程中记录的链表（g->gray 、g->grayagain 、g->weak 、g->allweak 、g->ephemeron）。</li>
<li>将 lua 栈（g->mainthread）标记为灰色。</li>
<li>将注册表（g->l_registry）的标记为灰色。</li>
<li>将 lua 基础类型的元表标记为灰色。</li>
<li>将 userdata 列表的所有对象标记为灰色。</li>
</ul>
</li>
<li>其中，标记的方法具体实现为：</li>
</ul>
<pre tabindex=0><code>// lgc.c

static void reallymarkobject (global_State *g, GCObject *o) {
  switch (o-&gt;tt) {
    case LUA_VSHRSTR:
    case LUA_VLNGSTR: {
      set2black(o);  /* nothing to visit */
      break;
    }
    case LUA_VUPVAL: {
      UpVal *uv = gco2upv(o);
      if (upisopen(uv))
        set2gray(uv);  /* open upvalues are kept gray */
      else
        set2black(o);  /* closed upvalues are visited here */
      markvalue(g, uv-&gt;v);  /* mark its content */
      break;
    }
    case LUA_VUSERDATA: {
      Udata *u = gco2u(o);
      if (u-&gt;nuvalue == 0) {  /* no user values? */
        markobjectN(g, u-&gt;metatable);  /* mark its metatable */
        set2black(o);  /* nothing else to mark */
        break;
      }
      /* else... */
    }  /* FALLTHROUGH */
    case LUA_VLCL: case LUA_VCCL: case LUA_VTABLE:
    case LUA_VTHREAD: case LUA_VPROTO: {
      linkobjgclist(o, g-&gt;gray);  /* to be visited later */
      break;
    }
    default: lua_assert(0); break;
  }
}

static void linkgclist_ (GCObject *o, GCObject **pnext, GCObject **list) {
  lua_assert(!isgray(o));  /* cannot be in a gray list */
  *pnext = *list;
  *list = o;
  set2gray(o);  /* now it is */
}


/*
** Link a generic collectable object 'o' into the list 'p'.
*/
#define linkobjgclist(o,p) linkgclist_(obj2gco(o), getgclist(o), &amp;(p))
</code></pre><ul>
<li>可以看到，通常情况下，标记灰色的过程为：
<ul>
<li>将当前对象的 gclist 指向灰色对象列表 gray 。</li>
<li>将当前对象设置到 gray 列表。</li>
<li>将当前对象标记为灰色（非黑非白）。</li>
</ul>
</li>
<li>而对于字符串类型，则是直接将对象标记为黑色。这是因为字符串类型的对象，不会再引用其他的对象，所以不需要再向后延伸。</li>
</ul>
<h4 id=传播阶段gcspropagate---gcsenteratomic>传播阶段（GCSpropagate -> GCSenteratomic）</h4>
<ul>
<li>传播阶段的代码实现为：</li>
</ul>
<pre tabindex=0><code>// lgc.c

static lu_mem propagatemark (global_State *g) {
  GCObject *o = g-&gt;gray;
  nw2black(o);
  g-&gt;gray = *getgclist(o);  /* remove from 'gray' list */
  switch (o-&gt;tt) {
    case LUA_VTABLE: return traversetable(g, gco2t(o));
    case LUA_VUSERDATA: return traverseudata(g, gco2u(o));
    case LUA_VLCL: return traverseLclosure(g, gco2lcl(o));
    case LUA_VCCL: return traverseCclosure(g, gco2ccl(o));
    case LUA_VPROTO: return traverseproto(g, gco2p(o));
    case LUA_VTHREAD: return traversethread(g, gco2th(o));
    default: lua_assert(0); return 0;
  }
}
</code></pre><ul>
<li>该阶段执行一次，会将灰色列表的当前对象移除，标记为黑色，并将此对象的 gclist 设置为灰色列表（和启动阶段的设置对应）。之后，对此对象进行遍历，获取其引用的所有对象，标记成灰色，加入灰色列表。</li>
<li>此后，会重复上面的过程，持续标记过程，直到灰色列表的所有对象都已经标记为黑色，该阶段才算真正完成。</li>
</ul>
<h5 id=遍历-table>遍历 table</h5>
<ul>
<li>遍历检查 table 过程如下：</li>
</ul>
<pre tabindex=0><code>// lgc.c

static lu_mem traversetable (global_State *g, Table *h) {
  const char *weakkey, *weakvalue;
  const TValue *mode = gfasttm(g, h-&gt;metatable, TM_MODE);
  markobjectN(g, h-&gt;metatable);
  if (mode &amp;&amp; ttisstring(mode) &amp;&amp;  /* is there a weak mode? */
      (cast_void(weakkey = strchr(svalue(mode), 'k')),
       cast_void(weakvalue = strchr(svalue(mode), 'v')),
       (weakkey || weakvalue))) {  /* is really weak? */
    if (!weakkey)  /* strong keys? */
      traverseweakvalue(g, h);
    else if (!weakvalue)  /* strong values? */
      traverseephemeron(g, h, 0);
    else  /* all weak */
      linkgclist(h, g-&gt;allweak);  /* nothing to traverse now */
  }
  else  /* not weak */
    traversestrongtable(g, h);
  return 1 + h-&gt;alimit + 2 * allocsizenode(h);
}
</code></pre><ul>
<li>对于 table 来说，根据 table 是否为弱表，有不同的检查方式。
<ul>
<li>key 为强类型，value 为弱类型。
<ul>
<li>遍历 table 的哈希表部分，如果 value 为空，则清除 key 值。如果 value 不为空，则将 key 值标记为灰色。</li>
<li>如果当前是在 GCSatomic 状态，并且数组部分不为空，或者哈希表部分存在未标记的对象，则该 table 要加入到 g->weak 列表中，不然就将 table 加入到 g->grayagain 列表中。</li>
</ul>
</li>
<li>key 为弱类型，value 为强类型。
<ul>
<li>遍历 table 的数组部分，将所有对象标记为灰色。</li>
<li>遍历 table 的哈希表部分：
<ul>
<li>如果 value 为空，则清除 key 值。</li>
<li>如果 value 不为空，key 已标记，value 未标记过，则将 value 值标记为灰色。</li>
<li>如果当前为 GCSpropagate 状态，则将 table 加入 g->grayagain 列表。</li>
<li>如果遍历前存在 key-value 都未标记过的，则将 table 加入 g->ephemeron 列表。</li>
<li>如果遍历前存在 key 未标记过的，则将 table 加入 g->allweak 列表。</li>
</ul>
</li>
</ul>
</li>
<li>key-value 都为弱类型。
-将 table 加入 g->allweak 列表。</li>
<li>key-value 都为强类型。
<ul>
<li>遍历 table 的数组部分，将所有对象标记为灰色。</li>
<li>遍历 table 的哈希表部分：
<ul>
<li>如果 value 为空，则清除 key 值。</li>
<li>将 key 值标记为灰色。</li>
<li>将 value 值标记为灰色。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>遍历结束后，会返回处理的 TValue 对象数量，为：
<ul>
<li>当前 table ：1 。</li>
<li>table 的数组部分数量： h->alimit 。</li>
<li>table 的哈希表部分数量（每个节点有 key 和 value 两个对象）：2 * allocsizenode(h) 。</li>
</ul>
</li>
</ul>
<h5 id=遍历-thread>遍历 thread</h5>
<ul>
<li>遍历检查 thread 过程如下：</li>
</ul>
<pre tabindex=0><code>// lgc.c

static int traversethread (global_State *g, lua_State *th) {
  UpVal *uv;
  StkId o = th-&gt;stack;
  if (isold(th) || g-&gt;gcstate == GCSpropagate)
    linkgclist(th, g-&gt;grayagain);  /* insert into 'grayagain' list */
  if (o == NULL)
    return 1;  /* stack not completely built yet */
  lua_assert(g-&gt;gcstate == GCSatomic ||
             th-&gt;openupval == NULL || isintwups(th));
  for (; o &lt; th-&gt;top; o++)  /* mark live elements in the stack */
    markvalue(g, s2v(o));
  for (uv = th-&gt;openupval; uv != NULL; uv = uv-&gt;u.open.next)
    markobject(g, uv);  /* open upvalues cannot be collected */
  if (g-&gt;gcstate == GCSatomic) {  /* final traversal? */
    StkId lim = th-&gt;stack + th-&gt;stacksize;  /* real end of stack */
    for (; o &lt; lim; o++)  /* clear not-marked stack slice */
      setnilvalue(s2v(o));
    /* 'remarkupvals' may have removed thread from 'twups' list */
    if (!isintwups(th) &amp;&amp; th-&gt;openupval != NULL) {
      th-&gt;twups = g-&gt;twups;  /* link it back to the list */
      g-&gt;twups = th;
    }
  }
  else if (!g-&gt;gcemergency)
    luaD_shrinkstack(th); /* do not change stack in emergency cycle */
  return 1 + th-&gt;stacksize;
}
</code></pre><ul>
<li>对于线程类型对象，主要操作对象为栈和 upvalue ，过程为：
<ul>
<li>从栈底到栈顶，把栈上的对象标记为灰色。</li>
<li>将 openupval 列表的对象标记为灰色。</li>
<li>如果当前是 GCSatomic 状态，从栈顶开始，到整个栈的最大值，将栈上所有对象清除。</li>
<li>如果当前不为 GCSatomic 状态，且 g->gcemergency 不为 0（即不为紧急 gc），则对当前栈进行缩减，缩减流程为：
<ul>
<li>获取当前栈正在使用的大小。</li>
<li>设置最佳大小为正在使用的大小加上 BASIC_STACK_SIZE（C 函数可用的最小 lua 栈大小的 2 倍，20）。</li>
<li>如果当前正在使用的大小没有超过 LUAI_MAXSTACK - EXTRA_STACK，并且最佳大小也小于当前栈的大小，才以最佳大小进行栈缩小。</li>
</ul>
</li>
</ul>
</li>
<li>遍历结束后，返回处理的大小为：
<ul>
<li>当前 thread 对象 ：1 。</li>
<li>当前栈的大小：th->stacksize 。</li>
</ul>
</li>
</ul>
<h4 id=原子阶段gcspropagate---gcsenteratomic>原子阶段（GCSpropagate -> GCSenteratomic）</h4>
<ul>
<li>原子阶段主要从头开始，对所有未标记过的对象进行检查标记，再执行一次清扫过程。</li>
<li>该阶段的标记方法为：</li>
</ul>
<pre tabindex=0><code>// lgc.c

static lu_mem atomic (lua_State *L) {
  global_State *g = G(L);
  lu_mem work = 0;
  GCObject *origweak, *origall;
  GCObject *grayagain = g-&gt;grayagain;  /* save original list */
  g-&gt;grayagain = NULL;
  lua_assert(g-&gt;ephemeron == NULL &amp;&amp; g-&gt;weak == NULL);
  lua_assert(!iswhite(g-&gt;mainthread));
  g-&gt;gcstate = GCSatomic;
  markobject(g, L);  /* mark running thread */
  /* registry and global metatables may be changed by API */
  markvalue(g, &amp;g-&gt;l_registry);
  markmt(g);  /* mark global metatables */
  work += propagateall(g);  /* empties 'gray' list */
  /* remark occasional upvalues of (maybe) dead threads */
  work += remarkupvals(g);
  work += propagateall(g);  /* propagate changes */
  g-&gt;gray = grayagain;
  work += propagateall(g);  /* traverse 'grayagain' list */
  convergeephemerons(g);
  /* at this point, all strongly accessible objects are marked. */
  /* Clear values from weak tables, before checking finalizers */
  clearbyvalues(g, g-&gt;weak, NULL);
  clearbyvalues(g, g-&gt;allweak, NULL);
  origweak = g-&gt;weak; origall = g-&gt;allweak;
  separatetobefnz(g, 0);  /* separate objects to be finalized */
  work += markbeingfnz(g);  /* mark objects that will be finalized */
  work += propagateall(g);  /* remark, to propagate 'resurrection' */
  convergeephemerons(g);
  /* at this point, all resurrected objects are marked. */
  /* remove dead objects from weak tables */
  clearbykeys(g, g-&gt;ephemeron);  /* clear keys from all ephemeron tables */
  clearbykeys(g, g-&gt;allweak);  /* clear keys from all 'allweak' tables */
  /* clear values from resurrected weak tables */
  clearbyvalues(g, g-&gt;weak, origweak);
  clearbyvalues(g, g-&gt;allweak, origall);
  luaS_clearcache(g);
  g-&gt;currentwhite = cast_byte(otherwhite(g));  /* flip current white */
  lua_assert(g-&gt;gray == NULL);
  return work;  /* estimate of slots marked by 'atomic' */
}
</code></pre><ul>
<li>可以看到，该阶段的标记过程，还是从 lua 栈、注册表、基础类型元表为起点进行检查标记。传播阶段中的 g->grayagain 、g->ephemeron 会在这个全部进行遍历标记，g->weak 、g->allweak 弱表列表，也会在这个阶段进行清除。</li>
<li>完成所有标记操作后，会将 g->currentwhite 切换为另一种白色，在这之后新建的对象，则不会在这轮 gc 中处理。</li>
<li>和传播阶段相比，原子阶段的标记操作是一步到位的，需要将所有对象都标记完成，才会执行其他操作，这个过程不能中断。</li>
<li>完成标记后，会执行清除阶段的准备过程。</li>
</ul>
<pre tabindex=0><code>// lgc.c

static void entersweep (lua_State *L) {
  global_State *g = G(L);
  g-&gt;gcstate = GCSswpallgc;
  lua_assert(g-&gt;sweepgc == NULL);
  g-&gt;sweepgc = sweeptolive(L, &amp;g-&gt;allgc);
}

static GCObject **sweeptolive (lua_State *L, GCObject **p) {
  GCObject **old = p;
  do {
    p = sweeplist(L, p, 1, NULL);
  } while (p == old);
  return p;
}
</code></pre><ul>
<li>进入清除阶段前，会对 g->allgc 进行清除处理，直到找到第一个还有引用的对象，转为白色后，将其下一个对象设置到 g->sweepgc 上，清除阶段就能直接对 g->sweepgc 进行处理，而不需要都从 g->allgc 开始，也不会影响 g->allgc 的值。</li>
</ul>
<h4 id=清除阶段gcsswpallgc---gcsswpfinobj---gcsswptobefnz---gcsswpend>清除阶段（GCSswpallgc -> GCSswpfinobj -> GCSswptobefnz -> GCSswpend）</h4>
<ul>
<li>清除阶段主要对几个列表处理，包括 g->allgc 、g->finobj 、g->tobefnz。对 g->sweepgc 进行清除后，再依次将下一个列表设置到 g->sweepgc ，继续处理。清除的代码如下：</li>
</ul>
<pre tabindex=0><code>// lgc.c

static int sweepstep (lua_State *L, global_State *g,
                      int nextstate, GCObject **nextlist) {
  if (g-&gt;sweepgc) {
    l_mem olddebt = g-&gt;GCdebt;
    int count;
    g-&gt;sweepgc = sweeplist(L, g-&gt;sweepgc, GCSWEEPMAX, &amp;count);
    g-&gt;GCestimate += g-&gt;GCdebt - olddebt;  /* update estimate */
    return count;
  }
  else {  /* enter next state */
    g-&gt;gcstate = nextstate;
    g-&gt;sweepgc = nextlist;
    return 0;  /* no work done */
  }
}

static GCObject **sweeplist (lua_State *L, GCObject **p, int countin,
                             int *countout) {
  global_State *g = G(L);
  int ow = otherwhite(g);
  int i;
  int white = luaC_white(g);  /* current white */
  for (i = 0; *p != NULL &amp;&amp; i &lt; countin; i++) {
    GCObject *curr = *p;
    int marked = curr-&gt;marked;
    if (isdeadm(ow, marked)) {  /* is 'curr' dead? */
      *p = curr-&gt;next;  /* remove 'curr' from list */
      freeobj(L, curr);  /* erase 'curr' */
    }
    else {  /* change mark to 'white' */
      curr-&gt;marked = cast_byte((marked &amp; ~maskgcbits) | white);
      p = &amp;curr-&gt;next;  /* go to next element */
    }
  }
  if (countout)
    *countout = i;  /* number of elements traversed */
  return (*p == NULL) ? NULL : p;
}
</code></pre><ul>
<li>清除的步骤为，检查每个对象的标记：
<ul>
<li>如果为白色，则表示该对象已经没有引用，将对象释放，并将 g->GCdebt 减去该对象释放的大小。</li>
<li>如果不为白色，则将该对象的标记设置为新的白色。</li>
</ul>
</li>
<li>每次清除的最大数量为 100 （GCSWEEPMAX）个对象，当前列表完全清除后，才会进入下一个状态清除下一个列表。</li>
<li>所有列表清除完成后，就切换到 GCSswpend 状态，此时会进行字符串缓存的检查。</li>
</ul>
<pre tabindex=0><code>// lgc.c 

static void checkSizes (lua_State *L, global_State *g) {
  if (!g-&gt;gcemergency) {
    if (g-&gt;strt.nuse &lt; g-&gt;strt.size / 4) {  /* string table too big? */
      l_mem olddebt = g-&gt;GCdebt;
      luaS_resize(L, g-&gt;strt.size / 2);
      g-&gt;GCestimate += g-&gt;GCdebt - olddebt;  /* correct estimate */
    }
  }
}
</code></pre><ul>
<li>常规 gc 时，g->strt.nuse 为字符串缓存表当前 TString 的数量，如果小于当前大小的 1/4 ，则需要将 strt 缩小为当前大小的 1/2 ，</li>
</ul>
<h4 id=析构阶段gcsswpend---gcscallfin---gcspause>析构阶段（GCSswpend -> GCScallfin -> GCSpause）</h4>
<ul>
<li>析构阶段主要是对 g->tobefnz 列表的 userdata 对象，执行析构函数，每个析构函数等价于 50（GCFINALIZECOST）个 TValue 处理对象。</li>
<li>处理完成后，就切换到 GCSpause 状态，本次 gc 循环结束。</li>
</ul>
<h3 id=单步-gc>单步 GC</h3>
<ul>
<li>lua gc 的各个阶段，每次执行都是一次单步 gc 的操作，单步 gc 通过调用 luaC_step 方法实现。单步 gc 的触发方式有：
<ul>
<li>lua 中调用 collectgarbage(&ldquo;step&rdquo;) 方法。</li>
<li>部分操作完成后，调用 luaC_condGC 方法，尝试进行 gc 。相关的操作主要有：
<ul>
<li>lua_tolstring ：将栈上的 lua 值转为 c 字符串。</li>
<li>lua_pushlstring ：将指针指向的指定长度的字符串，转为 lua 字符串后入栈。</li>
<li>lua_pushstring ：将指针指向的以'\0&rsquo;结尾的字符串，转为 lua 字符串后入栈。</li>
<li>lua_pushvfstring/lua_pushfstring ：将格式化后的字符串，转为 lua 字符串后入栈。</li>
<li>lua_pushcclosure ：创建一个 lua 闭包后入栈。</li>
<li>lua_createtable ：创建一个空表后入栈。</li>
<li>lua_concat ：字符串拼接。</li>
<li>lua_newuserdatauv ：创建 userdata 后入栈。</li>
<li>&mldr;</li>
</ul>
</li>
</ul>
</li>
<li>可以看到，在 lua 中创建需要 gc 的对象时，就会尝试进行一次单步 gc 。因此，在整个 lua 运行过程，gc 的过程基本上是一直在背后不断进行的，通常不需要手动调用 collectgarbage(&ldquo;collect&rdquo;) 来进行垃圾回收。</li>
</ul>
<h4 id=触发条件>触发条件</h4>
<ul>
<li>luaC_condGC 的代码实现如下：</li>
</ul>
<pre tabindex=0><code>// lgc.h

#define luaC_condGC(L,pre,pos) \
	{ if (G(L)-&gt;GCdebt &gt; 0) { pre; luaC_step(L); pos;}; \
	  condchangemem(L,pre,pos); }
</code></pre><ul>
<li>调用 luaC_condGC 方法时，并不是每次都会触发 luaC_step 方法进行单步 gc ，只有当 GCdebt > 0 时，gc 才会继续进行。而 GCdebt 的修改方式有：
<ul>
<li>创建新对象的时候，GCdebt 加上新增对象的大小。</li>
<li>释放对象的时候，GCdebt 会减去释放对象的大小。</li>
<li>执行 luaC_step 后，如果本轮 gc 没完成，则会修改 GCdebt 的值。</li>
</ul>
</li>
<li>GCdebt 修改的代码如下：</li>
</ul>
<pre tabindex=0><code>// lgc.c

static void incstep (lua_State *L, global_State *g) {
  int stepmul = (getgcparam(g-&gt;gcstepmul) | 1);  /* avoid division by 0 */
  l_mem debt = (g-&gt;GCdebt / WORK2MEM) * stepmul;
  l_mem stepsize = (g-&gt;gcstepsize &lt;= log2maxs(l_mem))
                 ? ((cast(l_mem, 1) &lt;&lt; g-&gt;gcstepsize) / WORK2MEM) * stepmul
                 : MAX_LMEM;  /* overflow; keep maximum value */
  do {  /* repeat until pause or enough &quot;credit&quot; (negative debt) */
    lu_mem work = singlestep(L);  /* perform one single step */
    debt -= work;
  } while (debt &gt; -stepsize &amp;&amp; g-&gt;gcstate != GCSpause);
  if (g-&gt;gcstate == GCSpause)
    setpause(g);  /* pause until next cycle */
  else {
    debt = (debt / stepmul) * WORK2MEM;  /* convert 'work units' to bytes */
    luaE_setdebt(g, debt);
  }
}

/*
** performs a basic GC step if collector is running
*/
void luaC_step (lua_State *L) {
  global_State *g = G(L);
  lua_assert(!g-&gt;gcemergency);
  if (g-&gt;gcrunning) {  /* running? */
    if(isdecGCmodegen(g))
      genstep(L, g);
    else
      incstep(L, g);
  }
}
</code></pre><ul>
<li></li>
</ul>
<hr>
<ul class=pager>
<li class=previous>
<a href=/post/lua/lua_table/ data-toggle=tooltip data-placement=top title="Lua篇 — 表">&larr;
Previous Post</a>
</li>
</ul>
<div id=disqus-comment></div>
</div>
<div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container">
<div class=side-catalog>
<hr class="hidden-sm hidden-xs">
<h5>
<a class=catalog-toggle href=#>CATALOG</a>
</h5>
<ul class=catalog-body></ul>
</div>
</div>
<div class="col-lg-11 col-lg-offset-1
col-md-10 col-md-offset-1
sidebar-container">
</div>
</div>
</div>
</article>
<footer>
<div class=container>
<div class=row>
<div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
<ul class="list-inline text-center">
</ul>
<p class="copyright text-muted">
Copyright &copy; Xun's Blog 2024
<br>
<a href=https://themes.gohugo.io/hugo-theme-cleanwhite>CleanWhite Hugo Theme</a> by <a href=https://zhaohuabing.com>Huabing</a> |
<iframe style=margin-left:2px;margin-bottom:-5px frameborder=0 scrolling=0 width=100px height=20px src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true"></iframe>
</p>
</div>
</div>
</div>
</footer>
<script>function loadAsync(f,b){var c=document,d='script',a=c.createElement(d),e=c.getElementsByTagName(d)[0];a.src=f,b&&a.addEventListener('load',function(a){b(null,a)},!1),e.parentNode.insertBefore(a,e)}</script>
<script>$('#tag_cloud').length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:'#bbbbee',end:'#0085a1'}},$('#tag_cloud a').tagcloud()})</script>
<script>loadAsync("https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.js",function(){var a=document.querySelector("nav");a&&FastClick.attach(a)})</script>
<script type=text/javascript>function generateCatalog(a){_containerSelector='div.post-container';var h=$(_containerSelector),c,d,e,f,g,b;return c=h.find('h1,h2,h3,h4,h5,h6'),$(a).html(''),c.each(function(){d=$(this).prop('tagName').toLowerCase(),g="#"+$(this).prop('id'),e=$(this).text(),b=$('<a href="'+g+'" rel="nofollow">'+e+'</a>'),f=$('<li class="'+d+'_nav"></li>').append(b),$(a).append(f)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(a){a.preventDefault(),$('.side-catalog').toggleClass("fold")}),loadAsync("/js/jquery.nav.js",function(){$('.catalog-body').onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script>
</body>
</html>
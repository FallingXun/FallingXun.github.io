<!doctype html><html lang=zh-cn>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta property="og:site_name" content="Xun's Blog">
<meta property="og:type" content="article">
<meta property="og:image" content="https://fallingxun.github.io//">
<meta property="twitter:image" content="https://fallingxun.github.io//">
<meta name=title content="Lua篇 — (3) xLua">
<meta property="og:title" content="Lua篇 — (3) xLua">
<meta property="twitter:title" content="Lua篇 — (3) xLua">
<meta name=description content>
<meta property="og:description" content>
<meta property="twitter:description" content>
<meta property="twitter:card" content="summary">
<meta name=keyword content>
<link rel="shortcut icon" href=/img/favicon.ico>
<title>Lua篇 — (3) xLua-</title>
<link rel=canonical href=/post/lua/lua_xlua/>
<link rel=stylesheet href=/css/iDisqus.min.css>
<link rel=stylesheet href=/css/bootstrap.min.css>
<link rel=stylesheet href=/css/hugo-theme-cleanwhite.min.css>
<link rel=stylesheet href=/css/zanshang.css>
<link href=//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css rel=stylesheet type=text/css>
<script src=/js/jquery.min.js></script>
<script src=/js/bootstrap.min.js></script>
<script src=/js/hux-blog.min.js></script>
</head>
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
<div class=container-fluid>
<div class="navbar-header page-scroll">
<button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=/>Xun's Blog</a>
</div>
<div id=huxblog_navbar>
<div class=navbar-collapse>
<ul class="nav navbar-nav navbar-right">
<li>
<a href=/>Home</a>
</li>
<li>
<a href=/categories/googleplay%E7%B3%BB%E5%88%97>googleplay系列</a>
</li>
<li>
<a href=/categories/lua%E7%B3%BB%E5%88%97>lua系列</a>
</li>
<li>
<a href=/categories/tmp%E7%B3%BB%E5%88%97>tmp系列</a>
</li>
</ul>
</div>
</div>
</div>
</nav>
<script>var $body=document.body,$toggle=document.querySelector('.navbar-toggle'),$navbar=document.querySelector('#huxblog_navbar'),$collapse=document.querySelector('.navbar-collapse');$toggle.addEventListener('click',handleMagic);function handleMagic(a){$navbar.className.indexOf('in')>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf('in')<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script>
<style type=text/css>header.intro-header{background-image:url('/')}</style>
<header class=intro-header>
<div class=container>
<div class=row>
<div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
<div class=post-heading>
<div class=tags>
<a class=tag href=/tags/lua title=Lua>
Lua
</a>
<a class=tag href=/tags/xlua title=xLua>
xLua
</a>
</div>
<h1>Lua篇 — (3) xLua</h1>
<h2 class=subheading></h2>
<span class=meta>
Posted by
Xun
on
Thursday, November 4, 2021
</span>
</div>
</div>
</div>
</div>
</header>
<article>
<div class=container>
<div class=row>
<div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container">
<p>由于很多旧项目是以CSharp开发的，热更时就会遇到难题。而xLua框架的出现，让很多项目能够在改动最小的情况下，支持热更新功能。</p>
<h3 id=简介>简介</h3>
<h3 id=初始化>初始化</h3>
<h4 id=创建luaenv>创建LuaEnv</h4>
<ul>
<li>Lua状态机的创建方法主要实现如下</li>
</ul>
<pre tabindex=0><code>    public LuaEnv()
    {

        ...
                
        rawL = LuaAPI.luaL_newstate();

        //Init Base Libs
        LuaAPI.luaopen_xlua(rawL);
        LuaAPI.luaopen_i64lib(rawL);

        translator = new ObjectTranslator(this, rawL);
        translator.createFunctionMetatable(rawL);
        translator.OpenLib(rawL);
        ObjectTranslatorPool.Instance.Add(rawL, translator);

        LuaAPI.lua_atpanic(rawL, StaticLuaCallbacks.Panic);

#if !XLUA_GENERAL
        LuaAPI.lua_pushstdcallcfunction(rawL, StaticLuaCallbacks.Print);
        if (0 != LuaAPI.xlua_setglobal(rawL, &quot;print&quot;))
        {
            throw new Exception(&quot;call xlua_setglobal fail!&quot;);
        }
#endif

        //template engine lib register
        TemplateEngine.LuaTemplate.OpenLib(rawL);

        AddSearcher(StaticLuaCallbacks.LoadBuiltinLib, 2); // just after the preload searcher
        AddSearcher(StaticLuaCallbacks.LoadFromCustomLoaders, 3);
#if !XLUA_GENERAL
        AddSearcher(StaticLuaCallbacks.LoadFromResource, 4);
        AddSearcher(StaticLuaCallbacks.LoadFromStreamingAssetsPath, -1);
#endif
        DoString(init_xlua, &quot;Init&quot;);
        init_xlua = null;

#if (!UNITY_SWITCH &amp;&amp; !UNITY_WEBGL) || UNITY_EDITOR
        AddBuildin(&quot;socket.core&quot;, StaticLuaCallbacks.LoadSocketCore);
        AddBuildin(&quot;socket&quot;, StaticLuaCallbacks.LoadSocketCore);
#endif

        AddBuildin(&quot;CS&quot;, StaticLuaCallbacks.LoadCS);

        LuaAPI.lua_newtable(rawL); //metatable of indexs and newindexs functions
        LuaAPI.xlua_pushasciistring(rawL, &quot;__index&quot;);
        LuaAPI.lua_pushstdcallcfunction(rawL, StaticLuaCallbacks.MetaFuncIndex);
        LuaAPI.lua_rawset(rawL, -3);

        LuaAPI.xlua_pushasciistring(rawL, Utils.LuaIndexsFieldName);
        LuaAPI.lua_newtable(rawL);
        LuaAPI.lua_pushvalue(rawL, -3);
        LuaAPI.lua_setmetatable(rawL, -2);
        LuaAPI.lua_rawset(rawL, LuaIndexes.LUA_REGISTRYINDEX);

        LuaAPI.xlua_pushasciistring(rawL, Utils.LuaNewIndexsFieldName);
        LuaAPI.lua_newtable(rawL);
        LuaAPI.lua_pushvalue(rawL, -3);
        LuaAPI.lua_setmetatable(rawL, -2);
        LuaAPI.lua_rawset(rawL, LuaIndexes.LUA_REGISTRYINDEX);

        LuaAPI.xlua_pushasciistring(rawL, Utils.LuaClassIndexsFieldName);
        LuaAPI.lua_newtable(rawL);
        LuaAPI.lua_pushvalue(rawL, -3);
        LuaAPI.lua_setmetatable(rawL, -2);
        LuaAPI.lua_rawset(rawL, LuaIndexes.LUA_REGISTRYINDEX);

        LuaAPI.xlua_pushasciistring(rawL, Utils.LuaClassNewIndexsFieldName);
        LuaAPI.lua_newtable(rawL);
        LuaAPI.lua_pushvalue(rawL, -3);
        LuaAPI.lua_setmetatable(rawL, -2);
        LuaAPI.lua_rawset(rawL, LuaIndexes.LUA_REGISTRYINDEX);

        LuaAPI.lua_pop(rawL, 1); // pop metatable of indexs and newindexs functions

        LuaAPI.xlua_pushasciistring(rawL, MAIN_SHREAD);
        LuaAPI.lua_pushthread(rawL);
        LuaAPI.lua_rawset(rawL, LuaIndexes.LUA_REGISTRYINDEX);

        LuaAPI.xlua_pushasciistring(rawL, CSHARP_NAMESPACE);
        if (0 != LuaAPI.xlua_getglobal(rawL, &quot;CS&quot;))
        {
            throw new Exception(&quot;get CS fail!&quot;);
        }
        LuaAPI.lua_rawset(rawL, LuaIndexes.LUA_REGISTRYINDEX);

#if !XLUA_GENERAL &amp;&amp; (!UNITY_WSA || UNITY_EDITOR)
        translator.Alias(typeof(Type), &quot;System.MonoType&quot;);
#endif

        if (0 != LuaAPI.xlua_getglobal(rawL, &quot;_G&quot;))
        {
            throw new Exception(&quot;get _G fail!&quot;);
        }
        translator.Get(rawL, -1, out _G);
        LuaAPI.lua_pop(rawL, 1);

        errorFuncRef = LuaAPI.get_error_func_ref(rawL);

        if (initers != null)
        {
            for (int i = 0; i &lt; initers.Count; i++)
            {
                initers[i](this, translator);
            }
        }

        translator.CreateArrayMetatable(rawL);
        translator.CreateDelegateMetatable(rawL);
        translator.CreateEnumerablePairs(rawL);
    }

</code></pre><ul>
<li>xLua的状态机构造函数比较庞大，将所有初始化操作全部集中在这里，接下来将逐一来分析其作用（以lua-5.3.5为例）。</li>
</ul>
<h4 id=初始化相关库>初始化相关库</h4>
<ul>
<li>LuaAPI.luaopen_xlua
<ul>
<li>初始化lua侧的基本库，包括package、coroutine、table、io、os、string、math、utf8、debug等。</li>
</ul>
</li>
<li>LuaAPI.luaopen_i64lib
<ul>
<li>初始化64位整型，包括int64和uint64。</li>
</ul>
</li>
</ul>
<h4 id=objecttranslator>ObjectTranslator</h4>
<ul>
<li>ObjectTranslator中进行了一些初始化操作，主要为：
<ul>
<li>缓存程序集，包括当前运行的程序集、mscorlib、System、System.Core。</li>
<li>创建ObjectCaster，初始化基本类型、LuaTable、LuaFunction的转化委托（返回object）。</li>
<li>创建ObjectCheckers，初始化基本类型、LuaTable、LuaFunction的类型检查。</li>
<li>创建MethodWrapsCache，建立运行时方法Wrap的缓存。</li>
<li>创建StaticLuaCallbacks，将一些常用的方法转成LuaFunction：
<ul>
<li>LuaGC：lua对象gc回收。</li>
<li>ToString：调用CSharp的ToString。</li>
<li>EnumAnd：枚举与操作。</li>
<li>EnumOr：枚举或操作。</li>
<li>StaticCSFunction：lua方法委托。</li>
<li>FixCSFunction：lua修复的方法委托。</li>
<li>DelegateConstructor：委托构造方法。</li>
</ul>
</li>
<li>将一些特殊方法转成LuaFunction：
<ul>
<li>StaticLuaCallbacks.ImportType：注册CSharp的class到lua侧。</li>
<li>StaticLuaCallbacks.LoadAssembly：加载程序集到ObjectTranslator.assemblies。</li>
<li>StaticLuaCallbacks.Cast：将某个对象的metatable设置为CSharp的class。</li>
</ul>
</li>
<li>创建一个表放入 LUA_REGISTRYINDEX 表，id为 ObjectTranslator.cacheRef，再创建一个值弱表（{__mode = &ldquo;v&rdquo;}），设置为此表的metatable。</li>
<li>创建 LuaCSFunction 的 metatable，包含__gc方法，放入 LUA_REGISTRYINDEX 表。</li>
<li>注册方法到lua侧：
<ul>
<li>xlua.import_type：CSharp侧的StaticLuaCallbacks.ImportType。</li>
<li>xlua.import_generic_type：CSharp侧的StaticLuaCallbacks.ImportGenericType。</li>
<li>xlua.cast：CSharp侧的StaticLuaCallbacks.Cast。</li>
<li>xlua.load_assembly：CSharp侧的StaticLuaCallbacks.LoadAssembly。</li>
<li>xlua.access：CSharp侧的StaticLuaCallbacks.XLuaAccess。</li>
<li>xlua.private_accessible：CSharp侧的StaticLuaCallbacks.XLuaPrivateAccessible。</li>
<li>xlua.metatable_operation：CSharp侧的StaticLuaCallbacks.XLuaMetatableOperation。</li>
<li>xlua.tofunction：CSharp侧的StaticLuaCallbacks.ToFunction。</li>
<li>xlua.get_generic_method：CSharp侧的StaticLuaCallbacks.GetGenericMethod。</li>
<li>xlua.release：CSharp侧的StaticLuaCallbacks.ReleaseCsObject。</li>
</ul>
</li>
<li>创建新表存入 LUA_REGISTRYINDEX 表，作为array的metatable，id为 common_array_meta。</li>
<li>创建新表存入 LUA_REGISTRYINDEX 表，作为delegate的metatable，id为 common_delegate_meta。</li>
</ul>
</li>
</ul>
<h4 id=初始化lua环境>初始化lua环境</h4>
<ul>
<li>执行 init_xlua 脚本，对lua环境进行初始化：
<ul>
<li>创建 CS 表，设置metatable方法：
<ul>
<li>__index方法：查找对应的类型，如：CS.UnityEngine.GameObject，则调起CSharp侧的 StaticLuaCallbacks.ImportType，将CSharp侧的类注册到lua侧，并将此类型缓存到 CS 表中。</li>
<li>__newindex方法：输出报错信息，当前没有这个类型。</li>
<li>__call方法：泛型类对象获取，如：CS.System.Collections.Generic.List(CS.System.String)，则会调起 StaticLuaCallbacks.ImportGenericType，获取指定类型的泛型type。由于每次调用都会触发 StaticLuaCallbacks.ImportGenericType 方法，而此方法中使用Type.MakeGenericType来构造泛型对象，需要创建Type数组，所以会有gc产生，可以缓存对象重复使用。</li>
</ul>
</li>
<li>注册 typeof 方法为CSharp的 Type.UnderlyingSystemType。</li>
<li>注册 setfenv 和 getfenv 方法。</li>
<li>注册 xlua.hotfix 方法，可以进行热修复。</li>
<li>注册 xlua.setmetatable 方法为 xlua.metatable_operation(cs)。</li>
<li>注册 xlua.setmetatable 方法为 xlua.metatable_operation(cs, mt)。</li>
<li>注册 xlua.setclass 方法，可实现CSharp的class或者struct在lua侧改造。</li>
<li>注册 base 方法，可实现调用CSharp父类对象方法（Hotfix.BASE_RPOXY_PERFIX标识）。</li>
</ul>
</li>
</ul>
<h4 id=方法设置>方法设置</h4>
<ul>
<li>注册lua侧的print方法为CSharp侧的StaticLuaCallbacks.Print。</li>
<li>设置lua侧的package.seachers方法，用于require调起：
<ul>
<li>package.seachers[2]（即 searcher_Lua）设置为CSharp侧的StaticLuaCallbacks.LoadBuiltinLib。</li>
<li>package.seachers[3]（即 searcher_C）设置为CSharp侧的StaticLuaCallbacks.LoadFromCustomLoaders。</li>
<li>package.seachers[4]（即 searcher_Croot）设置为CSharp侧的StaticLuaCallbacks.LoadFromResource。</li>
<li>package.seachers[5]（即 NULL）设置为CSharp侧的StaticLuaCallbacks.LoadFromStreamingAssetsPath。</li>
</ul>
</li>
<li>设置CSharp侧LoadBuiltinLib的查找字典LuaEnv.buildin_initer，当调用package.seachers[2]时，会从字典中中找：
<ul>
<li>socket.core：CSharp侧的StaticLuaCallbacks.LoadSocketCore。</li>
<li>socket：CSharp侧的StaticLuaCallbacks.LoadSocketCore。</li>
<li>CS：CSharp侧的StaticLuaCallbacks.LoadCS，获取 LUA_REGISTRYINDEX 表里的 xlua_csharp_namespace 表。</li>
</ul>
</li>
<li>设置index和newindex相关表：
<ul>
<li>创建新表meta，设置 __index 方法为CSharp侧的 StaticLuaCallbacks.MetaFuncIndex，查找当前表里对应type的内容。</li>
<li>创建新表，key值为 LuaIndexs，存入 LUA_REGISTRYINDEX 中，设置其metatable为meta表。</li>
<li>创建新表，key值为 LuaNewIndexs，存入 LUA_REGISTRYINDEX 中，设置其metatable为meta表。</li>
<li>创建新表，key值为 LuaClassIndexs，存入 LUA_REGISTRYINDEX 中，设置其metatable为meta表。</li>
<li>创建新表，key值为 LuaClassNewIndexs，存入 LUA_REGISTRYINDEX 中，设置其metatable为meta表。</li>
</ul>
</li>
<li>设置主线程到 LUA_REGIXTRYINDEX 中，key值为 xlua_main_thread。</li>
<li>将 _G 中的 CS 表，存入 LUA_REGISTRYINDEX 中，key值为 xlua_csharp_namespace。</li>
<li>初始化前面创建的array的metatable，进行相关注册：
<ul>
<li>__gc 方法设为CSharp侧的 StaticLuaCallbacks.LuaGC。</li>
<li>__tostring 方法设为CSharp侧的 StaticLuaCallbacks.ToString。</li>
<li>Length 方法设为CSharp侧的 StaticLuaCallbacks.ArrayLength。</li>
<li>__index 方法设为CSharp侧的 StaticLuaCallbacks.ArrayIndexer。</li>
<li>__newindex 方法设为CSharp侧的 StaticLuaCallbacks.ArrayNewIndexer。</li>
</ul>
</li>
<li>初始化前面创建的delegate的metatable，进行相关注册：
<ul>
<li>__gc 方法设为CSharp侧的 StaticLuaCallbacks.LuaGC。</li>
<li>__tostring 方法设为CSharp侧的 StaticLuaCallbacks.ToString。</li>
<li>__call 方法设为CSharp侧的 StaticLuaCallbacks.DelegateCall。</li>
<li>__add 方法设为CSharp侧的 StaticLuaCallbacks.DelegateCombine。</li>
<li>__sub 方法设为CSharp侧的 StaticLuaCallbacks.DelegateRemove。</li>
<li>__index 方法设为CSharp侧的 StaticLuaCallbacks.ArrayIndexer。</li>
<li>__newindex 方法设为CSharp侧的 StaticLuaCallbacks.ArrayNewIndexer。</li>
</ul>
</li>
<li>创建迭代访问Pairs方法，存入到 LUA_REGISTRYINDEX 中，id为 enumerable_pairs_func。</li>
</ul>
<h4 id=结构>结构</h4>
<ul>
<li>经过初始化后，当前lua侧的结构大致如下：</li>
</ul>
<pre tabindex=0><code>    _G = {
        ...

        xlua.import_type = CSharp侧的StaticLuaCallbacks.ImportType
        xlua.import_generic_type = CSharp侧的StaticLuaCallbacks.ImportGenericType
        xlua.cast = CSharp侧的StaticLuaCallbacks.Cast
        xlua.load_assembly = CSharp侧的StaticLuaCallbacks.LoadAssembly
        xlua.access = CSharp侧的StaticLuaCallbacks.XLuaAccess
        xlua.private_accessible = CSharp侧的StaticLuaCallbacks.XLuaPrivateAccessible
        xlua.metatable_operation = CSharp侧的StaticLuaCallbacks.XLuaMetatableOperation
        xlua.tofunction = CSharp侧的StaticLuaCallbacks.ToFunction
        xlua.get_generic_method = CSharp侧的StaticLuaCallbacks.GetGenericMethod
        xlua.release = CSharp侧的StaticLuaCallbacks.ReleaseCsObject

        CS（所有CSharp的对应表） = LUA_REGISTRYINDEX 表中的 xlua_csharp_namespace 表

        typeof = CSharp的 Type.UnderlyingSystemType
        setfenv = CSharp侧 LuaEnv.init_xlua 中的 setfenv
        getfenv = CSharp侧 LuaEnv.init_xlua 中的 getfenv
        xlua.hotfix = CSharp侧 LuaEnv.init_xlua 中的 xlua.hotfix
        xlua.setmetatable = xlua.metatable_operation(cs)
        xlua.setmetatable = xlua.metatable_operation(cs, mt)
        xlua.setclass = CSharp侧 LuaEnv.init_xlua 中的 xlua.setclass
        base = CSharp侧 LuaEnv.init_xlua 中的 base

        print = CSharp侧的 StaticLuaCallbacks.Print
    }

    -10000（即 LUA_REGISTRYINDEX） = {
        ...

        ref_cacheRef（分配的id，在CSharp侧为 ObjectTranslator.cacheRef）
            table = {

            },
            metatable = {
                __mode = v
            }

        ref_LuaCSFunction（分配的id，在CSharp侧存到 ObjectTranslator.typeIdMap） = {
            __gc = CSharp侧的 StaticLuaCallbacks.LuaGC,
            &amp;tag = 1
        }

        ref_common_array_meta = {
            __gc = CSharp侧的 StaticLuaCallbacks.LuaGC
            __tostring = CSharp侧的 StaticLuaCallbacks.ToString
            Length = CSharp侧的 StaticLuaCallbacks.ArrayLength
            __index = CSharp侧的 StaticLuaCallbacks.ArrayIndexer
            __newindex = CSharp侧的 StaticLuaCallbacks.ArrayNewIndexer           
        }

        ref_common_delegate_meta = {
            __gc = CSharp侧的 StaticLuaCallbacks.LuaGC
            __tostring = CSharp侧的 StaticLuaCallbacks.ToString
            __call = CSharp侧的 StaticLuaCallbacks.DelegateCall

            __add = CSharp侧的 StaticLuaCallbacks.DelegateCombine
            __sub = CSharp侧的 StaticLuaCallbacks.DelegateRemove
            __index = CSharp侧的 StaticLuaCallbacks.ArrayIndexer
            __newindex = CSharp侧的 StaticLuaCallbacks.ArrayNewIndexer
        }

        ref_enumerable_pairs_func = CSharp侧 ObjectTranslator.CreateEnumerablePairs方法中的lua代码方法

        LuaIndexs ：
            table = {},
            metatable = meta表 {
                __index = StaticLuaCallbacks.MetaFuncIndex
            }

        LuaNewIndexs ：
            table = {},
            metatable = meta表 

        LuaClassIndexs ：
            table = {},
            metatable = meta表 
        
        LuaClassNewIndexs ：
            table = {},
            metatable = meta表 

        xlua_csharp_namespace ：
            table = {

            },
            metatable = {
                __index = CSharp侧 LuaEnv.init_xlua 中的 __index(key),
                __newindex = CSharp侧 LuaEnv.init_xlua 中的 __newindex(),
                __call = CSharp侧 LuaEnv.init_xlua 中的 __call(...),
            }
    }
</code></pre><h3 id=访问对象>访问对象</h3>
<h4 id=lua访问csharp对象>Lua访问CSharp对象</h4>
<ul>
<li>当我们在Lua侧，要获取CSharp对象时，以GameObject为例，当我们查找某个GameObject时，在lua侧会使用</li>
</ul>
<pre tabindex=0><code>    -- Test.lua

    local go = CS.UnityEngine.GameObject.Find(&quot;TestGameObject&quot;);
</code></pre><ul>
<li>调用CSharp侧的GameObject.Find来获取对象，这里有几个步骤：
<ul>
<li>获取 _G.CS 表，查找 CS.UnityEngine 对象。</li>
<li>CS 表中不存在 UnityEngine，则触发CSharp侧的 StaticLuaCallbacks.ImportType方法，查找对应类。</li>
<li>由于UnityEngine不为class，所以设置 CS.UnityEngine 的 table 为 { &ldquo;.fqn&rdquo; = &ldquo;UnityEngine&rdquo; }，metatable为CS表的metatable。</li>
<li>查找GameObject对象，同样触发CSharp侧的 StaticLuaCallbacks.ImportType方法，查找UnityEngine.GameObject，并注册到lua侧中。</li>
<li>查找Find方法，传入参数并执行，触发CSharp侧的 GameObject.Find 方法，找到对应的GameObject。</li>
<li>调用ObjectTranslator.Push，创建index，返回lua侧。</li>
<li>lua侧使用index创建userdata，持有GameObject对象。</li>
</ul>
</li>
<li>在整个过程中，有两个步骤是比较重要的：
<ul>
<li>把CSharp的类注册到Lua侧。</li>
<li>将CSharp的对象绑定到Lua侧。</li>
</ul>
</li>
</ul>
<h5 id=注册csharp类>注册CSharp类</h5>
<ul>
<li>注册CSharp类的主要方法为 ObjectTranslator.GetTypeId ，其主要流程为：
<ul>
<li>查找 ObjectTranslator.typeIdMap 中是否有对应类型，有则直接返回。</li>
<li>如果是 Array 类型，则返回 common_array_meta 。</li>
<li>如果是 MulticastDelegate 类型，调用 TryDelayWrapLoader 方法创建类型的metatable。</li>
<li>如果 LUA_REGISTRYINDEX 表中没有此类型的metatable，则调用 TryDelayWrapLoader 方法创建（key值为type.FullName）。</li>
<li>如果是 Enum 类型，则在metatable中设置方法：
<ul>
<li>__band 设置为 StaticLuaCallbacks.EnumAnd。</li>
<li>__bor 设置为 StaticLuaCallbacks.EnumOr。</li>
</ul>
</li>
<li>如果是 IEnumerable 类型，则设置 __pairs 为 ref_enumerable_pairs_func的方法。</li>
<li>将此metatable存到 LUA_REGISTRYINDEX 表中，id为lua侧创建的引用 type_id。</li>
<li>将 type_id 存入 typeIdMap 中。</li>
</ul>
</li>
<li>ObjectTranslator.TryDelayWrapLoader 为创建metatable的方法，主要有两种方式：
<ul>
<li>预先生成CSharp侧的Wrap脚本，将类型和 XXXWrap.__Register 存入ObjectTranslator.delayWrap中，通过调用 __Register 方法，进行注册。</li>
<li>通过反射进行注册。</li>
</ul>
</li>
</ul>
<h6 id=wrap注册>Wrap注册</h6>
<ul>
<li>Wrap方式主要是预先生成Wrap文件，然后通过 __Register 方法初始化，主要有以下方法：
<ul>
<li>Utils.BeginObjectRegister：注册类实例对象相关信息。
<ul>
<li>将type的对应metatable压入栈上。</li>
<li>如果传入type为空，或者type不为ObjectTranslator.custom_push_funcs（即[LuaCallCSharp]的Enum、[GCOptimize]），且不为decimal，则设置 __gc 方法为CSharp侧的 StaticLuaCallbacks.LuaGC。</li>
<li>设置 __tostring 方法为CSharp侧的 StaticLuaCallbacks.ToString。</li>
<li>如果方法数量（method_count）不为0，则创建method_count大小的table到栈上，否则压入nil。</li>
<li>如果get属性数量（getter_count）不为0，则创建getter_count大小的table到栈上，否则压入nil。</li>
<li>如果set属性数量（setter_count）不为0，则创建setter_count大小的table到栈上，否则压入nil。</li>
<li>当前栈顶的情况为：
<ul>
<li>-1 ： set的table</li>
<li>-2 ： get的table</li>
<li>-3 ： method的table</li>
<li>-4 ： type的metatable</li>
</ul>
</li>
</ul>
</li>
<li>Utils.RegisterFunc：注册方法。
<ul>
<li>传入注册的方法的类型idx，和入栈顺序对应上：
<ul>
<li>Utils.OBJ_META_IDX：-4，metatable。</li>
<li>Utils.METHOD_IDX、Utils.：-3，普通方法表。</li>
<li>Utils.GETTER_IDX：-2，get方法表。</li>
<li>Utils.SETTER_IDX：-1，set方法表。</li>
<li>Utils.CLS_IDX：-4，class的table。</li>
<li>Utils.CLS_META_IDX：-3，class的metatable。</li>
<li>Utils.CLS_GETTER_IDX：-2，class的get方法表。</li>
<li>Utils.CLS_SETTER_IDX：-1，class的set方法表。</li>
</ul>
</li>
<li>获取方法在栈上的位置（栈顶位置 + idx + 1）。</li>
<li>将方法名和方法设置到栈上对应位置的table中。</li>
</ul>
</li>
<li>Utils.EndObjectRegister：完成实例对象注册。
<ul>
<li>设置metatable的__index：
<ul>
<li>将"__index"字符串入栈。</li>
<li>将method的table入栈。</li>
<li>将get的table入栈。</li>
<li>将CSharp侧的csIndexer方法入栈。</li>
<li>将type的基类base_type入栈。</li>
<li>将 LUA_REGISTRYINDEX 表中的 LuaIndexs 表入栈。</li>
<li>将CSharp侧的arrayIndexer方法入栈。</li>
<li>调用lua侧的 gen_obj_indexer 方法，将nil入栈，然后创建一个包括7个值的闭包，方法为 obj_indexer，将对应值出栈，闭包压入栈上。
<ul>
<li>闭包的值对应为 [1]: methods, [2]:getters, [3]:csindexer, [4]:base, [5]:indexfuncs, [6]:arrayindexer, [7]:baseindex</li>
<li>传入的参数对应为 [1]: obj, [2]: key</li>
</ul>
</li>
<li>将闭包存入 LuaIndexs 表，key为type的userdata。</li>
<li>设置type的metatable方法，key值为__index，value为闭包。</li>
</ul>
</li>
<li>设置metatable的__newindex：
<ul>
<li>将"__newindex"字符串入栈。</li>
<li>将set的table入栈。</li>
<li>将CSharp侧的csNewIndexer方法入栈。</li>
<li>将type的基类base_type入栈。</li>
<li>将 LUA_REGISTRYINDEX 表中的 LuaNewIndexs 表入栈。</li>
<li>将CSharp侧的arrayNewIndexer方法入栈。</li>
<li>调用lua侧的 gen_obj_newindexer 方法，将nil入栈，然后创建一个包括6个值的闭包，方法为 obj_newindexer，将对应值出栈，闭包压入栈上。
<ul>
<li>闭包的值对应为 [1]:setters, [2]:csnewindexer, [3]:base, [4]:newindexfuncs, [5]:arrayindexer, [6]:basenewindex</li>
<li>传入的参数对应为 [1]: obj, [2]: key, [3]: value</li>
</ul>
</li>
<li>将闭包存入 LuaNewIndexs 表，key为type的userdata。</li>
<li>设置type的metatable方法，key值为__newindex，value为闭包。</li>
</ul>
</li>
<li>将set、get、method的table和type的metatable出栈，恢复栈顶信息。</li>
</ul>
</li>
<li>Utils.BeginClassRegister：注册类相关信息，主要为静态对象、常量、枚举。
<ul>
<li>创建一个新表 cls_table，大小为类的静态对象和方法、常量、枚举的数量总数量 + 1。</li>
<li>设置type的userdata到cls_table中，key值为 UnderlyingSystemType（每个class都会注册这个key-value，所以cls_table的总大小+1）。</li>
<li>调用CSharp的 Util.SetCSTable 方法，注册type对应lua侧表：
<ul>
<li>将类型按 &ldquo;.&rdquo; 分割，创建对应table，存入 LUA_REGISTRYINDEX 表中的 xlua_csharp_namespace 表，如 UnityEngine.GameObject ，则创建key值 UnityEngine 的表存入 xlua_csharp_namespace 表，再将 cls_table 存入 UnityEngine 表中，key值为 GameObject。</li>
<li>将 cls_table 表存到 xlua_csharp_namespace 表，key值为type的userdata。</li>
</ul>
</li>
<li>创建新表 meta_table，设置__call方法为CSharp传入的creator方法。</li>
<li>创建get的table入栈。</li>
<li>创建set的table入栈。</li>
<li>设置为 cls_table 的metatable为 meta_table。</li>
</ul>
</li>
<li>Utils.RegisterObject：注册对象，通常为Enum值、常量等。
<ul>
<li>根据传入的类型idx，将对象设置到栈上对应table中，key值为传入的name。</li>
</ul>
</li>
<li>Utils.EndClassRegister
<ul>
<li>设置cls_table的index：
<ul>
<li>将"__index"入栈。</li>
<li>将get的table入栈。</li>
<li>将cls的table入栈。</li>
<li>将type的基类入栈。</li>
<li>将 LUA_REGISTRYINDEX 表中的 LuaClassIndexs 表入栈。</li>
<li>调用lua侧的 gen_cls_indexer 方法，将nil入栈，然后创建一个包括5个值的闭包，方法为 cls_indexer，将对应值出栈，闭包压入栈上。
<ul>
<li>闭包的值对应为 [1]:getters, [2]:feilds, [3]:base, [4]:indexfuncs, [5]:baseindex</li>
<li>传入的参数对应为 [1]: obj, [2]: key</li>
</ul>
</li>
<li>将闭包存入 LuaClassIndexs 表，key值为type的userdata。</li>
<li>设置cls_table的metatable方法，key值为__index，value为闭包。</li>
</ul>
</li>
<li>设置cls的newindex：
<ul>
<li>将"__newindex"入栈。</li>
<li>将set的table入栈。</li>
<li>将type的基类入栈。</li>
<li>将 LUA_REGISTRYINDEX 表中的 LuaClassNewIndexs 表入栈。</li>
<li>调用lua侧的 gen_cls_newindexer 方法，将nil入栈，然后创建一个包括4个值的闭包，方法为 cls_newindexer，将对应值出栈，闭包压入栈上。
<ul>
<li>闭包的值对应为 [1]:setters, [2]:base, [3]:indexfuncs, [4]:baseindex</li>
<li>传入的参数对应为 [1]: obj, [2]: key, [3]: value</li>
</ul>
</li>
<li>将闭包存入 LuaClassNewIndexs 表，key值为type的userdata。</li>
<li>设置cls_table的metatable方法，key值为__newindex，value为闭包。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id=反射注册>反射注册</h6>
<ul>
<li>反射注册（Utils.ReflectionWrap）的流程和Wrap流程基本一致，只是没有预先生成代码，主要流程为：
<ul>
<li>创建type的metatable，为obj_meta，存到 LUA_REGISTRYINDEX 表，key值为type.FullName。</li>
<li>设置 &tag 为 1。</li>
<li>创建cls_meta、obj_field、obj_getter、obj_setter、cls_field表。</li>
<li>调用CSharp侧的 Util.SetCSTable 方法，注册type对应lua侧表。</li>
<li>创建cls_getter、cls_setter表。</li>
<li>调用 makeReflectionWrap 方法，进行Wrap注册：
<ul>
<li>定义flag为 BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | access，access根据需求设置，可为 BindingFlags.Public 或 BindingFlags.NonPublic 或两者同时设置。</li>
<li>获取当前type符合flag类型的所有变量fields。</li>
<li>获取当前type符合类型（flag | BindingFlags.Public | BindingFlags.NonPublic）的所有事件all_events。</li>
<li>遍历fields对变量进行处理：
<ul>
<li>静态变量，如果变量名以 &ldquo;__Hotfix&rdquo; 或 &ldquo;_c__Hotfix&rdquo; 开头，且为委托，则不处理。</li>
<li>如果 all_events 中有这个变量名，则在 fieldName 前加 &ldquo;&"。</li>
<li>如果变量为静态，且有默认值并不能被修改，则存入 cls_field 中，key为 fieldName，value为变量的值。</li>
<li>如果没有默认值或者能被修改，则使用 translator.PushFixCSFunction 方法，将get和set的方法存入 StaticLuaCallback.fix_cs_functions中，将索引id作为 StaticLuaCallbacks.FixCSFunction 的参数，创建闭包，key值为 fieldName，存入表中。
<ul>
<li>静态变量：存入cls_getter、cls_setter。</li>
<li>成员变量：存入obj_getter、obj_setter。</li>
</ul>
</li>
</ul>
</li>
<li>获取当前type符合flag类型的所有events。</li>
<li>遍历events对事件进行处理：
<ul>
<li>获取事件对应的Wrap方法
<ul>
<li>MethodWrapsCache.methodsCache[type].methodsOfType[eventName]中存在，则直接返回。</li>
<li>如果没有缓存，则创建Wrap方法，Wrap会创建一个委托，绑定栈上 start_idx + 2 的方法，并根据 start_idx + 1 的值（"+&ldquo;或&rdquo;-"），执行事件添加或移除。</li>
</ul>
</li>
<li>将event存入表中，key值为 eventInfo.Name，value为Wrap方法。
<ul>
<li>静态事件：存入cls_field。</li>
<li>成员事件：存入obj_field。</li>
</ul>
</li>
</ul>
</li>
<li>获取当前type符合flag类型的所有有参属性。</li>
<li>设置out的item_getter、item_setter为有参属性的get、set。</li>
<li>获取当前type符合flag类型的所有方法methods。</li>
<li>创建方法的容器 Dictionary&lt;MethodKey, List<memberinfo>> pending_methods。</li>
<li>遍历methods对方法进行处理：
<ul>
<li>创建方法的MethodKey：new MethodKey { Name = method_name, IsStatic = method.IsStatic }。</li>
<li>如果 pending_methods 中是否存在此key，则将方法加入 List<memberinfo> 中。</li>
<li>如果方法为有参属性（get为一个参数，set为两个参数），第一个参数类型不是继承string，则不处理此方法。</li>
<li>如果方法为特殊名字方法（MethodBase.IsSpecialName），且以"add_"、&ldquo;remove_&ldquo;开头的，则不处理此方法。</li>
<li>如果方法为特殊名字方法（MethodBase.IsSpecialName），且以"op_&ldquo;开头的，如果 InternalGlobals.supportOp 中包含此方法，则加入 List<memberinfo> 中，否则不处理。InternalGlobals.supportOp 包括：
<ul>
<li>{ &ldquo;op_Addition&rdquo;, &ldquo;__add&rdquo; }</li>
<li>{ &ldquo;op_Subtraction&rdquo;, &ldquo;__sub&rdquo; }</li>
<li>{ &ldquo;op_Multiply&rdquo;, &ldquo;__mul&rdquo; }</li>
<li>{ &ldquo;op_Division&rdquo;, &ldquo;__div&rdquo; }</li>
<li>{ &ldquo;op_Equality&rdquo;, &ldquo;__eq&rdquo; }</li>
<li>{ &ldquo;op_UnaryNegation&rdquo;, &ldquo;__unm&rdquo; }</li>
<li>{ &ldquo;op_LessThan&rdquo;, &ldquo;__lt&rdquo; }</li>
<li>{ &ldquo;op_LessThanOrEqual&rdquo;, &ldquo;__le&rdquo; }</li>
<li>{ &ldquo;op_Modulus&rdquo;, &ldquo;__mod&rdquo; }</li>
<li>{ &ldquo;op_BitwiseAnd&rdquo;, &ldquo;__band&rdquo; }</li>
<li>{ &ldquo;op_BitwiseOr&rdquo;, &ldquo;__bor&rdquo; }</li>
<li>{ &ldquo;op_ExclusiveOr&rdquo;, &ldquo;__bxor&rdquo; }</li>
<li>{ &ldquo;op_OnesComplement&rdquo;, &ldquo;__bnot&rdquo; }</li>
<li>{ &ldquo;op_LeftShift&rdquo;, &ldquo;__shl&rdquo; }</li>
<li>{ &ldquo;op_RightShift&rdquo;, &ldquo;__shr&rdquo; }</li>
</ul>
</li>
<li>如果方法为特殊名字方法（MethodBase.IsSpecialName），且以"get_"、&ldquo;set__&ldquo;开头，则使用 translator.PushFixCSFunction 方法，将get、set方法存入 StaticLuaCallback.fix_cs_functions中，将索引id作为 StaticLuaCallbacks.FixCSFunction 的参数，创建闭包，key值为 methodName，静态方法存入cls_getter、cls_setter，其他存入obj_getter、obj_setter。</li>
<li>如果方法为构造函数，则不处理。</li>
<li>其他情况，则将方法加入 List<memberinfo> 中。</li>
</ul>
</li>
<li>遍历extension_methods对扩展方法进行处理：
<ul>
<li>创建方法的MethodKey：new MethodKey { Name = method_name, IsStatic = method.IsStatic }。</li>
<li>如果 pending_methods 中是否存在此key，则将方法加入 List<memberinfo> 中。</li>
</ul>
</li>
<li>遍历pending_methods中的所有对象：
<ul>
<li>如果 MethodKey.Name 以&rdquo;__op"开头，则使用 translator.PushFixCSFunction 方法，将 List<memberinfo> 的方法存入 StaticLuaCallback.fix_cs_functions中，将索引id作为 StaticLuaCallbacks.FixCSFunction 的参数，创建闭包，key值为 MethodKey.Name，存入obj_meta中。</li>
<li>其他对象，同样使用 translator.PushFixCSFunction 方法，如果 MethodKey.IsStatic 为静态，则存入cls_field表，否则存入obj_field表。</li>
</ul>
</li>
</ul>
</li>
<li>初始化 obj 的 metatable：
<ul>
<li>将CSharp侧的 StaticLuaCallbacks.LuaGC 方法存入 obj_meta 表，key值为 __gc。</li>
<li>将CSharp侧的 StaticLuaCallbacks.ToString 方法存入 obj_meta 表，key值为 __tostring。</li>
<li>设置 __index 方法：
<ul>
<li>将&rdquo;__index"入栈。</li>
<li>将 obj_field 表入栈。</li>
<li>将 obj_getter 表入栈。</li>
<li>使用 translator.PushFixCSFunction 方法，将 makeReflectionWrap 返回的 item_getter 方法存入 StaticLuaCallback.fix_cs_functions中，将索引id作为 StaticLuaCallbacks.FixCSFunction 的参数，创建闭包并入栈。</li>
<li>将当前type的基类入栈（translator.PushAny）。</li>
<li>将 LuaIndexs 表入栈。</li>
<li>将 nil 入栈。</li>
<li>调用lua侧的 gen_obj_indexer 方法，将nil入栈，然后创建一个包括7个值的闭包，方法为 obj_indexer，将对应值出栈，闭包压入栈上。</li>
<li>将闭包存入 LuaIndexs 表，key值为type的userdata。</li>
<li>将闭包存入 obj_meta 表，key值为 __index。</li>
</ul>
</li>
<li>设置 __newindex 方法：
<ul>
<li>将&rdquo;__newindex"入栈。</li>
<li>将 obj_setter 表入栈。</li>
<li>使用 translator.PushFixCSFunction 方法，将 makeReflectionWrap 返回的 item_setter 方法存入 StaticLuaCallback.fix_cs_functions中，将索引id作为 StaticLuaCallbacks.FixCSFunction 的参数，创建闭包并入栈。</li>
<li>将当前type的基类入栈（translator.Push）。</li>
<li>将 LuaNewIndexs 表入栈。</li>
<li>将 nil 入栈。</li>
<li>调用lua侧的 gen_obj_newindexer 方法，将nil入栈，然后创建一个包括6个值的闭包，方法为 obj_newindexer，将对应值出栈，闭包压入栈上。</li>
<li>将闭包存入 LuaNewIndexs 表，key值为type的userdata。</li>
<li>将闭包存入 obj_meta 表，key值为 __newindex。</li>
</ul>
</li>
</ul>
</li>
<li>将type存入cls_field表，key值为 UnderlyingSystemType。</li>
<li>如果type为枚举，则使用 translator.PushFixCSFunction 方法，为 genEnumCastFrom 方法创建闭包，存入cls_field表，key值为 __CastFrom。</li>
<li>初始化 cls 的 metatable
<ul>
<li>设置 __index 方法：
<ul>
<li>将&rdquo;__index"入栈。</li>
<li>将 cls_getter 表入栈。</li>
<li>将 cls_field 表入栈。</li>
<li>将当前type的基类入栈（translator.Push）。</li>
<li>将 LuaClassIndexs 表入栈。</li>
<li>调用lua侧的 gen_cls_indexer 方法，将nil入栈，然后创建一个包括5个值的闭包，方法为 cls_indexer，将对应值出栈，闭包压入栈上。</li>
<li>将闭包存入 LuaClassIndexs 表，key值为type的userdata。</li>
<li>将闭包存入 cls_meta 表，key值为 __index。</li>
</ul>
</li>
<li>设置 __newindex 方法：
<ul>
<li>将&rdquo;__newindex"入栈。</li>
<li>将 cls_setter 表入栈。</li>
<li>将当前type的基类入栈（translator.Push）。</li>
<li>将 LuaClassNewIndexs 表入栈。</li>
<li>调用lua侧的 gen_cls_newindexer 方法，将nil入栈，然后创建一个包括4个值的闭包，方法为 cls_newindexer，将对应值出栈，闭包压入栈上。</li>
<li>将闭包存入 LuaClassNewIndexs 表，key值为type的userdata。</li>
<li>将闭包存入 cls_meta 表，key值为 __newindex。</li>
</ul>
</li>
<li>将type的构造函数存入cls_meta表中，key值为 __call。</li>
</ul>
</li>
<li>将 cls_meta 表设置为 cls_field 表的metatable。</li>
<li>遍历嵌套在type中的类型（GetNestedTypes），如果为需要传入类型构建的泛型类型（如 List&lt;>），则不处理，其余则进行类型注册。</li>
</ul>
</li>
</ul>
<h6 id=结构-1>结构</h6>
<ul>
<li>注册后，lua侧的结构大致如下（以 GameObject 为例）：</li>
</ul>
<pre tabindex=0><code>    _G = {
        ...

        CS（所有CSharp的对应表）: LUA_REGISTRYINDEX 表中的 xlua_csharp_namespace 表
            
    }

    -10000（即 LUA_REGISTRYINDEX） = {
        ...

        LuaIndexs ：
            table = {
                ref_GameObject = UnityEngine.GameObject的obj的index闭包
            },
            metatable = {
                __index = StaticLuaCallbacks.MetaFuncIndex
            }

        LuaNewIndexs ：
            table = {
                ref_GameObject = UnityEngine.GameObject的obj的newindex闭包
            },
            metatable = meta表 

        LuaClassIndexs ：
            table = {
                ref_GameObject = UnityEngine.GameObject的cls的index闭包
            },
            metatable = meta表 
        
        LuaClassNewIndexs ：
            table = {
                ref_GameObject = UnityEngine.GameObject的cls的newindex闭包
            },
            metatable = meta表 

        xlua_csharp_namespace 表（即 _G.CS 表） = {
            table = {
                UnityEngine = {
                      GameObject = ref_GameObject 表
                        
                  }
            },
            metatable = {
                __index = CSharp侧 LuaEnv.init_xlua 中的 __index(key),
                __newindex = CSharp侧 LuaEnv.init_xlua 中的 __newindex(),
                __call = CSharp侧 LuaEnv.init_xlua 中的 __call(...),
            }

            ref_GameObject（分配的id，即 GameObject 的 userdata） = {
                table = {
                            UnderlyingSystemType = ref_GameObject（GameObject的userdata）

                            FindWithTag = CSharp侧的 GameObject.FindWithTag（Wrap为 UnityEngineGameObjectWrap._m_FindWithTag_xlua_st_，反射为 MethodWrap.Call）
                            Find = CSharp侧的 GameObject.Find（Wrap为 UnityEngineGameObjectWrap._m_Find_xlua_st_，反射为 MethodWrap.Call）
                            ...
                        }
                metatable = {
                    __call = GameObject的实例化（Wrap为 UnityEngineGameObjectWrap.__CreateInstance，反射为构造函数）
                    __index = cls的index闭包（参数为 [1]: obj, [2]: key ）
                        {
                            [1]:getters
                                {
                                    get的table
                                }
                            [2]:feilds
                                {
                                    CS.UnityEngine.GameObject 表
                                }
                            [3]:base
                                {
                                    type的基类
                                }
                            [4]:indexfuncs
                                {
                                    LUA_REGISTRYINDEX 表中的 LuaClassIndexs 表
                                }
                            [5]:baseindex
                                {
                                    nil
                                }
                        }
                    __newindex = cls的newindex闭包（参数为 [1]: obj, [2]: key, [3]: value ）
                        {
                            [1]:setters
                                {
                                    set的table
                                }
                            [2]:base
                                {
                                    type的基类
                                }
                            [3]:indexfuncs
                                {
                                    LUA_REGISTRYINDEX 表中的 LuaClassNewIndexs 表
                                }
                            [4]:baseindex
                                {
                                    nil
                                }
                        }
                }
            }
        }

        ref_GameObject（分配的id，对应CSharp侧的UnityEngine.GameObject） = UnityEngine.GameObject 表

        UnityEngine.GameObject （CSharp侧UnityEngine.GameObject的type.FullName，由 luaL_newmetatable 创建）：
            table = {},
            metatable = {
                &amp;tag = 1,
                
                __name = &quot;UnityEngine.GameObject&quot;,
                __gc = CSharp侧的 StaticLuaCallbacks.LuaGC,
                __tostring = CSharp侧的 StaticLuaCallbacks.ToString,
                __index = obj的index闭包（参数为 [1]: obj, [2]: key ）
                    {
                        [1]: methods
                            {
                                GetComponent = CSharp侧的 GameObject.GetComponent（Wrap为 UnityEngineGameObjectWrap._m_GetComponent，反射为 MethodWrap.Call）
                                SetActive = CSharp侧的 GameObject.SetActive（Wrap为 UnityEngineGameObjectWrap._m_SetActive，反射为 MethodWrap.Call）
                                ...
                            }
                        [2]: getters
                            {
                                transform = CSharp侧的 GameObject.transform（Wrap为 UnityEngineGameObjectWrap._g_get_transform，反射为 MethodWrap.Call）
                                layer = CSharp侧的 GameObject.layer（Wrap为 UnityEngineGameObjectWrap._g_get_layer，反射为 MethodWrap.Call）
                                ...
                            }
                        [3]: csindexer
                            {
                                CSharp侧的csIndexer方法
                            }
                        [4]: base
                            {
                                type的基类base_type
                            }
                        [5]: indexfuncs
                            {
                                LUA_REGISTRYINDEX 表中的 LuaIndexs 表
                            }
                        [6]: arrayindexer
                            {
                                CSharp侧的arrayIndexer方法
                            }
                        [7]: baseindex
                            {
                                nil
                            }
                    }
                __newindex = obj的newindex闭包（参数为 [1]: obj, [2]: key, [3]: value ）
                    {
                        [1]: setters
                            {
                                transform = CSharp侧的 GameObject.transform（Wrap为 UnityEngineGameObjectWrap._g_set_transform，反射为 MethodWrap.Call）
                                layer = CSharp侧的 GameObject.layer（Wrap为 UnityEngineGameObjectWrap._g_set_layer，反射为 MethodWrap.Call）
                                ...
                            }
                        [2]: csnewindexer
                            {
                                CSharp侧的csNewIndexer方法
                            }
                        [3]: base
                            {
                                type的基类base_type
                            }
                        [4]: newindexfuncs
                        {
                            LUA_REGISTRYINDEX 表中的 LuaNewIndexs 表
                        }
                        [5]: arrayindexer
                        {
                            CSharp侧的arrayNewIndexer方法
                        }
                        [6]: basenewindex
                        {
                            nil
                        }
                    }
            }
    }
</code></pre><h5 id=绑定csharp对象>绑定CSharp对象</h5>
<ul>
<li>CSharp侧的对象，传到Lua侧主要方法为 ObjectTranslator.Push ，主要流程为：
<ul>
<li>非值类型对象和枚举对象，从字典中获取对象对应的id，调用lua侧的 xlua_tryget_cachedud 方法，检查 LUA_REGISTRYINDEX 表中的 ref_cacheRef 表中是否有此id，如果有则不再处理。
<ul>
<li>非值类型对象：ObjectTranslator.reverseMap 字典。</li>
<li>枚举对象：ObjectTranslator.enumMap 字典。</li>
</ul>
</li>
<li>调用 ObjectTranslator.getTypeId 方法，获取type对应的type_id。</li>
<li>如果一个type的定义含本身静态readonly实例时，getTypeId会push一个实例，检查 LUA_REGISTRYINDEX 表中的 ref_cacheRef 表中是否有此id，如果有则不再处理。</li>
<li>调用 ObjectTranslator.addObject 方法，将对象存入 ObjectTranslator.objects 中，返回对应的 index，并根据类型存入字典：
<ul>
<li>非值类型对象：存入 ObjectTranslator.reverseMap 字典记录。</li>
<li>枚举对象：存入 ObjectTranslator.enumMap 字典记录。</li>
</ul>
</li>
<li>调用lua侧的 xlua_pushcsobj 方法，在lua侧创建对应的userdata，存入 LUA_REGISTRYINDEX 表中的 ref_cacheRef 表中，设置userdata的metatable为 LUA_REGISTRYINDEX 表中的 type_id 对应的表（如 ref_GameObject）。</li>
</ul>
</li>
<li>示例代码大致如下：</li>
</ul>
<pre tabindex=0><code>    -- Test.lua

    local go = CS.UnityEngine.GameObject.Find(&quot;TestGameObject&quot;);
</code></pre><pre tabindex=0><code>    // UnityEngineGameObjectWrap.cs
    ...
    [MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
    static int _m_Find_xlua_st_(RealStatePtr L)
    {
        try {
        
            ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);

            {
                string _name = LuaAPI.lua_tostring(L, 1);
                
                    var gen_ret = UnityEngine.GameObject.Find( _name );
                    translator.Push(L, gen_ret);
                
                
                
                return 1;
            }
            
        } 
        catch(System.Exception gen_e) {
            return LuaAPI.luaL_error(L, &quot;c# exception:&quot; + gen_e);
        }
        
    }
</code></pre><pre tabindex=0><code>    // ObjectTranslator.cs

    ...
    public void Push(RealStatePtr L, object o)
    {
        if (o == null)
        {
            LuaAPI.lua_pushnil(L);
            return;
        }
        int index = -1;
        Type type = o.GetType();
#if !UNITY_WSA || UNITY_EDITOR
        bool is_enum = type.IsEnum;
        bool is_valuetype = type.IsValueType;
#else
        bool is_enum = type.GetTypeInfo().IsEnum;
        bool is_valuetype = type.GetTypeInfo().IsValueType;
#endif
        bool needcache = !is_valuetype || is_enum;
        if (needcache &amp;&amp; (is_enum ? enumMap.TryGetValue(o, out index) : reverseMap.TryGetValue(o, out index)))
        {
            if (LuaAPI.xlua_tryget_cachedud(L, index, cacheRef) == 1)
            {
                return;
            }
            //这里实在太经典了，weaktable先删除，然后GC会延迟调用，当index会循环利用的时候，不注释这行将会导致重复释放
            //collectObject(index);
        }
        bool is_first;
        int type_id = getTypeId(L, type, out is_first);
        //如果一个type的定义含本身静态readonly实例时，getTypeId会push一个实例，这时候应该用这个实例
        if (is_first &amp;&amp; needcache &amp;&amp; (is_enum ? enumMap.TryGetValue(o, out index) : reverseMap.TryGetValue(o, out index))) 
        {
            if (LuaAPI.xlua_tryget_cachedud(L, index, cacheRef) == 1)
            {
                return;
            }
        }
        index = addObject(o, is_valuetype, is_enum);
        LuaAPI.xlua_pushcsobj(L, index, type_id, needcache, cacheRef);
    }
</code></pre><ul>
<li>可以看到，如果需要缓存的对象，会调用lua侧的 xlua_tryget_cachedud 方法，检查 LUA_REGISTRYINDEX 表中的 ref_cacheRef 表中是是否有此对象，如果返回值为1，表示表中有此对象，则不需要再次进行绑定。</li>
<li>Lua侧此时结构大致如下所示：</li>
</ul>
<pre tabindex=0><code>    _G = {
        ...

        CS（所有CSharp的对应表）: LUA_REGISTRYINDEX 表中的 xlua_csharp_namespace 表


        Test = {
            go = userdata_GameObject（从 LUA_REGISTRYINDEX 表中的 ref_cacheRef 表中获取）
        }            
    }

    -10000（即 LUA_REGISTRYINDEX） = {
        ...

        ref_cacheRef（分配的id，在CSharp侧为 ObjectTranslator.cacheRef）
            table = {
                index_GameObject（CSharp侧的一个UnityEngine.GameObject，index为ObjectTranslator分配）= userdata_GameObject {
					
                    （头部 Udata*）{
                      ...
                      tt = LUA_TUSERDATA
                      metatable = LUA_REGISTRYINDEX.ref_GameObject
                    }
                    （用户自定义数据 user domain*）{
                      index_GameObject
                    }
                  }
                
                ...
            },
            metatable = {
                __mode = v（值弱表）
            }

        LuaIndexs ：
            table = {
                ref_GameObject = UnityEngine.GameObject的obj的index闭包
            },
            metatable = {
                __index = StaticLuaCallbacks.MetaFuncIndex
            }

        LuaNewIndexs ：
            table = {
                ref_GameObject = UnityEngine.GameObject的obj的newindex闭包
            },
            metatable = meta表 

        LuaClassIndexs ：
            table = {
                ref_GameObject = UnityEngine.GameObject的cls的index闭包
            },
            metatable = meta表 
        
        LuaClassNewIndexs ：
            table = {
                ref_GameObject = UnityEngine.GameObject的cls的newindex闭包
            },
            metatable = meta表 

        xlua_csharp_namespace 表（即 _G.CS 表） = {
            table = {
                UnityEngine = {
                      GameObject = ref_GameObject 表
                        
                  }
            },
            metatable = {
                __index = CSharp侧 LuaEnv.init_xlua 中的 __index(key),
                __newindex = CSharp侧 LuaEnv.init_xlua 中的 __newindex(),
                __call = CSharp侧 LuaEnv.init_xlua 中的 __call(...),
            }

            ref_GameObject（分配的id，即 GameObject 的 userdata） = {
                table = {
                            UnderlyingSystemType = ref_GameObject（GameObject的userdata）

                            FindWithTag = CSharp侧的 GameObject.FindWithTag（Wrap为 UnityEngineGameObjectWrap._m_FindWithTag_xlua_st_，反射为 MethodWrap.Call）
                            Find = CSharp侧的 GameObject.Find（Wrap为 UnityEngineGameObjectWrap._m_Find_xlua_st_，反射为 MethodWrap.Call）
                            ...
                        }
                metatable = {
                    __call = GameObject的实例化（Wrap为 UnityEngineGameObjectWrap.__CreateInstance，反射为构造函数）
                    __index = cls的index闭包（参数为 [1]: obj, [2]: key ）
                        {
                            [1]:getters
                                {
                                    get的table
                                }
                            [2]:feilds
                                {
                                    CS.UnityEngine.GameObject 表
                                }
                            [3]:base
                                {
                                    type的基类
                                }
                            [4]:indexfuncs
                                {
                                    LUA_REGISTRYINDEX 表中的 LuaClassIndexs 表
                                }
                            [5]:baseindex
                                {
                                    nil
                                }
                        }
                    __newindex = cls的newindex闭包（参数为 [1]: obj, [2]: key, [3]: value ）
                        {
                            [1]:setters
                                {
                                    set的table
                                }
                            [2]:base
                                {
                                    type的基类
                                }
                            [3]:indexfuncs
                                {
                                    LUA_REGISTRYINDEX 表中的 LuaClassNewIndexs 表
                                }
                            [4]:baseindex
                                {
                                    nil
                                }
                        }
                }
            }
        }

        ref_GameObject（分配的id，对应CSharp侧的UnityEngine.GameObject） = UnityEngine.GameObject 表

        UnityEngine.GameObject （CSharp侧UnityEngine.GameObject的type.FullName，由 luaL_newmetatable 创建）：
            table = {},
            metatable = {
                &amp;tag = 1,
                
                __name = &quot;UnityEngine.GameObject&quot;,
                __gc = CSharp侧的 StaticLuaCallbacks.LuaGC,
                __tostring = CSharp侧的 StaticLuaCallbacks.ToString,
                __index = obj的index闭包（参数为 [1]: obj, [2]: key ）
                    {
                        [1]: methods
                            {
                                GetComponent = CSharp侧的 GameObject.GetComponent（Wrap为 UnityEngineGameObjectWrap._m_GetComponent，反射为 MethodWrap.Call）
                                SetActive = CSharp侧的 GameObject.SetActive（Wrap为 UnityEngineGameObjectWrap._m_SetActive，反射为 MethodWrap.Call）
                                ...
                            }
                        [2]: getters
                            {
                                transform = CSharp侧的 GameObject.transform（Wrap为 UnityEngineGameObjectWrap._g_get_transform，反射为 MethodWrap.Call）
                                layer = CSharp侧的 GameObject.layer（Wrap为 UnityEngineGameObjectWrap._g_get_layer，反射为 MethodWrap.Call）
                                ...
                            }
                        [3]: csindexer
                            {
                                CSharp侧的csIndexer方法
                            }
                        [4]: base
                            {
                                type的基类base_type
                            }
                        [5]: indexfuncs
                            {
                                LUA_REGISTRYINDEX 表中的 LuaIndexs 表
                            }
                        [6]: arrayindexer
                            {
                                CSharp侧的arrayIndexer方法
                            }
                        [7]: baseindex
                            {
                                nil
                            }
                    }
                __newindex = obj的newindex闭包（参数为 [1]: obj, [2]: key, [3]: value ）
                    {
                        [1]: setters
                            {
                                transform = CSharp侧的 GameObject.transform（Wrap为 UnityEngineGameObjectWrap._g_set_transform，反射为 MethodWrap.Call）
                                layer = CSharp侧的 GameObject.layer（Wrap为 UnityEngineGameObjectWrap._g_set_layer，反射为 MethodWrap.Call）
                                ...
                            }
                        [2]: csnewindexer
                            {
                                CSharp侧的csNewIndexer方法
                            }
                        [3]: base
                            {
                                type的基类base_type
                            }
                        [4]: newindexfuncs
                        {
                            LUA_REGISTRYINDEX 表中的 LuaNewIndexs 表
                        }
                        [5]: arrayindexer
                        {
                            CSharp侧的arrayNewIndexer方法
                        }
                        [6]: basenewindex
                        {
                            nil
                        }
                    }
            }
    }
</code></pre><ul>
<li>当我们的Test不再使用时，Test表会删除（TestPanel = nil)，此时整个table会变成可回收，而表里的变量也同样会标记成可回收，即userdata_GameObject也触发了luaL_unref方法，移除了userdata_GameObject引用，此时userdata_GameObject只有在 ref_cacheRef 中有引用，此时的结构如下：</li>
</ul>
<pre tabindex=0><code>    _G = {
        ...

        CS（所有CSharp的对应表）: LUA_REGISTRYINDEX 表中的 xlua_csharp_namespace 表
        
    }

    -10000（即 LUA_REGISTRYINDEX） = {
        ...

        ref_cacheRef（分配的id，在CSharp侧为 ObjectTranslator.cacheRef）
            table = {
                index_GameObject（CSharp侧的一个UnityEngine.GameObject，index为ObjectTranslator分配）= userdata_GameObject {
					
                    （头部 Udata*）{
                      ...
                      tt = LUA_TUSERDATA
                      metatable = LUA_REGISTRYINDEX.ref_GameObject
                    }
                    （用户自定义数据 user domain*）{
                      index_GameObject
                    }
                  }
                
                ...
            },
            metatable = {
                __mode = v
            }

        ...
    }
</code></pre><ul>
<li>由于 ref_cacheRef 表为值弱表，所以当lua gc触发时，userdata_GameObject由于没有其他引用，所以会被回收，并调起 userdata_GameObject.metatable的 __gc （即 LUA_REGISTRYINDEX.ref_GameObject.__gc） 方法，从而调起CSharp侧的 StaticLuaCallbacks.LuaGC 方法，删除 ObjectTranslator.objects 和 ObjectTranslator.reverseMap（或 ObjectTranslator.enumMap） 的引用。</li>
<li>CSharp侧的GC方法如下：</li>
</ul>
<pre tabindex=0><code>    // StaticLuaCallbacks.cs
    ...
    [MonoPInvokeCallback(typeof(LuaCSFunction))]
    public static int LuaGC(RealStatePtr L)
    {
        try
        {
            int udata = LuaAPI.xlua_tocsobj_safe(L, 1);
            if (udata != -1)
            {
                ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);
                if ( translator != null )
                {
                    translator.collectObject(udata);
                }
            }
            return 0;
        }
        catch (Exception e)
        {
            return LuaAPI.luaL_error(L, &quot;c# exception in LuaGC:&quot; + e);
        }
    }
</code></pre><pre tabindex=0><code>    // ObjectTranslator.cs
    ...
		internal void collectObject(int obj_index_to_collect)
		{
        object o;
        
        if (objects.TryGetValue(obj_index_to_collect, out o))
        {
            objects.Remove(obj_index_to_collect);
                  
            if (o != null)
            {
                int obj_index;
                //lua gc是先把weak table移除后再调用__gc，这期间同一个对象可能再次push到lua，关联到新的index
                bool is_enum = o.GetType().IsEnum();
                if ((is_enum ? enumMap.TryGetValue(o, out obj_index) : reverseMap.TryGetValue(o, out obj_index))
                    &amp;&amp; obj_index == obj_index_to_collect)
                {
                    if (is_enum)
                    {
                        enumMap.Remove(o);
                    }
                    else
                    {
                        reverseMap.Remove(o);
                    }
                }
            }
        }
		}
</code></pre><ul>
<li>可以看到，CSharp侧的GC流程为
<ul>
<li>调用lua侧的 xlua_tocsobj_safe 方法，获取对象对应的userdata的index。</li>
<li>移除CSharp侧的 ObjectTranslator.objects 中的 index。</li>
<li>检查对应字典中是否有存在此对象，并且对象对应的index和从lua侧获得的index一致，则移除字典中此对象。</li>
</ul>
</li>
<li>前面提到，CSharp侧的 ObjectTranslator.Push 方法绑定CSharp侧对象到Lua侧时，会调用lua侧的 xlua_tryget_cachedud 方法，先检查 ref_cacheRef 表中是否有此对象。因为lua侧gc触发时，LUA_REGISTRYINDEX表中的 ref_cacheRef 表先移除了弱值引用，而__gc方法并不是马上触发，所以这中间可能出现此对象又再关联上lua，并且关联到一个新的index，而原来旧的index将会随lua的gc移除。</li>
<li>同样，CSharp侧移除字典的对象前，还进行了一次index的比对，如果字典中此对象对应的index和gc要移除的index不一致，则表示此对象已经再次绑定到lua侧，关联到新的index，则不需要移除字典的引用。</li>
<li>总的来说，lua侧对CSharp侧对象的引用，只有lua gc触发的时候，才能在CSharp侧对应释放掉引用。</li>
</ul>
<h4 id=csharp访问lua对象>CSharp访问Lua对象</h4>
<h4 id=时序图>时序图</h4>
<h3 id=调用方法>调用方法</h3>
<h4 id=lua调用csharp方法>Lua调用CSharp方法</h4>
<h4 id=csharp调用lua方法>CSharp调用Lua方法</h4>
<h3 id=委托>委托</h3>
<h3 id=重载>重载</h3>
<h3 id=无gc传值>无GC传值</h3>
<h3 id=泛型>泛型</h3>
<h3 id=反射>反射</h3>
<h3 id=64位整型>64位整型</h3>
<pre tabindex=0><code>    _G = {
        uint64 = {
            tostring = i64lib.c的 uint64_tostring 方法
            compare = i64lib.c的 uint64_compare 方法
            divide = i64lib.c的 uint64_divide 方法
            remainder = i64lib.c的 uint64_remainder 方法
            parse = i64lib.c的 uint64_parse 方法
        }
    }

    -10000（即 LUA_REGISTRYINDEX） = {
        ...

        -- 5.1.5版本才有
        8（即 INT64_META_REF） = {
            __add = i64lib.c的 int64_add 方法
            __sub = i64lib.c的 int64_sub 方法
            __mul = i64lib.c的 int64_mul 方法
            __div = i64lib.c的 int64_div 方法
            __mod = i64lib.c的 int64_mod 方法
            __unm = i64lib.c的 int64_unm 方法
            __pow = i64lib.c的 int64_pow 方法
            __tostring = i64lib.c的 int64_tostring 方法
            __eq = i64lib.c的 int64_eq 方法
            __lt = i64lib.c的 int64_lt 方法
            __le = i64lib.c的 int64_le 方法
            __tostring = i64lib.c的 int64_tostring 方法
        }

    }
</code></pre><h3 id=协程>协程</h3>
<h3 id=接口interface>接口（Interface）</h3>
<h3 id=热修复>热修复</h3>
<h2 id=总结>总结</h2>
<hr>
<ul class=pager>
<li class=previous>
<a href=/post/lua/lua_tolua/ data-toggle=tooltip data-placement=top title="Lua篇 — (2) ToLua">&larr;
Previous Post</a>
</li>
</ul>
<div id=disqus-comment></div>
</div>
<div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container">
<div class=side-catalog>
<hr class="hidden-sm hidden-xs">
<h5>
<a class=catalog-toggle href=#>CATALOG</a>
</h5>
<ul class=catalog-body></ul>
</div>
</div>
<div class="col-lg-11 col-lg-offset-1
col-md-10 col-md-offset-1
sidebar-container">
</div>
</div>
</div>
</article>
<footer>
<div class=container>
<div class=row>
<div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
<ul class="list-inline text-center">
</ul>
<p class="copyright text-muted">
Copyright &copy; Xun's Blog 2021
<br>
<a href=https://themes.gohugo.io/hugo-theme-cleanwhite>CleanWhite Hugo Theme</a> by <a href=https://zhaohuabing.com>Huabing</a> |
<iframe style=margin-left:2px;margin-bottom:-5px frameborder=0 scrolling=0 width=100px height=20px src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true"></iframe>
</p>
</div>
</div>
</div>
</footer>
<script>function loadAsync(f,b){var c=document,d='script',a=c.createElement(d),e=c.getElementsByTagName(d)[0];a.src=f,b&&a.addEventListener('load',function(a){b(null,a)},!1),e.parentNode.insertBefore(a,e)}</script>
<script>$('#tag_cloud').length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:'#bbbbee',end:'#0085a1'}},$('#tag_cloud a').tagcloud()})</script>
<script>loadAsync("https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.js",function(){var a=document.querySelector("nav");a&&FastClick.attach(a)})</script>
<script type=text/javascript>function generateCatalog(a){_containerSelector='div.post-container';var h=$(_containerSelector),c,d,e,f,g,b;return c=h.find('h1,h2,h3,h4,h5,h6'),$(a).html(''),c.each(function(){d=$(this).prop('tagName').toLowerCase(),g="#"+$(this).prop('id'),e=$(this).text(),b=$('<a href="'+g+'" rel="nofollow">'+e+'</a>'),f=$('<li class="'+d+'_nav"></li>').append(b),$(a).append(f)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(a){a.preventDefault(),$('.side-catalog').toggleClass("fold")}),loadAsync("/js/jquery.nav.js",function(){$('.catalog-body').onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script>
</body>
</html>
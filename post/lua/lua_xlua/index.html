<!doctype html><html lang=zh-cn>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta property="og:site_name" content="Xun's Blog">
<meta property="og:type" content="article">
<meta property="og:image" content="https://fallingxun.github.io//">
<meta property="twitter:image" content="https://fallingxun.github.io//">
<meta name=title content="Lua篇 — (3) xLua">
<meta property="og:title" content="Lua篇 — (3) xLua">
<meta property="twitter:title" content="Lua篇 — (3) xLua">
<meta name=description content>
<meta property="og:description" content>
<meta property="twitter:description" content>
<meta property="twitter:card" content="summary">
<meta name=keyword content>
<link rel="shortcut icon" href=/img/favicon.ico>
<title>Lua篇 — (3) xLua-</title>
<link rel=canonical href=/post/lua/lua_xlua/>
<link rel=stylesheet href=/css/iDisqus.min.css>
<link rel=stylesheet href=/css/bootstrap.min.css>
<link rel=stylesheet href=/css/hugo-theme-cleanwhite.min.css>
<link rel=stylesheet href=/css/zanshang.css>
<link href=//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css rel=stylesheet type=text/css>
<script src=/js/jquery.min.js></script>
<script src=/js/bootstrap.min.js></script>
<script src=/js/hux-blog.min.js></script>
</head>
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
<div class=container-fluid>
<div class="navbar-header page-scroll">
<button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=/>Xun's Blog</a>
</div>
<div id=huxblog_navbar>
<div class=navbar-collapse>
<ul class="nav navbar-nav navbar-right">
<li>
<a href=/>Home</a>
</li>
<li>
<a href=/categories/googleplay%E7%B3%BB%E5%88%97>googleplay系列</a>
</li>
<li>
<a href=/categories/lua%E7%B3%BB%E5%88%97>lua系列</a>
</li>
<li>
<a href=/categories/tmp%E7%B3%BB%E5%88%97>tmp系列</a>
</li>
</ul>
</div>
</div>
</div>
</nav>
<script>var $body=document.body,$toggle=document.querySelector('.navbar-toggle'),$navbar=document.querySelector('#huxblog_navbar'),$collapse=document.querySelector('.navbar-collapse');$toggle.addEventListener('click',handleMagic);function handleMagic(a){$navbar.className.indexOf('in')>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf('in')<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script>
<style type=text/css>header.intro-header{background-image:url('/')}</style>
<header class=intro-header>
<div class=container>
<div class=row>
<div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
<div class=post-heading>
<div class=tags>
<a class=tag href=/tags/lua title=Lua>
Lua
</a>
<a class=tag href=/tags/xlua title=xLua>
xLua
</a>
</div>
<h1>Lua篇 — (3) xLua</h1>
<h2 class=subheading></h2>
<span class=meta>
Posted by
Xun
on
Thursday, November 4, 2021
</span>
</div>
</div>
</div>
</div>
</header>
<article>
<div class=container>
<div class=row>
<div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container">
<p>由于很多旧项目是以CSharp开发的，热更时就会遇到难题。而xLua框架的出现，让很多项目能够在改动最小的情况下，支持热更新功能。</p>
<h3 id=简介>简介</h3>
<h3 id=初始化>初始化</h3>
<h4 id=创建luaenv>创建LuaEnv</h4>
<ul>
<li>Lua状态机的创建方法主要实现如下</li>
</ul>
<pre tabindex=0><code>    public LuaEnv()
    {

        ...
                
        rawL = LuaAPI.luaL_newstate();

        //Init Base Libs
        LuaAPI.luaopen_xlua(rawL);
        LuaAPI.luaopen_i64lib(rawL);

        translator = new ObjectTranslator(this, rawL);
        translator.createFunctionMetatable(rawL);
        translator.OpenLib(rawL);
        ObjectTranslatorPool.Instance.Add(rawL, translator);

        LuaAPI.lua_atpanic(rawL, StaticLuaCallbacks.Panic);

#if !XLUA_GENERAL
        LuaAPI.lua_pushstdcallcfunction(rawL, StaticLuaCallbacks.Print);
        if (0 != LuaAPI.xlua_setglobal(rawL, &quot;print&quot;))
        {
            throw new Exception(&quot;call xlua_setglobal fail!&quot;);
        }
#endif

        //template engine lib register
        TemplateEngine.LuaTemplate.OpenLib(rawL);

        AddSearcher(StaticLuaCallbacks.LoadBuiltinLib, 2); // just after the preload searcher
        AddSearcher(StaticLuaCallbacks.LoadFromCustomLoaders, 3);
#if !XLUA_GENERAL
        AddSearcher(StaticLuaCallbacks.LoadFromResource, 4);
        AddSearcher(StaticLuaCallbacks.LoadFromStreamingAssetsPath, -1);
#endif
        DoString(init_xlua, &quot;Init&quot;);
        init_xlua = null;

#if (!UNITY_SWITCH &amp;&amp; !UNITY_WEBGL) || UNITY_EDITOR
        AddBuildin(&quot;socket.core&quot;, StaticLuaCallbacks.LoadSocketCore);
        AddBuildin(&quot;socket&quot;, StaticLuaCallbacks.LoadSocketCore);
#endif

        AddBuildin(&quot;CS&quot;, StaticLuaCallbacks.LoadCS);

        LuaAPI.lua_newtable(rawL); //metatable of indexs and newindexs functions
        LuaAPI.xlua_pushasciistring(rawL, &quot;__index&quot;);
        LuaAPI.lua_pushstdcallcfunction(rawL, StaticLuaCallbacks.MetaFuncIndex);
        LuaAPI.lua_rawset(rawL, -3);

        LuaAPI.xlua_pushasciistring(rawL, Utils.LuaIndexsFieldName);
        LuaAPI.lua_newtable(rawL);
        LuaAPI.lua_pushvalue(rawL, -3);
        LuaAPI.lua_setmetatable(rawL, -2);
        LuaAPI.lua_rawset(rawL, LuaIndexes.LUA_REGISTRYINDEX);

        LuaAPI.xlua_pushasciistring(rawL, Utils.LuaNewIndexsFieldName);
        LuaAPI.lua_newtable(rawL);
        LuaAPI.lua_pushvalue(rawL, -3);
        LuaAPI.lua_setmetatable(rawL, -2);
        LuaAPI.lua_rawset(rawL, LuaIndexes.LUA_REGISTRYINDEX);

        LuaAPI.xlua_pushasciistring(rawL, Utils.LuaClassIndexsFieldName);
        LuaAPI.lua_newtable(rawL);
        LuaAPI.lua_pushvalue(rawL, -3);
        LuaAPI.lua_setmetatable(rawL, -2);
        LuaAPI.lua_rawset(rawL, LuaIndexes.LUA_REGISTRYINDEX);

        LuaAPI.xlua_pushasciistring(rawL, Utils.LuaClassNewIndexsFieldName);
        LuaAPI.lua_newtable(rawL);
        LuaAPI.lua_pushvalue(rawL, -3);
        LuaAPI.lua_setmetatable(rawL, -2);
        LuaAPI.lua_rawset(rawL, LuaIndexes.LUA_REGISTRYINDEX);

        LuaAPI.lua_pop(rawL, 1); // pop metatable of indexs and newindexs functions

        LuaAPI.xlua_pushasciistring(rawL, MAIN_SHREAD);
        LuaAPI.lua_pushthread(rawL);
        LuaAPI.lua_rawset(rawL, LuaIndexes.LUA_REGISTRYINDEX);

        LuaAPI.xlua_pushasciistring(rawL, CSHARP_NAMESPACE);
        if (0 != LuaAPI.xlua_getglobal(rawL, &quot;CS&quot;))
        {
            throw new Exception(&quot;get CS fail!&quot;);
        }
        LuaAPI.lua_rawset(rawL, LuaIndexes.LUA_REGISTRYINDEX);

#if !XLUA_GENERAL &amp;&amp; (!UNITY_WSA || UNITY_EDITOR)
        translator.Alias(typeof(Type), &quot;System.MonoType&quot;);
#endif

        if (0 != LuaAPI.xlua_getglobal(rawL, &quot;_G&quot;))
        {
            throw new Exception(&quot;get _G fail!&quot;);
        }
        translator.Get(rawL, -1, out _G);
        LuaAPI.lua_pop(rawL, 1);

        errorFuncRef = LuaAPI.get_error_func_ref(rawL);

        if (initers != null)
        {
            for (int i = 0; i &lt; initers.Count; i++)
            {
                initers[i](this, translator);
            }
        }

        translator.CreateArrayMetatable(rawL);
        translator.CreateDelegateMetatable(rawL);
        translator.CreateEnumerablePairs(rawL);
    }

</code></pre><ul>
<li>xLua的状态机构造函数比较庞大，将所有初始化操作全部集中在这里，接下来将逐一来分析其作用（以lua-5.3.5为例）。</li>
</ul>
<h4 id=初始化相关库>初始化相关库</h4>
<ul>
<li>LuaAPI.luaopen_xlua
<ul>
<li>初始化lua侧的基本库，包括package、coroutine、table、io、os、string、math、utf8、debug等。</li>
</ul>
</li>
<li>LuaAPI.luaopen_i64lib
<ul>
<li>初始化64位整型，包括int64和uint64。</li>
</ul>
</li>
</ul>
<h4 id=objecttranslator>ObjectTranslator</h4>
<ul>
<li>ObjectTranslator中进行了一些初始化操作，主要为：
<ul>
<li>缓存程序集，包括当前运行的程序集、mscorlib、System、System.Core。</li>
<li>创建ObjectCaster，初始化基本类型、LuaTable、LuaFunction的转化委托（返回object）。</li>
<li>创建ObjectCheckers，初始化基本类型、LuaTable、LuaFunction的类型检查。</li>
<li>创建MethodWrapsCache，建立运行时方法Wrap的缓存。</li>
<li>创建StaticLuaCallbacks，将一些常用的方法转成LuaFunction：
<ul>
<li>LuaGC：lua对象gc回收。</li>
<li>ToString：调用CSharp的ToString。</li>
<li>EnumAnd：枚举与操作。</li>
<li>EnumOr：枚举或操作。</li>
<li>StaticCSFunction：lua方法委托。</li>
<li>FixCSFunction：lua修复的方法委托。</li>
<li>DelegateConstructor：委托构造方法。</li>
</ul>
</li>
<li>将一些特殊方法转成LuaFunction：
<ul>
<li>StaticLuaCallbacks.ImportType：注册CSharp的class到lua侧。</li>
<li>StaticLuaCallbacks.LoadAssembly：加载程序集到ObjectTranslator.assemblies。</li>
<li>StaticLuaCallbacks.Cast：将某个对象的metatable设置为CSharp的class。</li>
</ul>
</li>
<li>创建一个表放入 LUA_REGISTRYINDEX 表，id为 ObjectTranslator.cacheRef，再创建一个值弱表（{__mode = &ldquo;v&rdquo;}），设置为此表的metatable。</li>
<li>创建 LuaCSFunction 的 metatable，包含__gc方法，放入 LUA_REGISTRYINDEX 表。</li>
<li>注册方法到lua侧：
<ul>
<li>xlua.import_type：CSharp侧的StaticLuaCallbacks.ImportType。</li>
<li>xlua.import_generic_type：CSharp侧的StaticLuaCallbacks.ImportGenericType。</li>
<li>xlua.cast：CSharp侧的StaticLuaCallbacks.Cast。</li>
<li>xlua.load_assembly：CSharp侧的StaticLuaCallbacks.LoadAssembly。</li>
<li>xlua.access：CSharp侧的StaticLuaCallbacks.XLuaAccess。</li>
<li>xlua.private_accessible：CSharp侧的StaticLuaCallbacks.XLuaPrivateAccessible。</li>
<li>xlua.metatable_operation：CSharp侧的StaticLuaCallbacks.XLuaMetatableOperation。</li>
<li>xlua.tofunction：CSharp侧的StaticLuaCallbacks.ToFunction。</li>
<li>xlua.get_generic_method：CSharp侧的StaticLuaCallbacks.GetGenericMethod。</li>
<li>xlua.release：CSharp侧的StaticLuaCallbacks.ReleaseCsObject。</li>
</ul>
</li>
<li>创建新表存入 LUA_REGISTRYINDEX 表，作为array的metatable，id为 common_array_meta。</li>
<li>创建新表存入 LUA_REGISTRYINDEX 表，作为delegate的metatable，id为 common_delegate_meta。</li>
</ul>
</li>
</ul>
<h4 id=初始化lua环境>初始化lua环境</h4>
<ul>
<li>执行 init_xlua 脚本，对lua环境进行初始化：
<ul>
<li>创建 CS 表，设置metatable方法：
<ul>
<li>__index方法：查找对应的类型，如：CS.UnityEngine.GameObject，则调起CSharp侧的 StaticLuaCallbacks.ImportType，将CSharp侧的类注册到lua侧，并将此类型缓存到 CS 表中。</li>
<li>__newindex方法：输出报错信息，当前没有这个类型。</li>
<li>__call方法：泛型类对象获取，如：CS.System.Collections.Generic.List(CS.System.String)，则会调起 StaticLuaCallbacks.ImportGenericType，获取指定类型的泛型type。由于每次调用都会触发 StaticLuaCallbacks.ImportGenericType 方法，而此方法中使用Type.MakeGenericType来构造泛型对象，需要创建Type数组，所以会有gc产生，可以缓存对象重复使用。</li>
</ul>
</li>
<li>注册 typeof 方法为CSharp的 Type.UnderlyingSystemType。</li>
<li>注册 setfenv 和 getfenv 方法。</li>
<li>注册 xlua.hotfix 方法，可以进行热修复。</li>
<li>注册 xlua.setmetatable 方法为 xlua.metatable_operation(cs)。</li>
<li>注册 xlua.setmetatable 方法为 xlua.metatable_operation(cs, mt)。</li>
<li>注册 xlua.setclass 方法，可实现CSharp的class或者struct在lua侧改造。</li>
<li>注册 base 方法，可实现调用CSharp父类对象方法（Hotfix.BASE_RPOXY_PERFIX标识）。</li>
</ul>
</li>
</ul>
<h4 id=方法设置>方法设置</h4>
<ul>
<li>注册lua侧的print方法为CSharp侧的StaticLuaCallbacks.Print。</li>
<li>设置lua侧的package.seachers方法，用于require调起：
<ul>
<li>package.seachers[2]（即 searcher_Lua）设置为CSharp侧的StaticLuaCallbacks.LoadBuiltinLib。</li>
<li>package.seachers[3]（即 searcher_C）设置为CSharp侧的StaticLuaCallbacks.LoadFromCustomLoaders。</li>
<li>package.seachers[4]（即 searcher_Croot）设置为CSharp侧的StaticLuaCallbacks.LoadFromResource。</li>
<li>package.seachers[5]（即 NULL）设置为CSharp侧的StaticLuaCallbacks.LoadFromStreamingAssetsPath。</li>
</ul>
</li>
<li>设置CSharp侧LoadBuiltinLib的查找字典LuaEnv.buildin_initer，当调用package.seachers[2]时，会从字典中中找：
<ul>
<li>socket.core：CSharp侧的StaticLuaCallbacks.LoadSocketCore。</li>
<li>socket：CSharp侧的StaticLuaCallbacks.LoadSocketCore。</li>
<li>CS：CSharp侧的StaticLuaCallbacks.LoadCS，获取 LUA_REGISTRYINDEX 表里的 xlua_csharp_namespace 表。</li>
</ul>
</li>
<li>设置index和newindex相关表：
<ul>
<li>创建新表meta，设置 __index 方法为CSharp侧的 StaticLuaCallbacks.MetaFuncIndex，查找当前表里对应type的内容。</li>
<li>创建新表，key值为 LuaIndexs，存入 LUA_REGISTRYINDEX 中，设置其metatable为meta表。</li>
<li>创建新表，key值为 LuaNewIndexs，存入 LUA_REGISTRYINDEX 中，设置其metatable为meta表。</li>
<li>创建新表，key值为 LuaClassIndexs，存入 LUA_REGISTRYINDEX 中，设置其metatable为meta表。</li>
<li>创建新表，key值为 LuaClassNewIndexs，存入 LUA_REGISTRYINDEX 中，设置其metatable为meta表。</li>
</ul>
</li>
<li>设置主线程到 LUA_REGIXTRYINDEX 中，key值为 xlua_main_thread。</li>
<li>将 _G 中的 CS 表，存入 LUA_REGISTRYINDEX 中，key值为 xlua_csharp_namespace。</li>
<li>初始化前面创建的array的metatable，进行相关注册：
<ul>
<li>__gc 方法设为CSharp侧的 StaticLuaCallbacks.LuaGC。</li>
<li>__tostring 方法设为CSharp侧的 StaticLuaCallbacks.ToString。</li>
<li>Length 方法设为CSharp侧的 StaticLuaCallbacks.ArrayLength。</li>
<li>__index 方法设为CSharp侧的 StaticLuaCallbacks.ArrayIndexer。</li>
<li>__newindex 方法设为CSharp侧的 StaticLuaCallbacks.ArrayNewIndexer。</li>
</ul>
</li>
<li>初始化前面创建的delegate的metatable，进行相关注册：
<ul>
<li>__gc 方法设为CSharp侧的 StaticLuaCallbacks.LuaGC。</li>
<li>__tostring 方法设为CSharp侧的 StaticLuaCallbacks.ToString。</li>
<li>__call 方法设为CSharp侧的 StaticLuaCallbacks.DelegateCall。</li>
<li>__add 方法设为CSharp侧的 StaticLuaCallbacks.DelegateCombine。</li>
<li>__sub 方法设为CSharp侧的 StaticLuaCallbacks.DelegateRemove。</li>
<li>__index 方法设为CSharp侧的 StaticLuaCallbacks.ArrayIndexer。</li>
<li>__newindex 方法设为CSharp侧的 StaticLuaCallbacks.ArrayNewIndexer。</li>
</ul>
</li>
<li>创建迭代访问Pairs方法，存入到 LUA_REGISTRYINDEX 中，id为 enumerable_pairs_func。</li>
</ul>
<h4 id=结构>结构</h4>
<ul>
<li>经过初始化后，当前lua侧的结构大致如下：</li>
</ul>
<pre tabindex=0><code>    _G = {
        ...

        xlua.import_type = CSharp侧的StaticLuaCallbacks.ImportType
        xlua.import_generic_type = CSharp侧的StaticLuaCallbacks.ImportGenericType
        xlua.cast = CSharp侧的StaticLuaCallbacks.Cast
        xlua.load_assembly = CSharp侧的StaticLuaCallbacks.LoadAssembly
        xlua.access = CSharp侧的StaticLuaCallbacks.XLuaAccess
        xlua.private_accessible = CSharp侧的StaticLuaCallbacks.XLuaPrivateAccessible
        xlua.metatable_operation = CSharp侧的StaticLuaCallbacks.XLuaMetatableOperation
        xlua.tofunction = CSharp侧的StaticLuaCallbacks.ToFunction
        xlua.get_generic_method = CSharp侧的StaticLuaCallbacks.GetGenericMethod
        xlua.release = CSharp侧的StaticLuaCallbacks.ReleaseCsObject

        CS（所有CSharp的对应表）:
            table = {

            },
            metatable = {
                __index = CSharp侧 LuaEnv.init_xlua 中的 __index(key),
                __newindex = CSharp侧 LuaEnv.init_xlua 中的 __newindex(),
                __call = CSharp侧 LuaEnv.init_xlua 中的 __call(...),
            }

        typeof = CSharp的 Type.UnderlyingSystemType
        setfenv = CSharp侧 LuaEnv.init_xlua 中的 setfenv
        getfenv = CSharp侧 LuaEnv.init_xlua 中的 getfenv
        xlua.hotfix = CSharp侧 LuaEnv.init_xlua 中的 xlua.hotfix
        xlua.setmetatable = xlua.metatable_operation(cs)
        xlua.setmetatable = xlua.metatable_operation(cs, mt)
        xlua.setclass = CSharp侧 LuaEnv.init_xlua 中的 xlua.setclass
        base = CSharp侧 LuaEnv.init_xlua 中的 base

        print = CSharp侧的 StaticLuaCallbacks.Print
    }

    -10000（即 LUA_REGISTRYINDEX） = {
        ...

        ref_cacheRef（分配的id，在CSharp侧为 ObjectTranslator.cacheRef）
            table = {

            },
            metatable = {
                __mode = v
            }

        ref_LuaCSFunction（分配的id，在CSharp侧存到 ObjectTranslator.typeIdMap） = {
            __gc = CSharp侧的 StaticLuaCallbacks.LuaGC,
            &amp;tag = 1
        }

        ref_common_array_meta = {
            __gc = CSharp侧的 StaticLuaCallbacks.LuaGC
            __tostring = CSharp侧的 StaticLuaCallbacks.ToString
            Length = CSharp侧的 StaticLuaCallbacks.ArrayLength
            __index = CSharp侧的 StaticLuaCallbacks.ArrayIndexer
            __newindex = CSharp侧的 StaticLuaCallbacks.ArrayNewIndexer           
        }

        ref_common_delegate_meta = {
            __gc = CSharp侧的 StaticLuaCallbacks.LuaGC
            __tostring = CSharp侧的 StaticLuaCallbacks.ToString
            __call = CSharp侧的 StaticLuaCallbacks.DelegateCall
            __add = CSharp侧的 StaticLuaCallbacks.DelegateCombine
            __sub = CSharp侧的 StaticLuaCallbacks.DelegateRemove
            __index = CSharp侧的 StaticLuaCallbacks.ArrayIndexer
            __newindex = CSharp侧的 StaticLuaCallbacks.ArrayNewIndexer
        }

        ref_enumerable_pairs_func = CSharp侧 ObjectTranslator.CreateEnumerablePairs方法中的lua代码方法

        LuaIndexs ：
            table = {},
            metatable = {
                __index = StaticLuaCallbacks.MetaFuncIndex
            }

        LuaNewIndexs ：
            table = {},
            metatable = {
                __index = StaticLuaCallbacks.MetaFuncIndex
            }

        LuaClassIndexs ：
            table = {},
            metatable = {
                __index = StaticLuaCallbacks.MetaFuncIndex
            }
        
        LuaClassNewIndexs ：
            table = {},
            metatable = {
                __index = StaticLuaCallbacks.MetaFuncIndex
            }

        xlua_csharp_namespace = _G.CS 表
    }
</code></pre><h3 id=访问对象>访问对象</h3>
<h4 id=lua访问csharp对象>Lua访问CSharp对象</h4>
<ul>
<li>当我们在Lua侧，要获取CSharp对象时，以GameObject为例，当我们查找某个GameObject时，在lua侧会使用</li>
</ul>
<pre tabindex=0><code>    -- Test.lua

    local go = CS.UnityEngine.GameObject.Find(&quot;TestGameObject&quot;);
</code></pre><ul>
<li>调用CSharp侧的GameObject.Find来获取对象，这里有几个步骤：
<ul>
<li>获取 _G.CS 表，查找 CS.UnityEngine 对象。</li>
<li>CS 表中不存在 UnityEngine，则触发CSharp侧的 StaticLuaCallbacks.ImportType方法，查找对应类。</li>
<li>由于UnityEngine不为class，所以设置 CS.UnityEngine 的 table 为 { &ldquo;.fqn&rdquo; = &ldquo;UnityEngine&rdquo; }，metatable为CS表的metatable。</li>
<li>查找GameObject对象，同样触发CSharp侧的 StaticLuaCallbacks.ImportType方法，查找UnityEngine.GameObject，并注册到lua侧中。</li>
<li>查找Find方法，传入参数并执行，触发CSharp侧的 GameObject.Find 方法，找到对应的GameObject。</li>
<li>调用ObjectTranslator.Push，创建index，返回lua侧。</li>
<li>lua侧使用index创建userdata，持有GameObject对象。</li>
</ul>
</li>
<li>在整个过程中，有两个步骤是比较重要的：
<ul>
<li>把CSharp的类注册到Lua侧。</li>
<li>将CSharp的对象绑定到Lua侧。</li>
</ul>
</li>
</ul>
<h5 id=注册csharp类>注册CSharp类</h5>
<ul>
<li>注册CSharp类的主要方法为 ObjectTranslator.GetTypeId ，其主要流程为：
<ul>
<li>查找 ObjectTranslator.typeIdMap 中是否有对应类型，有则直接返回。</li>
<li>如果是 Array 类型，则返回 common_array_meta 。</li>
<li>如果是 MulticastDelegate 类型，调用 TryDelayWrapLoader 方法创建类型的metatable。</li>
<li>如果 LUA_REGISTRYINDEX 表中没有此类型的metatable，则调用 TryDelayWrapLoader 方法创建（key值为type.FullName）。</li>
<li>如果是 Enum 类型，则在metatable中设置方法：
<ul>
<li>__band 设置为 StaticLuaCallbacks.EnumAnd。</li>
<li>__bor 设置为 StaticLuaCallbacks.EnumOr。</li>
</ul>
</li>
<li>如果是 IEnumerable 类型，则设置 __pairs 为 ref_enumerable_pairs_func的方法。</li>
<li>将此metatable存到 LUA_REGISTRYINDEX 表中，id为lua侧创建的引用 type_id。</li>
<li>将 type_id 存入 typeIdMap 中。</li>
</ul>
</li>
<li>ObjectTranslator.TryDelayWrapLoader 为创建metatable的方法，主要有两种方式：
<ul>
<li>预先生成CSharp侧的Wrap脚本，将类型和 XXXWrap.__Register 存入ObjectTranslator.delayWrap中，通过调用 __Register 方法，进行注册。</li>
<li>通过反射进行注册。</li>
</ul>
</li>
</ul>
<h6 id=wrap注册>Wrap注册</h6>
<ul>
<li>Wrap方式主要是预先生成Wrap文件，然后通过 __Register 方法初始化，主要有以下方法：
<ul>
<li>Utils.BeginObjectRegister：注册类实例对象相关信息。
<ul>
<li>将type的对应metatable压入栈上。</li>
<li>如果传入type为空，或者type是ObjectTranslator.custom_push_funcs（[LuaCallCSharp]的Enum、[GCOptimize]）且不为decimal，则设置 __gc 方法为CSharp侧的 StaticLuaCallbacks.LuaGC。</li>
<li>设置 __tostring 方法为CSharp侧的 StaticLuaCallbacks.ToString。</li>
<li>如果方法数量（method_count）不为0，则创建method_count大小的table到栈上，否则压入nil。</li>
<li>如果get属性数量（getter_count）不为0，则创建getter_count大小的table到栈上，否则压入nil。</li>
<li>如果set属性数量（setter_count）不为0，则创建setter_count大小的table到栈上，否则压入nil。</li>
<li>当前栈顶的情况为：
<ul>
<li>-1 ： set的table</li>
<li>-2 ： get的table</li>
<li>-3 ： method的table</li>
<li>-4 ： type的metatable</li>
</ul>
</li>
</ul>
</li>
<li>Utils.RegisterFunc：注册方法。
<ul>
<li>传入注册的方法的类型idx，和入栈顺序对应上：
<ul>
<li>Utils.OBJ_META_IDX：-4，metatable。</li>
<li>Utils.METHOD_IDX、Utils.：-3，普通方法表。</li>
<li>Utils.GETTER_IDX：-2，get方法表。</li>
<li>Utils.SETTER_IDX：-1，set方法表。</li>
<li>Utils.CLS_IDX：-4，class的table。</li>
<li>Utils.CLS_META_IDX：-3，class的metatable。</li>
<li>Utils.CLS_GETTER_IDX：-2，class的get方法表。</li>
<li>Utils.CLS_SETTER_IDX：-1，class的set方法表。</li>
</ul>
</li>
<li>获取方法在栈上的位置（栈顶位置 + idx + 1）。</li>
<li>将方法名和方法设置到栈上对应位置的table中。</li>
</ul>
</li>
<li>Utils.EndObjectRegister：完成实例对象注册。
<ul>
<li>设置metatable的__index：
<ul>
<li>将"__index"字符串入栈。</li>
<li>将method的table入栈。</li>
<li>将get的table入栈。</li>
<li>将CSharp侧的csIndexer方法入栈。</li>
<li>将type的基类base_type入栈。</li>
<li>将 LUA_REGISTRYINDEX 表中的 LuaIndexs 表入栈。</li>
<li>将CSharp侧的arrayIndexer方法入栈。</li>
<li>调用lua侧的 gen_obj_indexer 方法，将nil入栈，然后创建一个包括7个值的闭包，方法为 obj_indexer，将对应值出栈，闭包压入栈上。
<ul>
<li>闭包的值对应为 [1]: methods, [2]:getters, [3]:csindexer, [4]:base, [5]:indexfuncs, [6]:arrayindexer, [7]:baseindex</li>
<li>传入的参数对应为 [1]: obj, [2]: key</li>
</ul>
</li>
<li>将闭包存入 LuaIndexs 表，key为type的userdata。</li>
<li>设置type的metatable方法，key值为__index，value为 LuaIndexs 表。</li>
</ul>
</li>
<li>设置metatable的__newindex：
<ul>
<li>将"__newindex"字符串入栈。</li>
<li>将set的table入栈。</li>
<li>将CSharp侧的csNewIndexer方法入栈。</li>
<li>将type的基类base_type入栈。</li>
<li>将 LUA_REGISTRYINDEX 表中的 LuaNewIndexs 表入栈。</li>
<li>将CSharp侧的arrayNewIndexer方法入栈。</li>
<li>调用lua侧的 gen_obj_newindexer 方法，将nil入栈，然后创建一个包括6个值的闭包，方法为 obj_newindexer，将对应值出栈，闭包压入栈上。
<ul>
<li>闭包的值对应为 [1]:setters, [2]:csnewindexer, [3]:base, [4]:newindexfuncs, [5]:arrayindexer, [6]:basenewindex</li>
<li>传入的参数对应为 [1]: obj, [2]: key, [3]: value</li>
</ul>
</li>
<li>将闭包存入 LuaNewIndexs 表，key为type的userdata。</li>
<li>设置type的metatable方法，key值为__newindex，value为 LuaNewIndexs 表。</li>
</ul>
</li>
<li>将set、get、method的table和type的metatable出栈，恢复栈顶信息。</li>
</ul>
</li>
<li>Utils.BeginClassRegister：注册类相关信息，主要为静态对象、常量、枚举。
<ul>
<li>创建一个新表 cls_table，大小为类的静态对象和方法、常量、枚举的数量总数量 + 1。</li>
<li>设置type的userdata到cls_table中，key值为 UnderlyingSystemType（每个class都会注册这个key-value，所以cls_table的总大小+1）。</li>
<li>调用CSharp的 Util.SetCSTable 方法，注册type对应lua侧表：
<ul>
<li>将类型按 &ldquo;.&rdquo; 分割，创建对应table，存入 LUA_REGISTRYINDEX 表中的 xlua_csharp_namespace 表，如 UnityEngine.GameObject ，则创建key值 UnityEngine 的表存入 xlua_csharp_namespace 表，再将 cls_table 存入 UnityEngine 表中，key值为 GameObject。</li>
<li>将 cls_table 表存到 xlua_csharp_namespace 表，key值为type的userdata。</li>
</ul>
</li>
<li>创建新表 meta_table，设置__call方法为CSharp传入的creator方法。</li>
<li>创建get的table入栈。</li>
<li>创建set的table入栈。</li>
<li>设置为 cls_table 的metatable为 meta_table。</li>
</ul>
</li>
<li>Utils.RegisterObject：注册对象，通常为Enum值、常量等。
<ul>
<li>根据传入的类型idx，将对象设置到栈上对应table中，key值为传入的name。</li>
</ul>
</li>
<li>Utils.EndClassRegister
<ul>
<li>设置cls_table的index：
<ul>
<li>将"__index"入栈。</li>
<li>将get的table入栈。</li>
<li>将cls的table入栈。</li>
<li>将type的基类入栈。</li>
<li>将 LUA_REGISTRYINDEX 表中的 LuaClassIndexs 表入栈。</li>
<li>调用lua侧的 gen_cls_indexer 方法，将nil入栈，然后创建一个包括5个值的闭包，方法为 cls_indexer，将对应值出栈，闭包压入栈上。
<ul>
<li>闭包的值对应为 [1]:getters, [2]:feilds, [3]:base, [4]:indexfuncs, [5]:baseindex</li>
<li>传入的参数对应为 [1]: obj, [2]: key</li>
</ul>
</li>
<li>将闭包存入 LuaClassIndexs 表，key值为type的userdata。</li>
<li>设置cls_table的metatable方法，key值为__index，value为 LuaClassIndexs 表。</li>
</ul>
</li>
<li>设置cls的newindex：
<ul>
<li>将"__newindex"入栈。</li>
<li>将set的table入栈。</li>
<li>将type的基类入栈。</li>
<li>将 LUA_REGISTRYINDEX 表中的 LuaClassNewIndexs 表入栈。</li>
<li>调用lua侧的 gen_cls_newindexer 方法，将nil入栈，然后创建一个包括4个值的闭包，方法为 cls_newindexer，将对应值出栈，闭包压入栈上。
<ul>
<li>闭包的值对应为 [1]:setters, [2]:base, [3]:indexfuncs, [4]:baseindex</li>
<li>传入的参数对应为 [1]: obj, [2]: key, [3]: value</li>
</ul>
</li>
<li>将闭包存入 LuaClassNewIndexs 表，key值为type的userdata。</li>
<li>设置cls_table的metatable方法，key值为__newindex，value为 LuaClassNewIndexs 表。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id=反射注册>反射注册</h6>
<ul>
<li>反射注册的流程和Wrap流程基本一致，只是没有预先生成代码，主要流程为：
<ul>
<li>创建type的metatable，为obj_meta，存到 LUA_REGISTRYINDEX 表，key值为type.FullName。</li>
<li>设置 &tag 为 1。</li>
<li>创建cls_meta、obj_field、obj_getter、obj_setter、cls_field表。</li>
<li>调用CSharp侧的 Util.SetCSTable 方法，注册type对应lua侧表。</li>
<li>创建cls_getter、cls_setter表。</li>
<li>调用 makeReflectionWrap 方法，进行Wrap注册：
<ul>
<li>定义flag为 BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | access，access根据需求设置，可为 BindingFlags.Public 或 BindingFlags.NonPublic 或两者同时设置。</li>
<li>获取当前type符合flag类型的所有变量fields。</li>
<li>获取当前type符合类型（flag | BindingFlags.Public | BindingFlags.NonPublic）的所有事件all_events。</li>
<li>遍历fields对变量进行处理：
<ul>
<li>静态变量，如果变量名以 &ldquo;__Hotfix&rdquo; 或 &ldquo;_c__Hotfix&rdquo; 开头，且为委托，则不处理。</li>
<li>如果 all_events 中有这个变量名，则在 fieldName 前加 &ldquo;&"。</li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id=绑定csharp对象>绑定CSharp对象</h5>
<h4 id=csharp访问lua对象>CSharp访问Lua对象</h4>
<h4 id=时序图>时序图</h4>
<h3 id=调用方法>调用方法</h3>
<h4 id=lua调用csharp方法>Lua调用CSharp方法</h4>
<h4 id=csharp调用lua方法>CSharp调用Lua方法</h4>
<h3 id=委托>委托</h3>
<h3 id=重载>重载</h3>
<h3 id=无gc传值>无GC传值</h3>
<h3 id=泛型>泛型</h3>
<h3 id=反射>反射</h3>
<h3 id=64位整型>64位整型</h3>
<pre tabindex=0><code>    _G = {
        uint64 = {
            tostring = i64lib.c的 uint64_tostring 方法
            compare = i64lib.c的 uint64_compare 方法
            divide = i64lib.c的 uint64_divide 方法
            remainder = i64lib.c的 uint64_remainder 方法
            parse = i64lib.c的 uint64_parse 方法
        }
    }

    -10000（即 LUA_REGISTRYINDEX） = {
        ...

        -- 5.1.5版本才有
        8（即 INT64_META_REF） = {
            __add = i64lib.c的 int64_add 方法
            __sub = i64lib.c的 int64_sub 方法
            __mul = i64lib.c的 int64_mul 方法
            __div = i64lib.c的 int64_div 方法
            __mod = i64lib.c的 int64_mod 方法
            __unm = i64lib.c的 int64_unm 方法
            __pow = i64lib.c的 int64_pow 方法
            __tostring = i64lib.c的 int64_tostring 方法
            __eq = i64lib.c的 int64_eq 方法
            __lt = i64lib.c的 int64_lt 方法
            __le = i64lib.c的 int64_le 方法
            __tostring = i64lib.c的 int64_tostring 方法
        }

    }
</code></pre><h3 id=协程>协程</h3>
<h3 id=接口interface>接口（Interface）</h3>
<h3 id=热修复>热修复</h3>
<h2 id=总结>总结</h2>
<hr>
<ul class=pager>
<li class=previous>
<a href=/post/lua/lua_tolua/ data-toggle=tooltip data-placement=top title="Lua篇 — (2) ToLua">&larr;
Previous Post</a>
</li>
</ul>
<div id=disqus-comment></div>
</div>
<div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container">
<div class=side-catalog>
<hr class="hidden-sm hidden-xs">
<h5>
<a class=catalog-toggle href=#>CATALOG</a>
</h5>
<ul class=catalog-body></ul>
</div>
</div>
<div class="col-lg-11 col-lg-offset-1
col-md-10 col-md-offset-1
sidebar-container">
</div>
</div>
</div>
</article>
<footer>
<div class=container>
<div class=row>
<div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
<ul class="list-inline text-center">
</ul>
<p class="copyright text-muted">
Copyright &copy; Xun's Blog 2021
<br>
<a href=https://themes.gohugo.io/hugo-theme-cleanwhite>CleanWhite Hugo Theme</a> by <a href=https://zhaohuabing.com>Huabing</a> |
<iframe style=margin-left:2px;margin-bottom:-5px frameborder=0 scrolling=0 width=100px height=20px src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true"></iframe>
</p>
</div>
</div>
</div>
</footer>
<script>function loadAsync(f,b){var c=document,d='script',a=c.createElement(d),e=c.getElementsByTagName(d)[0];a.src=f,b&&a.addEventListener('load',function(a){b(null,a)},!1),e.parentNode.insertBefore(a,e)}</script>
<script>$('#tag_cloud').length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:'#bbbbee',end:'#0085a1'}},$('#tag_cloud a').tagcloud()})</script>
<script>loadAsync("https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.js",function(){var a=document.querySelector("nav");a&&FastClick.attach(a)})</script>
<script type=text/javascript>function generateCatalog(a){_containerSelector='div.post-container';var h=$(_containerSelector),c,d,e,f,g,b;return c=h.find('h1,h2,h3,h4,h5,h6'),$(a).html(''),c.each(function(){d=$(this).prop('tagName').toLowerCase(),g="#"+$(this).prop('id'),e=$(this).text(),b=$('<a href="'+g+'" rel="nofollow">'+e+'</a>'),f=$('<li class="'+d+'_nav"></li>').append(b),$(a).append(f)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(a){a.preventDefault(),$('.side-catalog').toggleClass("fold")}),loadAsync("/js/jquery.nav.js",function(){$('.catalog-body').onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script>
</body>
</html>
<!doctype html><html lang=zh-cn>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta property="og:site_name" content="Xun's Blog">
<meta property="og:type" content="article">
<meta property="og:image" content="https://fallingxun.github.io//">
<meta property="twitter:image" content="https://fallingxun.github.io//">
<meta name=title content="Unity篇 — 事件系统">
<meta property="og:title" content="Unity篇 — 事件系统">
<meta property="twitter:title" content="Unity篇 — 事件系统">
<meta name=description content>
<meta property="og:description" content>
<meta property="twitter:description" content>
<meta property="twitter:card" content="summary">
<meta name=keyword content>
<link rel="shortcut icon" href=/img/favicon.ico>
<title>Unity篇 — 事件系统-</title>
<link rel=canonical href=/post/unity/ugui/eventsystem/>
<link rel=stylesheet href=/css/iDisqus.min.css>
<link rel=stylesheet href=/css/bootstrap.min.css>
<link rel=stylesheet href=/css/hugo-theme-cleanwhite.min.css>
<link rel=stylesheet href=/css/zanshang.css>
<link href=//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css rel=stylesheet type=text/css>
<script src=/js/jquery.min.js></script>
<script src=/js/bootstrap.min.js></script>
<script src=/js/hux-blog.min.js></script>
</head>
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
<div class=container-fluid>
<div class="navbar-header page-scroll">
<button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=/>Xun's Blog</a>
</div>
<div id=huxblog_navbar>
<div class=navbar-collapse>
<ul class="nav navbar-nav navbar-right">
<li>
<a href=/>Home</a>
</li>
<li>
<a href=/categories/googleplay%E7%B3%BB%E5%88%97>googleplay系列</a>
</li>
<li>
<a href=/categories/lua%E7%B3%BB%E5%88%97>lua系列</a>
</li>
<li>
<a href=/categories/tmp%E7%B3%BB%E5%88%97>tmp系列</a>
</li>
<li>
<a href=/categories/unity%E7%B3%BB%E5%88%97>unity系列</a>
</li>
<li>
<a href=/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%B3%BB%E5%88%97>图形学系列</a>
</li>
<li>
<a href=/categories/%E6%B8%B2%E6%9F%93%E7%B3%BB%E5%88%97>渲染系列</a>
</li>
<li>
<a href=/categories/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97>算法系列</a>
</li>
</ul>
</div>
</div>
</div>
</nav>
<script>var $body=document.body,$toggle=document.querySelector('.navbar-toggle'),$navbar=document.querySelector('#huxblog_navbar'),$collapse=document.querySelector('.navbar-collapse');$toggle.addEventListener('click',handleMagic);function handleMagic(a){$navbar.className.indexOf('in')>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf('in')<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script>
<style type=text/css>header.intro-header{background-image:url('/')}</style>
<header class=intro-header>
<div class=container>
<div class=row>
<div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
<div class=post-heading>
<div class=tags>
<a class=tag href=/tags/%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F title=事件系统>
事件系统
</a>
<a class=tag href=/tags/%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6 title=点击事件>
点击事件
</a>
<a class=tag href=/tags/eventsystem title=EventSystem>
EventSystem
</a>
</div>
<h1>Unity篇 — 事件系统</h1>
<h2 class=subheading></h2>
<span class=meta>
Posted by
Xun
on
Sunday, January 29, 2023
</span>
</div>
</div>
</div>
</div>
</header>
<article>
<div class=container>
<div class=row>
<div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container">
<p>Unity 中各种点击、拖拽的交互响应是不可或缺的。在 UGUI 中，使用了 EventSystem 进行管理。</p>
<h2 id=简介>简介</h2>
<ul>
<li>一个简单的交互流程，主要有以下步骤：
<ul>
<li>用户点击、滑动、拖拽鼠标（或屏幕）</li>
<li>找到响应的对象</li>
<li>执行对象对应的方法</li>
</ul>
</li>
<li>因此，相对地，就需要知道
<ul>
<li>如何获取玩家的操作</li>
<li>如何找到需要响应的对象</li>
<li>如何执行对应方法</li>
</ul>
</li>
<li>Unity 的事件系统，主要由输入模块（InputModule）、射线检测模块（Raycast）、事件执行模块（ExecuteEvents）组成，在事件系统（EventSystem）的管理下进行。</li>
</ul>
<h2 id=时序图>时序图</h2>
<ul>
<li>EventSystem 的时序图如下
<img src="/img/Unity/EventSystem/EventSystem%e6%97%b6%e5%ba%8f%e5%9b%be.png?raw=true" alt=EventSystem时序图.png>
</li>
</ul>
<h2 id=eventsystem-主流程>EventSystem 主流程</h2>
<ul>
<li>EventSystem 继承 UIBehavior ，作为组件进行使用。其定义了几个对象：
<ul>
<li>m_SystemInputModules ：当前 EventSystem 的所有 InputModule 列表（List<baseinputmodule>）。</li>
<li>m_CurrentInputModule ：当前 EventSystem 使用的 InputModule 。</li>
<li>m_EventSystems ：所有 EventSystem 列表（static List<eventsystem>）。</li>
<li>current ：当前使用的 EventSystem 。</li>
</ul>
</li>
</ul>
<pre tabindex=0><code>    public class EventSystem : UIBehaviour
    {
        private List&lt;BaseInputModule&gt; m_SystemInputModules = new List&lt;BaseInputModule&gt;();

        private BaseInputModule m_CurrentInputModule;

        private  static List&lt;EventSystem&gt; m_EventSystems = new List&lt;EventSystem&gt;();

        /// &lt;summary&gt;
        /// Return the current EventSystem.
        /// &lt;/summary&gt;
        public static EventSystem current
        {
            get { return m_EventSystems.Count &gt; 0 ? m_EventSystems[0] : null; }
            set
            {
                int index = m_EventSystems.IndexOf(value);

                if (index &gt; 0)
                {
                    m_EventSystems.RemoveAt(index);
                    m_EventSystems.Insert(0, value);
                }
                else if (index &lt; 0)
                {
                    Debug.LogError(&quot;Failed setting EventSystem.current to unknown EventSystem &quot; + value);
                }
            }
        }

        
        ...
    
    }
</code></pre><ul>
<li>当 EveneSystem 激活时，则会加入 m_EventSystems 列表中。同样，当 EveneSystem 关闭时，则会从 m_EventSystems 列表中移除自身， 并且清除掉当前的输入模块信息 m_CurrentInputModule 。</li>
</ul>
<pre tabindex=0><code>    public class EventSystem : UIBehaviour
    {
        ...
    
        protected override void OnEnable()
        {
            base.OnEnable();
            m_EventSystems.Add(this);
        }

        protected override void OnDisable()
        {
            if (m_CurrentInputModule != null)
            {
                m_CurrentInputModule.DeactivateModule();
                m_CurrentInputModule = null;
            }

            m_EventSystems.Remove(this);

            base.OnDisable();
        }

        ...
    }
</code></pre><ul>
<li>当 EventSystem 处于激活状态时，由于继承 UIBehavior ，每帧会执行 Update 方法进行更新，主要内容为：
<ul>
<li>对 m_SystemInputModules 列表中的所有 InputModule 执行 UpdateModule 方法。</li>
<li>如果当前输入模块 m_CurrentInputModule 为空，或者不为 m_SystemInputModules 列表中首个符合条件的模块，则进行切换。</li>
<li>如果此帧没有进行模块切换，则对当前输入模块 m_CurrentInputModule 执行 Process 方法进行处理。</li>
</ul>
</li>
</ul>
<pre tabindex=0><code>    public class EventSystem : UIBehaviour
    {
        ...
    
        protected virtual void Update()
        {
            if (current != this)
                return;
            // 对 m_SystemInputModules 列表中的所有 InputModule 执行 UpdateModule 方法。
            TickModules();

            //如果当前输入模块 m_CurrentInputModule 为空，或者不为 m_SystemInputModules 列表中首个符合条件的模块，则进行切换。
            bool changedModule = false;
            var systemInputModulesCount = m_SystemInputModules.Count;
            for (var i = 0; i &lt; systemInputModulesCount; i++)
            {
                var module = m_SystemInputModules[i];
                if (module.IsModuleSupported() &amp;&amp; module.ShouldActivateModule())
                {
                    if (m_CurrentInputModule != module)
                    {
                        ChangeEventModule(module);
                        changedModule = true;
                    }
                    break;
                }
            }

            // no event module set... set the first valid one...
            if (m_CurrentInputModule == null)
            {
                for (var i = 0; i &lt; systemInputModulesCount; i++)
                {
                    var module = m_SystemInputModules[i];
                    if (module.IsModuleSupported())
                    {
                        ChangeEventModule(module);
                        changedModule = true;
                        break;
                    }
                }
            }

            // 如果此帧没有进行模块切换，则对当前输入模块 m_CurrentInputModule 执行 Process 方法进行处理。 
            if (!changedModule &amp;&amp; m_CurrentInputModule != null)
                m_CurrentInputModule.Process();

            ...
        }

        ...
    }
</code></pre><ul>
<li>m_SystemInputModules 列表是在 EventSystem.UpdateModules 方法中生成的，即 EventSystem 所属 GameObject 上所有激活的 BaseInputModule 对象。</li>
</ul>
<pre tabindex=0><code>    public class EventSystem : UIBehaviour
    {
        ...
    
        public void UpdateModules()
        {
            GetComponents(m_SystemInputModules);
            var systemInputModulesCount = m_SystemInputModules.Count;
            for (int i = systemInputModulesCount - 1; i &gt;= 0; i--)
            {
                if (m_SystemInputModules[i] &amp;&amp; m_SystemInputModules[i].IsActive())
                    continue;

                m_SystemInputModules.RemoveAt(i);
            }
        }

        ...
    }
</code></pre><ul>
<li>因此，GameObject 上会挂载 EventSystem 组件，同时会挂载其需要的所有 InputModule 组件。</li>
</ul>
<h2 id=inputmodule-输入模块>InputModule 输入模块</h2>
<ul>
<li>从 EventSystem 中知道，InputModule 组件需要挂载到同一个 GameObject 上，并且只有激活的才会加入到 EventSystem.m_SystemInputModules 列表中。</li>
<li>可以看到，BaseInputModule 中，当对象激活时，会获取组件上的 EventSystem，并且调用 EventSystem.UpdateModules 方法，从而实现将自身加入到 EventSystem.m_SystemInputModules 列表中。同样，当对象关闭时，会再次刷新 EventSystem.m_SystemInputModules 列表，将自身移除。</li>
</ul>
<pre tabindex=0><code>    public abstract class BaseInputModule : UIBehaviour
    {
        ...

        protected EventSystem eventSystem
        {
            get { return m_EventSystem; }
        }

        protected override void OnEnable()
        {
            base.OnEnable();
            m_EventSystem = GetComponent&lt;EventSystem&gt;();
            m_EventSystem.UpdateModules();
        }

        protected override void OnDisable()
        {
            m_EventSystem.UpdateModules();
            base.OnDisable();
        }
        
        ...
    }

</code></pre><ul>
<li>EventSystem 更新时，会先触发 BaseInputModule.UpdateModule 方法，默认情况下，会使用 StandaloneInputModule 组件。其中 UpdateModule 方法，主要记录上一帧和当前帧的输入坐标。另外，如果当前没有聚焦，并且处于拖拽状态，则会释放按压状态，结束拖拽。</li>
</ul>
<pre tabindex=0><code>    public class StandaloneInputModule : PointerInputModule
    {
        ...

        public override void UpdateModule()
        {
            if (!eventSystem.isFocused &amp;&amp; ShouldIgnoreEventsOnNoFocus())
            {
                if (m_InputPointerEvent != null &amp;&amp; m_InputPointerEvent.pointerDrag != null &amp;&amp; m_InputPointerEvent.dragging)
                {
                    ReleaseMouse(m_InputPointerEvent, m_InputPointerEvent.pointerCurrentRaycast.gameObject);
                }

                m_InputPointerEvent = null;

                return;
            }

            m_LastMousePosition = m_MousePosition;
            m_MousePosition = input.mousePosition;
        }
        
        ...
    }

</code></pre><ul>
<li>EventSystem 还会对当前输入模块 m_CurrentInputModule 执行 Process 方法，主要进行：
<ul>
<li>对当前选中的 GameObject ，发送更新事件（UpdateEvent）。</li>
<li>处理触碰事件（TouchEvent）。</li>
<li>如果没有触碰事件，则处理鼠标输入事件（MouseEvent）。</li>
<li>对当前选中的 GameObject，发送移动事件（MoveEvent）。</li>
<li>&mldr;</li>
</ul>
</li>
</ul>
<pre tabindex=0><code>    public class StandaloneInputModule : PointerInputModule
    {
        ...

        public override void Process()
        {
            if (!eventSystem.isFocused &amp;&amp; ShouldIgnoreEventsOnNoFocus())
                return;

            bool usedEvent = SendUpdateEventToSelectedObject();

            // case 1004066 - touch / mouse events should be processed before navigation events in case
            // they change the current selected gameobject and the submit button is a touch / mouse button.

            // touch needs to take precedence because of the mouse emulation layer
            if (!ProcessTouchEvents() &amp;&amp; input.mousePresent)
                ProcessMouseEvent();

            if (eventSystem.sendNavigationEvents)
            {
                if (!usedEvent)
                    usedEvent |= SendMoveEventToSelectedObject();

                if (!usedEvent)
                    SendSubmitEventToSelectedObject();
            }
        }
        
        ...
    }

</code></pre><ul>
<li>其中，主要关注的是 TouchEvent 和 MouseEvent。TouchEvent 的主要流程为：
<ul>
<li>调用 EventSystem.RaycastAll 方法，获取射线检测到的第一个 GameObject 。</li>
<li>根据当前的按压（pressed）状态、释放（released）状态，发送不同的事件（PointerDown、PointerClick、Drag 等）。</li>
<li>如果当前没有释放，则进行移动和拖拽处理。</li>
</ul>
</li>
</ul>
<pre tabindex=0><code>    public class StandaloneInputModule : PointerInputModule
    {
        ...

        private bool ProcessTouchEvents()
        {
            for (int i = 0; i &lt; input.touchCount; ++i)
            {
                Touch touch = input.GetTouch(i);

                if (touch.type == TouchType.Indirect)
                    continue;

                bool released;
                bool pressed;
                var pointer = GetTouchPointerEventData(touch, out pressed, out released);

                ProcessTouchPress(pointer, pressed, released);

                if (!released)
                {
                    ProcessMove(pointer);
                    ProcessDrag(pointer);
                }
                else
                    RemovePointerData(pointer);
            }
            return input.touchCount &gt; 0;
        }
        
        ...
    }

</code></pre><pre tabindex=0><code>    public abstract class PointerInputModule : BaseInputModule
    {
        ...

        protected PointerEventData GetTouchPointerEventData(Touch input, out bool pressed, out bool released)
        {

            ...

            if (input.phase == TouchPhase.Canceled)
            {
                pointerData.pointerCurrentRaycast = new RaycastResult();
            }
            else
            {
                eventSystem.RaycastAll(pointerData, m_RaycastResultCache);

                var raycast = FindFirstRaycast(m_RaycastResultCache);
                pointerData.pointerCurrentRaycast = raycast;
                m_RaycastResultCache.Clear();
            }
            return pointerData;
        }
        
        ...
    }

</code></pre><ul>
<li>MouseEvent 和 TouchEvent类似，同样是调用 EventSystem.RaycastAll 方法，获取射线检测到的第一个 GameObject ，对其发送各种事件。</li>
</ul>
<pre tabindex=0><code>    public class StandaloneInputModule : PointerInputModule
    {
        ...

        protected void ProcessMouseEvent(int id)
        {
            var mouseData = GetMousePointerEventData(id);
            var leftButtonData = mouseData.GetButtonState(PointerEventData.InputButton.Left).eventData;

            m_CurrentFocusedGameObject = leftButtonData.buttonData.pointerCurrentRaycast.gameObject;

            // Process the first mouse button fully
            ProcessMousePress(leftButtonData);
            ProcessMove(leftButtonData.buttonData);
            ProcessDrag(leftButtonData.buttonData);

            // Now process right / middle clicks
            ProcessMousePress(mouseData.GetButtonState(PointerEventData.InputButton.Right).eventData);
            ProcessDrag(mouseData.GetButtonState(PointerEventData.InputButton.Right).eventData.buttonData);
            ProcessMousePress(mouseData.GetButtonState(PointerEventData.InputButton.Middle).eventData);
            ProcessDrag(mouseData.GetButtonState(PointerEventData.InputButton.Middle).eventData.buttonData);

            if (!Mathf.Approximately(leftButtonData.buttonData.scrollDelta.sqrMagnitude, 0.0f))
            {
                var scrollHandler = ExecuteEvents.GetEventHandler&lt;IScrollHandler&gt;(leftButtonData.buttonData.pointerCurrentRaycast.gameObject);
                ExecuteEvents.ExecuteHierarchy(scrollHandler, leftButtonData.buttonData, ExecuteEvents.scrollHandler);
            }
        }

        
        ...
    }

</code></pre><pre tabindex=0><code>    public abstract class PointerInputModule : BaseInputModule
    {
        ...

        protected virtual MouseState GetMousePointerEventData(int id)
        {
            ...

            eventSystem.RaycastAll(leftData, m_RaycastResultCache);
            var raycast = FindFirstRaycast(m_RaycastResultCache);
            leftData.pointerCurrentRaycast = raycast;
            m_RaycastResultCache.Clear();

            ...

            return m_MouseState;
        }
        
        ...
    }

</code></pre><h2 id=raycast-射线检测>Raycast 射线检测</h2>
<ul>
<li>EventSystem.RaycastAll 方法，对 RaycasterManager 中 s_Raycasters 列表的激活对象，执行 BaseRaycaster.Raycast 方法，来查找指向的对象。</li>
</ul>
<pre tabindex=0><code>    public class EventSystem : UIBehaviour
    {
        ...
    
        public void RaycastAll(PointerEventData eventData, List&lt;RaycastResult&gt; raycastResults)
        {
            raycastResults.Clear();
            var modules = RaycasterManager.GetRaycasters();
            var modulesCount = modules.Count;
            for (int i = 0; i &lt; modulesCount; ++i)
            {
                var module = modules[i];
                if (module == null || !module.IsActive())
                    continue;

                module.Raycast(eventData, raycastResults);
            }

            raycastResults.Sort(s_RaycastComparer);
        }

        ...
    }
</code></pre><ul>
<li>s_Raycasters 列表的对象，是通过 RaycasterManager.AddRaycaster 方法加入的。BaseRaycaster 对象激活时，OnEnable 方法，将自身注册到 s_Raycasters 列表中，关闭时通过 OnDisable 方法将自身移除。所以 RayCaster 对象，也是以组件的形式挂载到 GameObject 上，根据不同的子类型，重写 Raycast 方法，可以实现不同的射线检测模式。</li>
</ul>
<pre tabindex=0><code>    public abstract class BaseRaycaster : UIBehaviour
    {
        ...

        public abstract void Raycast(PointerEventData eventData, List&lt;RaycastResult&gt; resultAppendList);

        ...

        protected override void OnEnable()
        {
            base.OnEnable();
            RaycasterManager.AddRaycaster(this);
        }

        protected override void OnDisable()
        {
            RaycasterManager.RemoveRaycasters(this);
            base.OnDisable();
        }
        
        ...
    }
</code></pre><h3 id=physicsraycaster>PhysicsRaycaster</h3>
<ul>
<li>PhysicRaycaster 的 Raycast 代码如下：</li>
</ul>
<pre tabindex=0><code>    public class PhysicsRaycaster : BaseRaycaster
    {
        ...

        public override void Raycast(PointerEventData eventData, List&lt;RaycastResult&gt; resultAppendList)
        {
#if PACKAGE_PHYSICS
            Ray ray = new Ray();
            int displayIndex = 0;
            float distanceToClipPlane = 0;
            if (!ComputeRayAndDistance(eventData, ref ray, ref displayIndex, ref distanceToClipPlane))
                return;

            int hitCount = 0;

            if (m_MaxRayIntersections == 0)
            {
                if (ReflectionMethodsCache.Singleton.raycast3DAll == null)
                    return;

                m_Hits = ReflectionMethodsCache.Singleton.raycast3DAll(ray, distanceToClipPlane, finalEventMask);
                hitCount = m_Hits.Length;
            }
            else
            {
                if (ReflectionMethodsCache.Singleton.getRaycastNonAlloc == null)
                    return;
                if (m_LastMaxRayIntersections != m_MaxRayIntersections)
                {
                    m_Hits = new RaycastHit[m_MaxRayIntersections];
                    m_LastMaxRayIntersections = m_MaxRayIntersections;
                }

                hitCount = ReflectionMethodsCache.Singleton.getRaycastNonAlloc(ray, m_Hits, distanceToClipPlane, finalEventMask);
            }

            if (hitCount != 0)
            {
                if (hitCount &gt; 1)
                    System.Array.Sort(m_Hits, 0, hitCount, RaycastHitComparer.instance);

                for (int b = 0, bmax = hitCount; b &lt; bmax; ++b)
                {
                    var result = new RaycastResult
                    {
                        gameObject = m_Hits[b].collider.gameObject,
                        module = this,
                        distance = m_Hits[b].distance,
                        worldPosition = m_Hits[b].point,
                        worldNormal = m_Hits[b].normal,
                        screenPosition = eventData.position,
                        displayIndex = displayIndex,
                        index = resultAppendList.Count,
                        sortingLayer = 0,
                        sortingOrder = 0
                    };
                    resultAppendList.Add(result);
                }
            }
#endif
        }

        ...
    }
</code></pre><ul>
<li>可以看到，PhysicsRaycaster.Raycast 主要做了：
<ul>
<li>通过反射方式，调用 Physics.RaycastAll 或 Physics.Raycast 方法，进行射线检测。</li>
<li>对检测结果进行排序。</li>
<li>将结果转成 List<raycastresult> 对象返回。</li>
</ul>
</li>
<li>射线检测是 Unity 的内部方法，通过发射射线，获取所有穿过的碰撞体对象，而排序则是通过 RaycastHitComparer.Compare 实现的。</li>
</ul>
<pre tabindex=0><code>    public class PhysicsRaycaster : BaseRaycaster
    {
        ...

#if PACKAGE_PHYSICS
        private class RaycastHitComparer : IComparer&lt;RaycastHit&gt;
        {
            public static RaycastHitComparer instance = new RaycastHitComparer();
            public int Compare(RaycastHit x, RaycastHit y)
            {
                return x.distance.CompareTo(y.distance);
            }
        }
#endif

    }
</code></pre><ul>
<li>RaycastHitComparer 只考虑远近距离，即通过比较射线接触的物体的距离，从近到远进行排序。</li>
</ul>
<h3 id=physics2draycaster>Physics2DRaycaster</h3>
<ul>
<li>Physics2DRaycaster 的 Raycast 代码如下：</li>
</ul>
<pre tabindex=0><code>    public class Physics2DRaycaster : PhysicsRaycaster
    {
        ...

        public override void Raycast(PointerEventData eventData, List&lt;RaycastResult&gt; resultAppendList)
        {
#if PACKAGE_PHYSICS2D
            Ray ray = new Ray();
            float distanceToClipPlane = 0;
            int displayIndex = 0;
            if (!ComputeRayAndDistance(eventData, ref ray, ref displayIndex, ref distanceToClipPlane))
                return;

            int hitCount = 0;

            if (maxRayIntersections == 0)
            {
                if (ReflectionMethodsCache.Singleton.getRayIntersectionAll == null)
                    return;
                m_Hits = ReflectionMethodsCache.Singleton.getRayIntersectionAll(ray, distanceToClipPlane, finalEventMask);
                hitCount = m_Hits.Length;
            }
            else
            {
                if (ReflectionMethodsCache.Singleton.getRayIntersectionAllNonAlloc == null)
                    return;

                if (m_LastMaxRayIntersections != m_MaxRayIntersections)
                {
                    m_Hits = new RaycastHit2D[maxRayIntersections];
                    m_LastMaxRayIntersections = m_MaxRayIntersections;
                }

                hitCount = ReflectionMethodsCache.Singleton.getRayIntersectionAllNonAlloc(ray, m_Hits, distanceToClipPlane, finalEventMask);
            }

            if (hitCount != 0)
            {
                for (int b = 0, bmax = hitCount; b &lt; bmax; ++b)
                {
                    Renderer r2d = null;
                    // Case 1198442: Check for 2D renderers when filling in RaycastResults
                    var rendererResult = m_Hits[b].collider.gameObject.GetComponent&lt;Renderer&gt;();
                    if (rendererResult != null)
                    {
                        if (rendererResult is SpriteRenderer)
                        {
                            r2d = rendererResult;
                        }
#if PACKAGE_TILEMAP
                        if (rendererResult is TilemapRenderer)
                        {
                            r2d = rendererResult;
                        }
#endif
                        if (rendererResult is SpriteShapeRenderer)
                        {
                            r2d = rendererResult;
                        }
                    }

                    var result = new RaycastResult
                    {
                        gameObject = m_Hits[b].collider.gameObject,
                        module = this,
                        distance = Vector3.Distance(eventCamera.transform.position, m_Hits[b].point),
                        worldPosition = m_Hits[b].point,
                        worldNormal = m_Hits[b].normal,
                        screenPosition = eventData.position,
                        displayIndex = displayIndex,
                        index = resultAppendList.Count,
                        sortingLayer =  r2d != null ? r2d.sortingLayerID : 0,
                        sortingOrder = r2d != null ? r2d.sortingOrder : 0
                    };
                    resultAppendList.Add(result);
                }
            }
#endif
        }

        ...
    }
</code></pre><ul>
<li>Physics2DRaycaster.Raycast 和 PhysicsRaycaster.Raycast 相比，少了排序的操作，其主要做了：
<ul>
<li>通过反射调用 Physics2D.GetRayIntersectionAll 或 Physics2D.GetRayIntersectionNonAlloc 进行射线检测。</li>
<li>获取射线检测到的对象上的 Renderer（SpriteRenderer、TilemapRenderer、SpriteShapeRenderer）。</li>
<li>将结果转成 List<raycastresult> 对象返回。</li>
</ul>
</li>
</ul>
<h3 id=graphicraycaster>GraphicRaycaster</h3>
<ul>
<li>GraphicRaycaster 重写的 Raycast 方法，部分代码如下：</li>
</ul>
<pre tabindex=0><code>    public class GraphicRaycaster : BaseRaycaster
    {
        ...

         public override void Raycast(PointerEventData eventData, List&lt;RaycastResult&gt; resultAppendList)
        {
            if (canvas == null)
                return;
            // 获取 canvas 下的 graphic 对象
            var canvasGraphics = GraphicRegistry.GetRaycastableGraphicsForCanvas(canvas);
            if (canvasGraphics == null || canvasGraphics.Count == 0)
                return;

            ...

            // 获取事件坐标
            var eventPosition = Display.RelativeMouseAt(eventData.position);
           
            ...

            float hitDistance = float.MaxValue;

            Ray ray = new Ray();

            if (currentEventCamera != null)
                ray = currentEventCamera.ScreenPointToRay(eventPosition);

            ...

            m_RaycastResults.Clear();

            // 进行 Raycast 检测
            Raycast(canvas, currentEventCamera, eventPosition, canvasGraphics, m_RaycastResults);

            // 将结果转到 List&lt;RaycastResult&gt; 列表返回
            int totalCount = m_RaycastResults.Count;
            for (var index = 0; index &lt; totalCount; index++)
            {
                var go = m_RaycastResults[index].gameObject;
                bool appendGraphic = true;
                
                if (ignoreReversedGraphics)
                {
                    if (currentEventCamera == null)
                    {
                        // If we dont have a camera we know that we should always be facing forward
                        var dir = go.transform.rotation * Vector3.forward;
                        appendGraphic = Vector3.Dot(Vector3.forward, dir) &gt; 0;
                    }
                    else
                    {
                        // If we have a camera compare the direction against the cameras forward.
                        var cameraForward = currentEventCamera.transform.rotation * Vector3.forward * currentEventCamera.nearClipPlane;
                        appendGraphic = Vector3.Dot(go.transform.position - currentEventCamera.transform.position - cameraForward, go.transform.forward) &gt;= 0;
                    }
                }

                if (appendGraphic)
                {
                    float distance = 0;
                    Transform trans = go.transform;
                    Vector3 transForward = trans.forward;

                    if (currentEventCamera == null || canvas.renderMode == RenderMode.ScreenSpaceOverlay)
                        distance = 0;
                    else
                    {
                        // http://geomalgorithms.com/a06-_intersect-2.html
                        distance = (Vector3.Dot(transForward, trans.position - ray.origin) / Vector3.Dot(transForward, ray.direction));

                        // Check to see if the go is behind the camera.
                        if (distance &lt; 0)
                            continue;
                    }

                    if (distance &gt;= hitDistance)
                        continue;

                    var castResult = new RaycastResult
                    {
                        gameObject = go,
                        module = this,
                        distance = distance,
                        screenPosition = eventPosition,
                        displayIndex = displayIndex,
                        index = resultAppendList.Count,
                        depth = m_RaycastResults[index].depth,
                        sortingLayer = canvas.sortingLayerID,
                        sortingOrder = canvas.sortingOrder,
                        worldPosition = ray.origin + ray.direction * distance,
                        worldNormal = -transForward
                    };
                    resultAppendList.Add(castResult);
                }
            }
        }

        ...
    }

</code></pre><ul>
<li>从流程上看，GraphicRaycaster 重写的 Raycast 方法，创建射线后，并没有直接使用射线检测，而是通过调用内部的 Raycast 方法进行检测，再将结果返回。</li>
</ul>
<pre tabindex=0><code>    public class GraphicRaycaster : BaseRaycaster
    {
        ...

        [NonSerialized] static readonly List&lt;Graphic&gt; s_SortedGraphics = new List&lt;Graphic&gt;();
        private static void Raycast(Canvas canvas, Camera eventCamera, Vector2 pointerPosition, IList&lt;Graphic&gt; foundGraphics, List&lt;Graphic&gt; results)
        {
            // Necessary for the event system
            int totalCount = foundGraphics.Count;
            for (int i = 0; i &lt; totalCount; ++i)
            {
                Graphic graphic = foundGraphics[i];

                // -1 means it hasn't been processed by the canvas, which means it isn't actually drawn
                if (!graphic.raycastTarget || graphic.canvasRenderer.cull || graphic.depth == -1)
                    continue;

                if (!RectTransformUtility.RectangleContainsScreenPoint(graphic.rectTransform, pointerPosition, eventCamera, graphic.raycastPadding))
                    continue;

                if (eventCamera != null &amp;&amp; eventCamera.WorldToScreenPoint(graphic.rectTransform.position).z &gt; eventCamera.farClipPlane)
                    continue;

                if (graphic.Raycast(pointerPosition, eventCamera))
                {
                    s_SortedGraphics.Add(graphic);
                }
            }

            s_SortedGraphics.Sort((g1, g2) =&gt; g2.depth.CompareTo(g1.depth));
            totalCount = s_SortedGraphics.Count;
            for (int i = 0; i &lt; totalCount; ++i)
                results.Add(s_SortedGraphics[i]);

            s_SortedGraphics.Clear();
        }

    }
</code></pre><ul>
<li>GraphicRaycaster 内部的 Raycast 方法，主要步骤：
<ul>
<li>剔除不需要进行检测的情况（如 raycastTarget 关闭，响应点坐标不在 rectTransform 范围内、超过远裁剪平面等）。</li>
<li>调用 Graphic.Raycast 方法，判断当前 graphic 是否符合响应坐标，符合则加入 s_SortedGraphics 列表。</li>
<li>对 s_SortedGraphics 列表的对象，根据深度从大到小排序。</li>
<li>将 s_SortedGraphics 对象转到 results 中并返回。</li>
</ul>
</li>
<li>Graphic.Raycast 方法的代码如下：</li>
</ul>
<pre tabindex=0><code>    public abstract class Graphic : UIBehaviour, ICanvasElement
    {
        ...

        public virtual bool Raycast(Vector2 sp, Camera eventCamera)
        {
            if (!isActiveAndEnabled)
                return false;

            var t = transform;
            var components = ListPool&lt;Component&gt;.Get();

            bool ignoreParentGroups = false;
            bool continueTraversal = true;

            while (t != null)
            {
                t.GetComponents(components);
                for (var i = 0; i &lt; components.Count; i++)
                {
                    var canvas = components[i] as Canvas;
                    if (canvas != null &amp;&amp; canvas.overrideSorting)
                        continueTraversal = false;

                    var filter = components[i] as ICanvasRaycastFilter;

                    if (filter == null)
                        continue;

                    var raycastValid = true;

                    var group = components[i] as CanvasGroup;
                    if (group != null)
                    {
                        if (ignoreParentGroups == false &amp;&amp; group.ignoreParentGroups)
                        {
                            ignoreParentGroups = true;
                            raycastValid = filter.IsRaycastLocationValid(sp, eventCamera);
                        }
                        else if (!ignoreParentGroups)
                            raycastValid = filter.IsRaycastLocationValid(sp, eventCamera);
                    }
                    else
                    {
                        raycastValid = filter.IsRaycastLocationValid(sp, eventCamera);
                    }

                    if (!raycastValid)
                    {
                        ListPool&lt;Component&gt;.Release(components);
                        return false;
                    }
                }
                t = continueTraversal ? t.parent : null;
            }
            ListPool&lt;Component&gt;.Release(components);
            return true;
        }

        ...
    }
</code></pre><ul>
<li>Graphic.Raycast 方法的流程为：
<ul>
<li>获取自身所有 Graphic 组件。</li>
<li>对每一个继承 ICanvasRaycastFilter 接口的 Graphic 组件，执行 ICanvasRaycastFilter.IsRaycastLocationValid 方法，检测响应点是否对此组件有效，如果无效则直接返回。</li>
<li>逐级向上，直到 Canvas 设置了 overrideSorting ，或者直到根节点，返回有效。</li>
</ul>
</li>
<li>GraphicRaycaster 内部的 Raycast 方法主要通过 RectTransform 的 Rect 来过滤组件，而 Graphic 的 Raycast 主要是用来确认该组件是否被射线检测命中。</li>
</ul>
<h2 id=executeevents-执行事件>ExecuteEvents 执行事件</h2>
<ul>
<li>射线检测模块完成后，得到了 RaycastResult 数据，接下来就要执行相关的事件。继续看 StandaloneInputModule.ProcessTouchPress 方法，部分代码如下：</li>
</ul>
<pre tabindex=0><code>    public class StandaloneInputModule : PointerInputModule
    {
        ...

        protected void ProcessTouchPress(PointerEventData pointerEvent, bool pressed, bool released)
        {
            var currentOverGo = pointerEvent.pointerCurrentRaycast.gameObject;

            // PointerDown notification
            if (pressed)
            {
                ...

                var newClick = ExecuteEvents.GetEventHandler&lt;IPointerClickHandler&gt;(currentOverGo);

                ...

                pointerEvent.pointerClick = newClick;

                ...
            }

            // PointerUp notification
            if (released)
            {
                ...

                // see if we mouse up on the same element that we clicked on...
                var pointerClickHandler = ExecuteEvents.GetEventHandler&lt;IPointerClickHandler&gt;(currentOverGo);

                // PointerClick and Drop events
                if (pointerEvent.pointerClick == pointerClickHandler &amp;&amp; pointerEvent.eligibleForClick)
                {
                    ExecuteEvents.Execute(pointerEvent.pointerClick, pointerEvent, ExecuteEvents.pointerClickHandler);
                }

                ...

                pointerEvent.pointerClick = null;

                ...
            }

            m_InputPointerEvent = pointerEvent;
        }
        
        ...
    }

</code></pre><ul>
<li>这里以点击事件为例，射线检测完成后，得到了目标 gameObject ，当按下时，通过调用 ExecuteEvents.GetEventHandler<ipointerclickhandler> 方法获取点击事件响应的最终 gameObject。当释放时，如果还是同一个 gameObject，则执行 ExecuteEvents.Execute 方法执行点击事件。</li>
</ul>
<pre tabindex=0><code>    public static class ExecuteEvents
    {
        ...

        private static bool ShouldSendToComponent&lt;T&gt;(Component component) where T : IEventSystemHandler
        {
            var valid = component is T;
            if (!valid)
                return false;

            var behaviour = component as Behaviour;
            if (behaviour != null)
                return behaviour.isActiveAndEnabled;
            return true;
        }

        /// &lt;summary&gt;
        /// Get the specified object's event event.
        /// &lt;/summary&gt;
        private static void GetEventList&lt;T&gt;(GameObject go, IList&lt;IEventSystemHandler&gt; results) where T : IEventSystemHandler
        {
            // Debug.LogWarning(&quot;GetEventList&lt;&quot; + typeof(T).Name + &quot;&gt;&quot;);
            if (results == null)
                throw new ArgumentException(&quot;Results array is null&quot;, &quot;results&quot;);

            if (go == null || !go.activeInHierarchy)
                return;

            var components = ListPool&lt;Component&gt;.Get();
            go.GetComponents(components);

            var componentsCount = components.Count;
            for (var i = 0; i &lt; componentsCount; i++)
            {
                if (!ShouldSendToComponent&lt;T&gt;(components[i]))
                    continue;

                // Debug.Log(string.Format(&quot;{2} found! On {0}.{1}&quot;, go, s_GetComponentsScratch[i].GetType(), typeof(T)));
                results.Add(components[i] as IEventSystemHandler);
            }
            ListPool&lt;Component&gt;.Release(components);
            // Debug.LogWarning(&quot;end GetEventList&lt;&quot; + typeof(T).Name + &quot;&gt;&quot;);
        }

        /// &lt;summary&gt;
        /// Whether the specified game object will be able to handle the specified event.
        /// &lt;/summary&gt;
        public static bool CanHandleEvent&lt;T&gt;(GameObject go) where T : IEventSystemHandler
        {
            var internalHandlers = s_HandlerListPool.Get();
            GetEventList&lt;T&gt;(go, internalHandlers);
            var handlerCount = internalHandlers.Count;
            s_HandlerListPool.Release(internalHandlers);
            return handlerCount != 0;
        }

        /// &lt;summary&gt;
        /// Bubble the specified event on the game object, figuring out which object will actually receive the event.
        /// &lt;/summary&gt;
        public static GameObject GetEventHandler&lt;T&gt;(GameObject root) where T : IEventSystemHandler
        {
            if (root == null)
                return null;

            Transform t = root.transform;
            while (t != null)
            {
                if (CanHandleEvent&lt;T&gt;(t.gameObject))
                    return t.gameObject;
                t = t.parent;
            }
            return null;
        }
    }
</code></pre><ul>
<li>可以看到，对于点击事件 IPointerClickHandler，对射线检测得到的对象，会获取其挂载的 IPointerClickHandler 类型的激活状态的组件，找到了则返回 gameObject 。如果找不到，则从父节点中继续查找。</li>
</ul>
<pre tabindex=0><code>    public static class ExecuteEvents
    {
        ...

        public static bool Execute&lt;T&gt;(GameObject target, BaseEventData eventData, EventFunction&lt;T&gt; functor) where T : IEventSystemHandler
        {
            var internalHandlers = s_HandlerListPool.Get();
            GetEventList&lt;T&gt;(target, internalHandlers);
            //  if (s_InternalHandlers.Count &gt; 0)
            //      Debug.Log(&quot;Executinng &quot; + typeof (T) + &quot; on &quot; + target);

            var internalHandlersCount = internalHandlers.Count;
            for (var i = 0; i &lt; internalHandlersCount; i++)
            {
                T arg;
                try
                {
                    arg = (T)internalHandlers[i];
                }
                catch (Exception e)
                {
                    var temp = internalHandlers[i];
                    Debug.LogException(new Exception(string.Format(&quot;Type {0} expected {1} received.&quot;, typeof(T).Name, temp.GetType().Name), e));
                    continue;
                }

                try
                {
                    functor(arg, eventData);
                }
                catch (Exception e)
                {
                    Debug.LogException(e);
                }
            }

            var handlerCount = internalHandlers.Count;
            s_HandlerListPool.Release(internalHandlers);
            return handlerCount &gt; 0;
        }

        ...
    }
</code></pre><ul>
<li>ExecuteEvents.Execute<t> 方法，则根据对应的事件类型，如：点击事件 IPointerClickHandler，通过调用 GetEventList<t> 获取类型为 IPointerClickHandler 的组件，并对所有执行 IPointerClickHandler.OnPointerClick(PointerEventData eventData) 方法，其他事件类型同理，可在 ExecuteEvents 中找到对应实现。</li>
</ul>
<h2 id=总结>总结</h2>
<ul>
<li>通过了解 Unity 的事件系统的运作流程，可以对其有更加清晰的认识，也能更好地使用。</li>
<li>对于特殊的需求，也可以通过重写不同模块的方法来自定义，如：
<ul>
<li>重写 InputModule 的 Process 方法， 自定义输入系统处理流程。</li>
<li>重写 InputModule 的 GetTouchPointerEventData 方法，自定义触碰事件数据生成方法。</li>
<li>重写 Raycast 的 Raycast 方法，自定义射线检测处理规则。</li>
<li>&mldr;</li>
</ul>
</li>
</ul>
<hr>
<ul class=pager>
<li class=previous>
<a href=/post/unity/customizedvariant/customizedvariant/ data-toggle=tooltip data-placement=top title="Unity篇 — 定制化变体">&larr;
Previous Post</a>
</li>
<li class=next>
<a href=/post/unity/optimization/drawcalloptimization/ data-toggle=tooltip data-placement=top title="Unity篇 — Draw Call">Next
Post &rarr;</a>
</li>
</ul>
<div id=disqus-comment></div>
</div>
<div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container">
<div class=side-catalog>
<hr class="hidden-sm hidden-xs">
<h5>
<a class=catalog-toggle href=#>CATALOG</a>
</h5>
<ul class=catalog-body></ul>
</div>
</div>
<div class="col-lg-11 col-lg-offset-1
col-md-10 col-md-offset-1
sidebar-container">
</div>
</div>
</div>
</article>
<footer>
<div class=container>
<div class=row>
<div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
<ul class="list-inline text-center">
</ul>
<p class="copyright text-muted">
Copyright &copy; Xun's Blog 2024
<br>
<a href=https://themes.gohugo.io/hugo-theme-cleanwhite>CleanWhite Hugo Theme</a> by <a href=https://zhaohuabing.com>Huabing</a> |
<iframe style=margin-left:2px;margin-bottom:-5px frameborder=0 scrolling=0 width=100px height=20px src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true"></iframe>
</p>
</div>
</div>
</div>
</footer>
<script>function loadAsync(f,b){var c=document,d='script',a=c.createElement(d),e=c.getElementsByTagName(d)[0];a.src=f,b&&a.addEventListener('load',function(a){b(null,a)},!1),e.parentNode.insertBefore(a,e)}</script>
<script>$('#tag_cloud').length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:'#bbbbee',end:'#0085a1'}},$('#tag_cloud a').tagcloud()})</script>
<script>loadAsync("https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.js",function(){var a=document.querySelector("nav");a&&FastClick.attach(a)})</script>
<script type=text/javascript>function generateCatalog(a){_containerSelector='div.post-container';var h=$(_containerSelector),c,d,e,f,g,b;return c=h.find('h1,h2,h3,h4,h5,h6'),$(a).html(''),c.each(function(){d=$(this).prop('tagName').toLowerCase(),g="#"+$(this).prop('id'),e=$(this).text(),b=$('<a href="'+g+'" rel="nofollow">'+e+'</a>'),f=$('<li class="'+d+'_nav"></li>').append(b),$(a).append(f)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(a){a.preventDefault(),$('.side-catalog').toggleClass("fold")}),loadAsync("/js/jquery.nav.js",function(){$('.catalog-body').onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script>
</body>
</html>
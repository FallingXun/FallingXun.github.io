<!doctype html><html lang=zh-cn>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta property="og:site_name" content="Xun's Blog">
<meta property="og:type" content="article">
<meta property="og:image" content="https://fallingxun.github.io//">
<meta property="twitter:image" content="https://fallingxun.github.io//">
<meta name=title content="Unity篇 — 事件系统">
<meta property="og:title" content="Unity篇 — 事件系统">
<meta property="twitter:title" content="Unity篇 — 事件系统">
<meta name=description content>
<meta property="og:description" content>
<meta property="twitter:description" content>
<meta property="twitter:card" content="summary">
<meta name=keyword content>
<link rel="shortcut icon" href=/img/favicon.ico>
<title>Unity篇 — 事件系统-</title>
<link rel=canonical href=/post/unity/ugui/eventsystem/>
<link rel=stylesheet href=/css/iDisqus.min.css>
<link rel=stylesheet href=/css/bootstrap.min.css>
<link rel=stylesheet href=/css/hugo-theme-cleanwhite.min.css>
<link rel=stylesheet href=/css/zanshang.css>
<link href=//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css rel=stylesheet type=text/css>
<script src=/js/jquery.min.js></script>
<script src=/js/bootstrap.min.js></script>
<script src=/js/hux-blog.min.js></script>
</head>
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
<div class=container-fluid>
<div class="navbar-header page-scroll">
<button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=/>Xun's Blog</a>
</div>
<div id=huxblog_navbar>
<div class=navbar-collapse>
<ul class="nav navbar-nav navbar-right">
<li>
<a href=/>Home</a>
</li>
<li>
<a href=/categories/googleplay%E7%B3%BB%E5%88%97>googleplay系列</a>
</li>
<li>
<a href=/categories/lua%E7%B3%BB%E5%88%97>lua系列</a>
</li>
<li>
<a href=/categories/tmp%E7%B3%BB%E5%88%97>tmp系列</a>
</li>
<li>
<a href=/categories/unity%E7%B3%BB%E5%88%97>unity系列</a>
</li>
<li>
<a href=/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%B3%BB%E5%88%97>图形学系列</a>
</li>
<li>
<a href=/categories/%E6%B8%B2%E6%9F%93%E7%B3%BB%E5%88%97>渲染系列</a>
</li>
<li>
<a href=/categories/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97>算法系列</a>
</li>
</ul>
</div>
</div>
</div>
</nav>
<script>var $body=document.body,$toggle=document.querySelector('.navbar-toggle'),$navbar=document.querySelector('#huxblog_navbar'),$collapse=document.querySelector('.navbar-collapse');$toggle.addEventListener('click',handleMagic);function handleMagic(a){$navbar.className.indexOf('in')>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf('in')<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script>
<style type=text/css>header.intro-header{background-image:url('/')}</style>
<header class=intro-header>
<div class=container>
<div class=row>
<div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
<div class=post-heading>
<div class=tags>
<a class=tag href=/tags/%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F title=事件系统>
事件系统
</a>
<a class=tag href=/tags/%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6 title=点击事件>
点击事件
</a>
<a class=tag href=/tags/eventsystem title=EventSystem>
EventSystem
</a>
</div>
<h1>Unity篇 — 事件系统</h1>
<h2 class=subheading></h2>
<span class=meta>
Posted by
Xun
on
Sunday, January 29, 2023
</span>
</div>
</div>
</div>
</div>
</header>
<article>
<div class=container>
<div class=row>
<div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container">
<p>Unity 中各种点击、拖拽的交互响应是不可或缺的。在 UGUI 中，使用了 EventSystem 进行管理。</p>
<h2 id=简介>简介</h2>
<ul>
<li>一个简单的交互流程，主要有以下步骤：
<ul>
<li>用户点击、滑动、拖拽鼠标（或屏幕）</li>
<li>找到响应的对象</li>
<li>执行对象对应的方法</li>
</ul>
</li>
<li>因此，相对地，就需要知道
<ul>
<li>如何获取玩家的操作</li>
<li>如何找到需要响应的对象</li>
<li>如何执行对应方法</li>
</ul>
</li>
</ul>
<h2 id=eventsystem-主流程>EventSystem 主流程</h2>
<ul>
<li>EventSystem 继承 UIBehavior ，作为组件进行使用。其定义了几个对象：
<ul>
<li>m_SystemInputModules ：当前 EventSystem 的所有 InputModule 列表（List<baseinputmodule>）。</li>
<li>m_CurrentInputModule ：当前 EventSystem 使用的 InputModule 。</li>
<li>m_EventSystems ：所有 EventSystem 列表（static List<eventsystem>）。</li>
<li>current ：当前使用的 EventSystem 。</li>
</ul>
</li>
</ul>
<pre tabindex=0><code>    public class EventSystem : UIBehaviour
    {
        private List&lt;BaseInputModule&gt; m_SystemInputModules = new List&lt;BaseInputModule&gt;();

        private BaseInputModule m_CurrentInputModule;

        private  static List&lt;EventSystem&gt; m_EventSystems = new List&lt;EventSystem&gt;();

        /// &lt;summary&gt;
        /// Return the current EventSystem.
        /// &lt;/summary&gt;
        public static EventSystem current
        {
            get { return m_EventSystems.Count &gt; 0 ? m_EventSystems[0] : null; }
            set
            {
                int index = m_EventSystems.IndexOf(value);

                if (index &gt; 0)
                {
                    m_EventSystems.RemoveAt(index);
                    m_EventSystems.Insert(0, value);
                }
                else if (index &lt; 0)
                {
                    Debug.LogError(&quot;Failed setting EventSystem.current to unknown EventSystem &quot; + value);
                }
            }
        }

        
        ...
    
    }
</code></pre><ul>
<li>当 EveneSystem 激活时，则会加入 m_EventSystems 列表中。同样，当 EveneSystem 关闭时，则会从 m_EventSystems 列表中移除自身， 并且清除掉当前的输入模块信息 m_CurrentInputModule 。</li>
</ul>
<pre tabindex=0><code>    public class EventSystem : UIBehaviour
    {
        ...
    
        protected override void OnEnable()
        {
            base.OnEnable();
            m_EventSystems.Add(this);
        }

        protected override void OnDisable()
        {
            if (m_CurrentInputModule != null)
            {
                m_CurrentInputModule.DeactivateModule();
                m_CurrentInputModule = null;
            }

            m_EventSystems.Remove(this);

            base.OnDisable();
        }

        ...
    }
</code></pre><ul>
<li>当 EventSystem 处于激活状态时，由于继承 UIBehavior ，每帧会执行 Update 方法进行更新，主要内容为：
<ul>
<li>对 m_SystemInputModules 列表中的所有 InputModule 执行 UpdateModule 方法。</li>
<li>如果当前输入模块 m_CurrentInputModule 为空，或者不为 m_SystemInputModules 列表中首个符合条件的模块，则进行切换。</li>
<li>如果此帧没有进行模块切换，则对当前输入模块 m_CurrentInputModule 执行 Process 方法进行处理。</li>
</ul>
</li>
</ul>
<pre tabindex=0><code>    public class EventSystem : UIBehaviour
    {
        ...
    
        protected virtual void Update()
        {
            if (current != this)
                return;
            // 对 m_SystemInputModules 列表中的所有 InputModule 执行 UpdateModule 方法。
            TickModules();

            //如果当前输入模块 m_CurrentInputModule 为空，或者不为 m_SystemInputModules 列表中首个符合条件的模块，则进行切换。
            bool changedModule = false;
            var systemInputModulesCount = m_SystemInputModules.Count;
            for (var i = 0; i &lt; systemInputModulesCount; i++)
            {
                var module = m_SystemInputModules[i];
                if (module.IsModuleSupported() &amp;&amp; module.ShouldActivateModule())
                {
                    if (m_CurrentInputModule != module)
                    {
                        ChangeEventModule(module);
                        changedModule = true;
                    }
                    break;
                }
            }

            // no event module set... set the first valid one...
            if (m_CurrentInputModule == null)
            {
                for (var i = 0; i &lt; systemInputModulesCount; i++)
                {
                    var module = m_SystemInputModules[i];
                    if (module.IsModuleSupported())
                    {
                        ChangeEventModule(module);
                        changedModule = true;
                        break;
                    }
                }
            }

            // 如果此帧没有进行模块切换，则对当前输入模块 m_CurrentInputModule 执行 Process 方法进行处理。 
            if (!changedModule &amp;&amp; m_CurrentInputModule != null)
                m_CurrentInputModule.Process();

            ...
        }

        ...
    }
</code></pre><ul>
<li>m_SystemInputModules 列表是在 EventSystem.UpdateModules 方法中生成的，即 EventSystem 所属 GameObject 上所有激活的 BaseInputModule 对象。</li>
</ul>
<pre tabindex=0><code>    public class EventSystem : UIBehaviour
    {
        ...
    
        public void UpdateModules()
        {
            GetComponents(m_SystemInputModules);
            var systemInputModulesCount = m_SystemInputModules.Count;
            for (int i = systemInputModulesCount - 1; i &gt;= 0; i--)
            {
                if (m_SystemInputModules[i] &amp;&amp; m_SystemInputModules[i].IsActive())
                    continue;

                m_SystemInputModules.RemoveAt(i);
            }
        }

        ...
    }
</code></pre><ul>
<li>因此，GameObject 上会挂载 EventSystem 组件，同时会挂载其需要的所有 InputModule 组件。</li>
</ul>
<h2 id=inputmodule-输入模块>InputModule 输入模块</h2>
<ul>
<li>从 EventSystem 中知道，InputModule 组件需要挂载到同一个 GameObject 上，并且只有激活的才会加入到 EventSystem.m_SystemInputModules 列表中。</li>
<li>可以看到，BaseInputModule 中，当对象激活时，会获取组件上的 EventSystem，并且调用 EventSystem.UpdateModules 方法，从而实现将自身加入到 EventSystem.m_SystemInputModules 列表中。同样，当对象关闭时，会再次刷新 EventSystem.m_SystemInputModules 列表，将自身移除。</li>
</ul>
<pre tabindex=0><code>    public abstract class BaseInputModule : UIBehaviour
    {
        ...

        protected EventSystem eventSystem
        {
            get { return m_EventSystem; }
        }

        protected override void OnEnable()
        {
            base.OnEnable();
            m_EventSystem = GetComponent&lt;EventSystem&gt;();
            m_EventSystem.UpdateModules();
        }

        protected override void OnDisable()
        {
            m_EventSystem.UpdateModules();
            base.OnDisable();
        }
        
        ...
    }

</code></pre><ul>
<li>EventSystem 更新时，会先触发 BaseInputModule.UpdateModule 方法，默认情况下，会使用 StandaloneInputModule 组件。其中 UpdateModule 方法，主要记录上一帧和当前帧的输入坐标。另外，如果当前没有聚焦，并且处于拖拽状态，则会释放按压状态，结束拖拽。</li>
</ul>
<pre tabindex=0><code>    public class StandaloneInputModule : PointerInputModule
    {
        ...

        public override void UpdateModule()
        {
            if (!eventSystem.isFocused &amp;&amp; ShouldIgnoreEventsOnNoFocus())
            {
                if (m_InputPointerEvent != null &amp;&amp; m_InputPointerEvent.pointerDrag != null &amp;&amp; m_InputPointerEvent.dragging)
                {
                    ReleaseMouse(m_InputPointerEvent, m_InputPointerEvent.pointerCurrentRaycast.gameObject);
                }

                m_InputPointerEvent = null;

                return;
            }

            m_LastMousePosition = m_MousePosition;
            m_MousePosition = input.mousePosition;
        }
        
        ...
    }

</code></pre><ul>
<li>EventSystem 还会对当前输入模块 m_CurrentInputModule 执行 Process 方法，主要进行：
<ul>
<li>对当前选中的 GameObject ，发送更新事件（UpdateEvent）。</li>
<li>处理触碰事件（TouchEvent）。</li>
<li>如果没有触碰事件，则处理鼠标输入事件（MouseEvent）。</li>
<li>对当前选中的 GameObject，发送移动事件（MoveEvent）。</li>
<li>&mldr;</li>
</ul>
</li>
</ul>
<pre tabindex=0><code>    public class StandaloneInputModule : PointerInputModule
    {
        ...

        public override void Process()
        {
            if (!eventSystem.isFocused &amp;&amp; ShouldIgnoreEventsOnNoFocus())
                return;

            bool usedEvent = SendUpdateEventToSelectedObject();

            // case 1004066 - touch / mouse events should be processed before navigation events in case
            // they change the current selected gameobject and the submit button is a touch / mouse button.

            // touch needs to take precedence because of the mouse emulation layer
            if (!ProcessTouchEvents() &amp;&amp; input.mousePresent)
                ProcessMouseEvent();

            if (eventSystem.sendNavigationEvents)
            {
                if (!usedEvent)
                    usedEvent |= SendMoveEventToSelectedObject();

                if (!usedEvent)
                    SendSubmitEventToSelectedObject();
            }
        }
        
        ...
    }

</code></pre><ul>
<li>其中，主要关注的是 TouchEvent 和 MouseEvent。TouchEvent 的主要流程为：
<ul>
<li>调用 EventSystem.RaycastAll 方法，获取射线检测到的第一个 GameObject 。</li>
<li>根据当前的按压（pressed）状态、释放（released）状态，发送不同的事件（PointerDown、PointerClick、Drag 等）。</li>
<li>如果当前没有释放，则进行移动和拖拽处理。</li>
</ul>
</li>
</ul>
<pre tabindex=0><code>    public class StandaloneInputModule : PointerInputModule
    {
        ...

        private bool ProcessTouchEvents()
        {
            for (int i = 0; i &lt; input.touchCount; ++i)
            {
                Touch touch = input.GetTouch(i);

                if (touch.type == TouchType.Indirect)
                    continue;

                bool released;
                bool pressed;
                var pointer = GetTouchPointerEventData(touch, out pressed, out released);

                ProcessTouchPress(pointer, pressed, released);

                if (!released)
                {
                    ProcessMove(pointer);
                    ProcessDrag(pointer);
                }
                else
                    RemovePointerData(pointer);
            }
            return input.touchCount &gt; 0;
        }
        
        ...
    }

</code></pre><pre tabindex=0><code>    public abstract class PointerInputModule : BaseInputModule
    {
        ...

        protected PointerEventData GetTouchPointerEventData(Touch input, out bool pressed, out bool released)
        {

            ...

            if (input.phase == TouchPhase.Canceled)
            {
                pointerData.pointerCurrentRaycast = new RaycastResult();
            }
            else
            {
                eventSystem.RaycastAll(pointerData, m_RaycastResultCache);

                var raycast = FindFirstRaycast(m_RaycastResultCache);
                pointerData.pointerCurrentRaycast = raycast;
                m_RaycastResultCache.Clear();
            }
            return pointerData;
        }
        
        ...
    }

</code></pre><ul>
<li>MouseEvent 和 TouchEvent类似，同样是调用 EventSystem.RaycastAll 方法，获取射线检测到的第一个 GameObject ，对其发送各种事件。</li>
</ul>
<pre tabindex=0><code>    public class StandaloneInputModule : PointerInputModule
    {
        ...

        protected void ProcessMouseEvent(int id)
        {
            var mouseData = GetMousePointerEventData(id);
            var leftButtonData = mouseData.GetButtonState(PointerEventData.InputButton.Left).eventData;

            m_CurrentFocusedGameObject = leftButtonData.buttonData.pointerCurrentRaycast.gameObject;

            // Process the first mouse button fully
            ProcessMousePress(leftButtonData);
            ProcessMove(leftButtonData.buttonData);
            ProcessDrag(leftButtonData.buttonData);

            // Now process right / middle clicks
            ProcessMousePress(mouseData.GetButtonState(PointerEventData.InputButton.Right).eventData);
            ProcessDrag(mouseData.GetButtonState(PointerEventData.InputButton.Right).eventData.buttonData);
            ProcessMousePress(mouseData.GetButtonState(PointerEventData.InputButton.Middle).eventData);
            ProcessDrag(mouseData.GetButtonState(PointerEventData.InputButton.Middle).eventData.buttonData);

            if (!Mathf.Approximately(leftButtonData.buttonData.scrollDelta.sqrMagnitude, 0.0f))
            {
                var scrollHandler = ExecuteEvents.GetEventHandler&lt;IScrollHandler&gt;(leftButtonData.buttonData.pointerCurrentRaycast.gameObject);
                ExecuteEvents.ExecuteHierarchy(scrollHandler, leftButtonData.buttonData, ExecuteEvents.scrollHandler);
            }
        }

        
        ...
    }

</code></pre><pre tabindex=0><code>    public abstract class PointerInputModule : BaseInputModule
    {
        ...

        protected virtual MouseState GetMousePointerEventData(int id)
        {
            ...

            eventSystem.RaycastAll(leftData, m_RaycastResultCache);
            var raycast = FindFirstRaycast(m_RaycastResultCache);
            leftData.pointerCurrentRaycast = raycast;
            m_RaycastResultCache.Clear();

            ...

            return m_MouseState;
        }
        
        ...
    }

</code></pre><h2 id=raycast-射线检测>Raycast 射线检测</h2>
<ul>
<li>EventSystem.RaycastAll 方法，对 RaycasterManager 中 s_Raycasters 列表的激活对象，执行 BaseRaycaster.Raycast 方法，来查找指向的对象。</li>
</ul>
<pre tabindex=0><code>    public class EventSystem : UIBehaviour
    {
        ...
    
        public void RaycastAll(PointerEventData eventData, List&lt;RaycastResult&gt; raycastResults)
        {
            raycastResults.Clear();
            var modules = RaycasterManager.GetRaycasters();
            var modulesCount = modules.Count;
            for (int i = 0; i &lt; modulesCount; ++i)
            {
                var module = modules[i];
                if (module == null || !module.IsActive())
                    continue;

                module.Raycast(eventData, raycastResults);
            }

            raycastResults.Sort(s_RaycastComparer);
        }

        ...
    }
</code></pre>
<hr>
<ul class=pager>
<li class=previous>
<a href=/post/unity/customizedvariant/customizedvariant/ data-toggle=tooltip data-placement=top title="Unity篇 — 定制化变体">&larr;
Previous Post</a>
</li>
</ul>
<div id=disqus-comment></div>
</div>
<div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container">
<div class=side-catalog>
<hr class="hidden-sm hidden-xs">
<h5>
<a class=catalog-toggle href=#>CATALOG</a>
</h5>
<ul class=catalog-body></ul>
</div>
</div>
<div class="col-lg-11 col-lg-offset-1
col-md-10 col-md-offset-1
sidebar-container">
</div>
</div>
</div>
</article>
<footer>
<div class=container>
<div class=row>
<div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
<ul class="list-inline text-center">
</ul>
<p class="copyright text-muted">
Copyright &copy; Xun's Blog 2023
<br>
<a href=https://themes.gohugo.io/hugo-theme-cleanwhite>CleanWhite Hugo Theme</a> by <a href=https://zhaohuabing.com>Huabing</a> |
<iframe style=margin-left:2px;margin-bottom:-5px frameborder=0 scrolling=0 width=100px height=20px src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true"></iframe>
</p>
</div>
</div>
</div>
</footer>
<script>function loadAsync(f,b){var c=document,d='script',a=c.createElement(d),e=c.getElementsByTagName(d)[0];a.src=f,b&&a.addEventListener('load',function(a){b(null,a)},!1),e.parentNode.insertBefore(a,e)}</script>
<script>$('#tag_cloud').length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:'#bbbbee',end:'#0085a1'}},$('#tag_cloud a').tagcloud()})</script>
<script>loadAsync("https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.js",function(){var a=document.querySelector("nav");a&&FastClick.attach(a)})</script>
<script type=text/javascript>function generateCatalog(a){_containerSelector='div.post-container';var h=$(_containerSelector),c,d,e,f,g,b;return c=h.find('h1,h2,h3,h4,h5,h6'),$(a).html(''),c.each(function(){d=$(this).prop('tagName').toLowerCase(),g="#"+$(this).prop('id'),e=$(this).text(),b=$('<a href="'+g+'" rel="nofollow">'+e+'</a>'),f=$('<li class="'+d+'_nav"></li>').append(b),$(a).append(f)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(a){a.preventDefault(),$('.side-catalog').toggleClass("fold")}),loadAsync("/js/jquery.nav.js",function(){$('.catalog-body').onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script>
</body>
</html>
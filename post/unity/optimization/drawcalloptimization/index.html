<!doctype html><html lang=zh-cn>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta property="og:site_name" content="Xun's Blog">
<meta property="og:type" content="article">
<meta property="og:image" content="https://fallingxun.github.io//">
<meta property="twitter:image" content="https://fallingxun.github.io//">
<meta name=title content="Unity篇 — Draw Call">
<meta property="og:title" content="Unity篇 — Draw Call">
<meta property="twitter:title" content="Unity篇 — Draw Call">
<meta name=description content>
<meta property="og:description" content>
<meta property="twitter:description" content>
<meta property="twitter:card" content="summary">
<meta name=keyword content>
<link rel="shortcut icon" href=/img/favicon.ico>
<title>Unity篇 — Draw Call-</title>
<link rel=canonical href=/post/unity/optimization/drawcalloptimization/>
<link rel=stylesheet href=/css/iDisqus.min.css>
<link rel=stylesheet href=/css/bootstrap.min.css>
<link rel=stylesheet href=/css/hugo-theme-cleanwhite.min.css>
<link rel=stylesheet href=/css/zanshang.css>
<link href=//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css rel=stylesheet type=text/css>
<script src=/js/jquery.min.js></script>
<script src=/js/bootstrap.min.js></script>
<script src=/js/hux-blog.min.js></script>
</head>
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
<div class=container-fluid>
<div class="navbar-header page-scroll">
<button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=/>Xun's Blog</a>
</div>
<div id=huxblog_navbar>
<div class=navbar-collapse>
<ul class="nav navbar-nav navbar-right">
<li>
<a href=/>Home</a>
</li>
<li>
<a href=/categories/googleplay%E7%B3%BB%E5%88%97>googleplay系列</a>
</li>
<li>
<a href=/categories/lua%E7%B3%BB%E5%88%97>lua系列</a>
</li>
<li>
<a href=/categories/tmp%E7%B3%BB%E5%88%97>tmp系列</a>
</li>
<li>
<a href=/categories/unity%E7%B3%BB%E5%88%97>unity系列</a>
</li>
<li>
<a href=/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%B3%BB%E5%88%97>图形学系列</a>
</li>
<li>
<a href=/categories/%E6%B8%B2%E6%9F%93%E7%B3%BB%E5%88%97>渲染系列</a>
</li>
<li>
<a href=/categories/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97>算法系列</a>
</li>
</ul>
</div>
</div>
</div>
</nav>
<script>var $body=document.body,$toggle=document.querySelector('.navbar-toggle'),$navbar=document.querySelector('#huxblog_navbar'),$collapse=document.querySelector('.navbar-collapse');$toggle.addEventListener('click',handleMagic);function handleMagic(a){$navbar.className.indexOf('in')>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf('in')<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script>
<style type=text/css>header.intro-header{background-image:url('/')}</style>
<header class=intro-header>
<div class=container>
<div class=row>
<div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
<div class=post-heading>
<div class=tags>
<a class=tag href=/tags/draw-call title="Draw Call">
Draw Call
</a>
</div>
<h1>Unity篇 — Draw Call</h1>
<h2 class=subheading></h2>
<span class=meta>
Posted by
Xun
on
Sunday, January 29, 2023
</span>
</div>
</div>
</div>
</div>
</header>
<article>
<div class=container>
<div class=row>
<div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container">
<p>Draw Call 对于是性能优化过程需要关注的一个重要的内容。</p>
<h2 id=简介>简介</h2>
<ul>
<li>为了在屏幕上进行绘制，Unity 会发起 Draw Call 调用。每个 Draw Call 会告诉图形 API 要绘制什么内容以及用什么方式绘制。</li>
<li>每个 Draw Call 都包含图形 API 在屏幕上绘制所需的所有信息，例如有关纹理的信息、着色器和缓冲区。比起 Draw Call 的调用， Draw Call 的准备工作通常更消耗资源。</li>
<li>为了准备 Draw Call ，CPU 设置资源并更改 GPU 上的内部设置，这些设置统称为渲染状态。渲染状态的更改（例如切换到不同的材质）是图形 API 执行的最消耗资源的操作。</li>
<li>更改渲染状态是资源密集型任务，需要消耗大量的硬件资源。如果要优化渲染性能，主要需要减少渲染状态更改的次数。通过对相同渲染状态的对象进行分组，则图形 API 可以使用相同的渲染对象来执行多个 Draw Call ，而不需要同样数量的渲染状态更改。</li>
</ul>
<h2 id=合批>合批</h2>
<ul>
<li>通过合并网格来减少 draw call ，需要满足以下条件：
<ul>
<li>仅支持 MeshRenderer 、TrailRenderer 、LineRenderer 、ParticleSystem 、SpriteRenderer ，其他不支持，如：SkinnedMeshRender Cloth 。</li>
<li>Renderer 组件类型相同的对象才能进行合批。</li>
<li>需要使用相同的材质球。</li>
</ul>
</li>
<li>Unity 提供了两种合批方式：
<ul>
<li>静态合批。</li>
<li>动态合批。</li>
</ul>
</li>
<li>合批的优点，是 Unity 在绘制过程中，可以单独剔除部分网格对象，但代价是会产生一些额外开销。</li>
</ul>
<h3 id=静态合批>静态合批</h3>
<ul>
<li>官方文档说明如下：
<ul>
<li>静态合批预先组合静态游戏对象的网格， Unity 将组合数据发送到 GPU，但单独渲染组合中的每个网格。 Unity 仍然可以单独剔除网格，但每次绘制调用所占用的资源较少，因为数据的状态永远不会改变。</li>
<li>静态合批的对象需要满足以下条件：
<ul>
<li>要为 active 状态。</li>
<li>具有 MeshFilter 组件并且为 enable 状态。</li>
<li>MeshFilter 组件上有设置网格。</li>
<li>网格需要开启 read/write 状态。</li>
<li>网格顶点数量大于 0 。</li>
<li>网格没有合并过。</li>
<li>具有 MeshRenderer 组件并且为 enable 状态。</li>
<li>MeshRender 使用的所有材质球的 shader 没有开启 DisableBatching 标签。</li>
</ul>
</li>
<li>静态合批会为每个对象创建一个网格，将所有网格组合成一个新的大网格，再应用到所有合批的对象上，因此会需要额外的 CPU 内存，如果是离线处理，还会占用更多的存储空间。因此，对于大量使用相同网格的对象，使用静态合批可能会产生较大的内存问题。</li>
<li>静态合批每个批次最多可以包含 64000 个顶点，超出时会创建一个新的批次。</li>
</ul>
</li>
</ul>
<h4 id=不透明物体geometry>不透明物体（Geometry）</h4>
<ul>
<li>创建 10 个网格和 GameObject ，在不透明队列（Geometry）中渲染。运行时，根据静态合批的网格的 submeshes 顺序，对 GameObject 进行排序，第一个 submesh 离相机最近，如图所示：
<img src="/img/Unity/DrawCallOptimization/StaticBatch_1.png?raw=true" alt=StaticBatch_1.png>
<img src="/img/Unity/DrawCallOptimization/StaticBatch_2.png?raw=true" alt=StaticBatch_2.png>
</li>
<li>运行时表现如下：
<img src="/img/Unity/DrawCallOptimization/StaticBatch_3.png?raw=true" alt=StaticBatch_3.png>
<img src="/img/Unity/DrawCallOptimization/StaticBatch_4.png?raw=true" alt=StaticBatch_4.png>
</li>
<li>可以看到，静态合批后， SetPass Call 、Draw Call 、Batch 从 1 变成了 2，即创建的 GameObject 产生的 SetPass Call 、Draw Call 、Batch 都只有 1 。</li>
<li>重新对 GameObject 进行排序，调整成和 submeshes 的顺序不同，如：
<img src="/img/Unity/DrawCallOptimization/StaticBatch_5.png?raw=true" alt=StaticBatch_5.png>
<img src="/img/Unity/DrawCallOptimization/StaticBatch_6.png?raw=true" alt=StaticBatch_6.png>
</li>
<li>此时，SetPass Call 、Draw Call 、Batch 仍然为 2 ，即不会受到深度的影响。</li>
<li>分别隐藏 submeshes 的首个对象（4）、前两个对象（4 、14）、前两个对象和最后一个对象（4 、14 、2）时，SetPass Call 、Draw Call 、Batch 同样不会发生变化。
<img src="/img/Unity/DrawCallOptimization/StaticBatch_7.png?raw=true" alt=StaticBatch_7.png>
<img src="/img/Unity/DrawCallOptimization/StaticBatch_8.png?raw=true" alt=StaticBatch_8.png>
<img src="/img/Unity/DrawCallOptimization/StaticBatch_9.png?raw=true" alt=StaticBatch_9.png>
</li>
<li>只隐藏第二个对象（14）时，SetPass Call 、Batch 仍然为 2 ，而此时 Draw Call 则变成了 3 ，此时渲染顺序为：
<ul>
<li>第一个对象（4）。</li>
<li>第三到第十个对象（20 、18 、10 、12 、6 、8 、16 、2）。
<img src="/img/Unity/DrawCallOptimization/StaticBatch_10.png?raw=true" alt=StaticBatch_10.png>
</li>
</ul>
</li>
<li>隐藏第二、第五个对象（14 、10）时， Draw Call 则变成了 4 ，此时渲染顺序为：
<ul>
<li>第一个对象（4）。</li>
<li>第三、第四个对象（20 、18）。</li>
<li>第六到第十个对象（12 、6 、8 、16 、2）。
<img src="/img/Unity/DrawCallOptimization/StaticBatch_11.png?raw=true" alt=StaticBatch_11.png>
</li>
</ul>
</li>
<li>隐藏第二、第五、第八个对象（14 、10 、8）时， Draw Call 则变成了 5 ，此时渲染顺序为：
<ul>
<li>第一个对象（4）。</li>
<li>第三、第四个对象（20 、18）。</li>
<li>第六、第七个对象（12 、6）。</li>
<li>第九、第十个对象（16 、2）。
<img src="/img/Unity/DrawCallOptimization/StaticBatch_12.png?raw=true" alt=StaticBatch_12.png>
</li>
</ul>
</li>
<li>也就是说，对于不透明的物体，静态合批合并后的网格渲染时，SetPass Call 、Batch 都能进行合并，而 Draw Call 则不一定。如果需要渲染的对象在 submeshes 中是连续的，则可以使用 1 个 Draw Call 进行绘制，而如果隐藏了某些对象导致不连续，最终分成几段则需要几个 Draw Call 。</li>
</ul>
<h4 id=半透明物体transparent>半透明物体（Transparent）</h4>
<ul>
<li>将物体改成半透明队列（Transparent）中渲染时，如图所示：
<img src="/img/Unity/DrawCallOptimization/StaticBatch_13.png?raw=true" alt=StaticBatch_13.png>
</li>
<li>可以看到，SetPass Call 、Batch 同样能进行合并，但此时 Draw Call 变成了 11 ，将 GameObject 倒序，即第一个 submesh 离相机最远，如图所示：
<img src="/img/Unity/DrawCallOptimization/StaticBatch_14.png?raw=true" alt=StaticBatch_14.png>
<img src="/img/Unity/DrawCallOptimization/StaticBatch_15.png?raw=true" alt=StaticBatch_15.png>
</li>
<li>此时，Draw Call 又变回了 2 ，隐藏中间某些对象打断连续性的话，Draw Call 同样会发生变化，分成几段则需要几个 Draw Call 。</li>
<li>当交换第一、第二个对象（14 、4），Draw Call 变成了 4 ，此时渲染顺序为：
<ul>
<li>第二个对象（14）。</li>
<li>第一个对象（4）。</li>
<li>第三到第十个对象（20 、18 、10 、12 、6 、8 、16 、2）。
<img src="/img/Unity/DrawCallOptimization/StaticBatch_16.png?raw=true" alt=StaticBatch_16.png>
</li>
</ul>
</li>
<li>和不透明物体不同，半透明物体静态合批后，每个 submesh 仍然会按照从远到近的顺序进行渲染，此时如果渲染顺序和 submeshes 顺序不一致，即打断了 submeshes 的绘制顺序，则同样会使得 Draw Call 次数增加。</li>
</ul>
<h2 id=动态合批>动态合批</h2>
<ul>
<li>官方文档说明如下：
<ul>
<li>动态合批通过在 CPU 上变换网格顶点，对共享相同配置的顶点进行分组，并在一次绘制调用中渲染它们。如果顶点存储相同数量和类型的属性，则它们共享相同的配置。</li>
<li>网格的动态合批通过将所有顶点转换为世界空间来工作。这个过程是在 CPU 上，而不是在 GPU 上。这意味着，只有当转换工作比绘制调用占用的资源更少，动态合批才能产生优化。在游戏机或 Apple Metal 等现代 API 上，绘制调用开销通常要低得多，此时动态合批通常不会带来性能提升。</li>
<li>动态合批的对象需要满足以下条件：
<ul>
<li>顶点数不超过 300 ，顶点属性不超过 900 。</li>
<li>Transform 不能上设置为镜像，如一个对象的缩放为 1 ，另一个为 -1 。</li>
<li>需要使用相同的材质示例（shadow caster 渲染例外，只要 Unity 阴影通道所需的材质值相同即可）。</li>
<li>使用光照贴图时，光照贴图要相同。</li>
<li>前向渲染的多 Pass 渲染时，只能批处理首个 Pass ，不支持旧版延迟渲染。</li>
</ul>
</li>
<li></li>
</ul>
</li>
</ul>
<h2 id=gpu-instancing>GPU Instancing</h2>
<h2 id=合并网格>合并网格</h2>
<h2 id=srp-batcher>SRP Batcher</h2>
<hr>
<ul class=pager>
<li class=previous>
<a href=/post/unity/ugui/eventsystem/ data-toggle=tooltip data-placement=top title="Unity篇 — 事件系统">&larr;
Previous Post</a>
</li>
<li class=next>
<a href=/post/unity/shader/shader/ data-toggle=tooltip data-placement=top title="Unity篇 — Shader">Next
Post &rarr;</a>
</li>
</ul>
<div id=disqus-comment></div>
</div>
<div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container">
<div class=side-catalog>
<hr class="hidden-sm hidden-xs">
<h5>
<a class=catalog-toggle href=#>CATALOG</a>
</h5>
<ul class=catalog-body></ul>
</div>
</div>
<div class="col-lg-11 col-lg-offset-1
col-md-10 col-md-offset-1
sidebar-container">
</div>
</div>
</div>
</article>
<footer>
<div class=container>
<div class=row>
<div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
<ul class="list-inline text-center">
</ul>
<p class="copyright text-muted">
Copyright &copy; Xun's Blog 2024
<br>
<a href=https://themes.gohugo.io/hugo-theme-cleanwhite>CleanWhite Hugo Theme</a> by <a href=https://zhaohuabing.com>Huabing</a> |
<iframe style=margin-left:2px;margin-bottom:-5px frameborder=0 scrolling=0 width=100px height=20px src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true"></iframe>
</p>
</div>
</div>
</div>
</footer>
<script>function loadAsync(f,b){var c=document,d='script',a=c.createElement(d),e=c.getElementsByTagName(d)[0];a.src=f,b&&a.addEventListener('load',function(a){b(null,a)},!1),e.parentNode.insertBefore(a,e)}</script>
<script>$('#tag_cloud').length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:'#bbbbee',end:'#0085a1'}},$('#tag_cloud a').tagcloud()})</script>
<script>loadAsync("https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.js",function(){var a=document.querySelector("nav");a&&FastClick.attach(a)})</script>
<script type=text/javascript>function generateCatalog(a){_containerSelector='div.post-container';var h=$(_containerSelector),c,d,e,f,g,b;return c=h.find('h1,h2,h3,h4,h5,h6'),$(a).html(''),c.each(function(){d=$(this).prop('tagName').toLowerCase(),g="#"+$(this).prop('id'),e=$(this).text(),b=$('<a href="'+g+'" rel="nofollow">'+e+'</a>'),f=$('<li class="'+d+'_nav"></li>').append(b),$(a).append(f)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(a){a.preventDefault(),$('.side-catalog').toggleClass("fold")}),loadAsync("/js/jquery.nav.js",function(){$('.catalog-body').onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script>
</body>
</html>
<!doctype html><html lang=zh-cn>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta property="og:site_name" content="Xun's Blog">
<meta property="og:type" content="article">
<meta property="og:image" content="https://fallingxun.github.io//">
<meta property="twitter:image" content="https://fallingxun.github.io//">
<meta name=title content="Unity篇 — Shader">
<meta property="og:title" content="Unity篇 — Shader">
<meta property="twitter:title" content="Unity篇 — Shader">
<meta name=description content>
<meta property="og:description" content>
<meta property="twitter:description" content>
<meta property="twitter:card" content="summary">
<meta name=keyword content>
<link rel="shortcut icon" href=/img/favicon.ico>
<title>Unity篇 — Shader-</title>
<link rel=canonical href=/post/unity/shader/shader/>
<link rel=stylesheet href=/css/iDisqus.min.css>
<link rel=stylesheet href=/css/bootstrap.min.css>
<link rel=stylesheet href=/css/hugo-theme-cleanwhite.min.css>
<link rel=stylesheet href=/css/zanshang.css>
<link href=//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css rel=stylesheet type=text/css>
<script src=/js/jquery.min.js></script>
<script src=/js/bootstrap.min.js></script>
<script src=/js/hux-blog.min.js></script>
</head>
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
<div class=container-fluid>
<div class="navbar-header page-scroll">
<button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=/>Xun's Blog</a>
</div>
<div id=huxblog_navbar>
<div class=navbar-collapse>
<ul class="nav navbar-nav navbar-right">
<li>
<a href=/>Home</a>
</li>
<li>
<a href=/categories/googleplay%E7%B3%BB%E5%88%97>googleplay系列</a>
</li>
<li>
<a href=/categories/lua%E7%B3%BB%E5%88%97>lua系列</a>
</li>
<li>
<a href=/categories/tmp%E7%B3%BB%E5%88%97>tmp系列</a>
</li>
<li>
<a href=/categories/unity%E7%B3%BB%E5%88%97>unity系列</a>
</li>
<li>
<a href=/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%B3%BB%E5%88%97>图形学系列</a>
</li>
<li>
<a href=/categories/%E6%B8%B2%E6%9F%93%E7%B3%BB%E5%88%97>渲染系列</a>
</li>
<li>
<a href=/categories/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97>算法系列</a>
</li>
</ul>
</div>
</div>
</div>
</nav>
<script>var $body=document.body,$toggle=document.querySelector('.navbar-toggle'),$navbar=document.querySelector('#huxblog_navbar'),$collapse=document.querySelector('.navbar-collapse');$toggle.addEventListener('click',handleMagic);function handleMagic(a){$navbar.className.indexOf('in')>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf('in')<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script>
<style type=text/css>header.intro-header{background-image:url('/')}</style>
<header class=intro-header>
<div class=container>
<div class=row>
<div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
<div class=post-heading>
<div class=tags>
<a class=tag href=/tags/shader%E5%8F%82%E8%80%83 title=shader参考>
shader参考
</a>
</div>
<h1>Unity篇 — Shader</h1>
<h2 class=subheading></h2>
<span class=meta>
Posted by
Xun
on
Monday, March 6, 2023
</span>
</div>
</div>
</div>
</div>
</header>
<article>
<div class=container>
<div class=row>
<div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container">
<p>Shader相关字段、方法记录。</p>
<h2 id=properties-类型>Properties 类型</h2>
<ul>
<li>
<p>Int</p>
<ul>
<li>语法
<ul>
<li>number</li>
</ul>
</li>
<li>示例
<ul>
<li>_Int(&ldquo;Int&rdquo;, Int) = 2</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Float</p>
<ul>
<li>语法
<ul>
<li>number</li>
</ul>
</li>
<li>示例
<ul>
<li>_Float(&ldquo;Float&rdquo;, Float) = 1.5</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Range(min, max)</p>
<ul>
<li>语法
<ul>
<li>number</li>
</ul>
</li>
<li>示例
<ul>
<li>_Range(&ldquo;Range&rdquo;, Range(0.0, 5.0)) = 3.0</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Color</p>
<ul>
<li>语法
<ul>
<li>(number, number, number, number)</li>
</ul>
</li>
<li>示例
<ul>
<li>_Color(&ldquo;Color&rdquo;, Color) = (1, 1, 1, 1)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Vector</p>
<ul>
<li>语法
<ul>
<li>(number, number, number, number)</li>
</ul>
</li>
<li>示例
<ul>
<li>_Vector(&ldquo;Vector&rdquo;, Vector) = (2, 3, 6, 1)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>2D</p>
<ul>
<li>语法
<ul>
<li>&ldquo;defaulttexture&rdquo; {}</li>
</ul>
</li>
<li>示例
<ul>
<li>_2D(&ldquo;2D&rdquo;, 2D) = "" {}</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Cube</p>
<ul>
<li>语法
<ul>
<li>&ldquo;defaulttexture&rdquo; {}</li>
</ul>
</li>
<li>示例
<ul>
<li>_Cube(&ldquo;Cube&rdquo;, Cube) = &ldquo;white&rdquo; {}</li>
</ul>
</li>
</ul>
</li>
<li>
<p>3D</p>
<ul>
<li>语法
<ul>
<li>&ldquo;defaulttexture&rdquo; {}</li>
</ul>
</li>
<li>示例
<ul>
<li>_3D(&ldquo;3D&rdquo;, 3D) = &ldquo;black&rdquo; {}</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id=materialpropertydrawer-方法>MaterialPropertyDrawer 方法</h2>
<ul>
<li>
<p>[Toggle(keyword名)]</p>
<ul>
<li>启用或禁用单个着色器关键字。它使用浮点数来存储着色器关键字的状态，并将其显示为切换。启用切换时，Unity 启用 shader 关键字；当禁用切换时，Unity 会禁用 shader 关键字。</li>
<li>如果指定关键字名称，则切换会影响具有该名称的着色器关键字。如果未指定着色器关键字名称，则切换会影响名称为 的着色器关键字(uppercase property name)_ON。</li>
</ul>
<pre tabindex=0><code>  // 这个版本指定了一个关键字名称。
  // 材质属性名称不重要。
  // 启用切换时，Unity 启用名为“ENABLE_EXAMPLE_FEATURE”的着色器关键字。
  // 当禁用切换时，Unity 会禁用名为“ENABLE_EXAMPLE_FEATURE”的着色器关键字。
  [ Toggle (ENABLE_EXAMPLE_FEATURE)] _ExampleFeatureEnabled (&quot;Enable example feature&quot;, Float) = 0 

  // 此版本未指定关键字名称。
  // 材质属性名称决定了它影响的着色器关键字。
  // 启用此切换时，Unity 会启用名为“_ANOTHER_FEATURE_ON”的着色器关键字。
  // 当禁用此切换时，Unity 会禁用名为“_ANOTHER_FEATURE_ON”的着色器关键字。
  [ Toggle ] _Another_Feature (&quot;Enable another feature&quot;, Float) = 0 

  // ...稍后，在 HLSL 代码中：
  #pragma multi_compile __ ENABLE_EXAMPLE_FEATURE
  #pragma multi_compile __ _ANOTHER_FEATURE_ON
</code></pre></li>
<li>
<p>[ToggleOff(keyword名)]</p>
<ul>
<li>启用切换时，Unity 禁用 shader 关键字；当禁用切换时，Unity 启用 shader 关键字。此外，未指定着色器关键字名称时的默认名称是(uppercase property name)_OFF。</li>
<li>可用于向现有着色器添加功能和切换，同时保持向后兼容性。</li>
</ul>
<pre tabindex=0><code>  // 这个版本指定了一个关键字名称。
  // 材质属性名称不重要。
  // 启用切换时，Unity 禁用名为“DISABLE_EXAMPLE_FEATURE”的着色器关键字。
  // 当禁用切换时，Unity 启用名为“DISABLE_EXAMPLE_FEATURE”的着色器关键字。
  [ToggleOff(DISABLE_EXAMPLE_FEATURE)] _ExampleFeatureEnabled (&quot;Enable example feature&quot;, Float) = 0 

  // 此版本未指定关键字名称。
  // 材质属性名称决定了它影响的着色器关键字。
  // 启用此切换后，Unity 会禁用名为“_ANOTHER_FEATURE_OFF”的着色器关键字。
  // 当这个切换被禁用时，Unity 会启用一个名为“_ANOTHER_FEATURE_OFF”的着色器关键字。
  [ToggleOff] _Another_Feature (&quot;Enable another feature&quot;, Float) = 0 

  // ...稍后，在 HLSL 代码中：
  #pragma multi_compile __ DISABLE_EXAMPLE_FEATURE
  #pragma multi_compile __ _ANOTHER_FEATURE_OFF
</code></pre></li>
<li>
<p>[KeywordEnum(keyword1, keyword2, &mldr;)]</p>
<ul>
<li>允许您选择启用一组着色器关键字中的哪一个。它将浮动显示为弹出菜单，浮动的值决定 Unity 启用哪个着色器关键字。Unity 启用名为 的着色器关键字(uppercase property name)_(uppercase enum value name)。最多可以提供 9 个名称。</li>
</ul>
<pre tabindex=0><code>  //显示一个带有无、加、乘选项的弹出窗口。
  // 每个选项都会设置 _OVERLAY_NONE、_OVERLAY_ADD、_OVERLAY_MULTIPLY 着色器关键字。
  [KeywordEnum(None, Add, Multiply)] _Overlay (&quot;Overlay mode&quot;, Float) = 0 

  // ...稍后，在 HLSL 代码中：
  #pragma multi_compile _OVERLAY_NONE _OVERLAY_ADD _OVERLAY_MULTIPLY
</code></pre><ul>
<li>[Enum(类型1, 类型2, &mldr;)]
<ul>
<li>显示浮动属性的弹出菜单。您可以提供枚举类型名称（最好使用名称空间完全限定，以防有多种类型）或显式名称/值对来显示。最多可以指定 7 个名称/值对。</li>
</ul>
<pre tabindex=0><code>// 混合模式值
[Enum(UnityEngine.Rendering.BlendMode)] _Blend (&quot;Blend mode&quot;, Float) = 1 

// 混合模式值的子集，只有“One”（值 1）和“SrcAlpha”（值 5）。
[Enum(One,1,SrcAlpha,5)] _Blend2 (&quot;混合模式子集&quot;, Float) = 1
</code></pre></li>
</ul>
</li>
<li>
<p>[PowerSlider(非线性响应值)]</p>
<ul>
<li>显示一个对 Range 着色器属性具有非线性响应的滑块。</li>
</ul>
<pre tabindex=0><code>  // 一个 3.0 响应曲线的滑块
  [PowerSlider(3.0)] _Shininess (&quot;Shininess&quot;, Range (0.01, 1)) = 0.08
</code></pre></li>
<li>
<p>[IntRange]</p>
<ul>
<li>显示 Range 着色器属性的整数滑块。</li>
</ul>
<pre tabindex=0><code>  // 指定范围的整数滑块（0 到 255）
  [IntRange] _Alpha (&quot;Alpha&quot;, Range (0, 255)) = 100
</code></pre></li>
<li>
<p>[Space(间隔值)]</p>
<ul>
<li>在着色器属性之前创建垂直空间。</li>
</ul>
<pre tabindex=0><code>  // 默认小空间。
  [ Space ] _Prop1 (&quot;Prop1&quot;, Float) = 0 

  // 大量空间。
  [空格（50）]_Prop2（“Prop2”，浮点数）= 0
</code></pre></li>
<li>
<p>[Header(标题内容)]</p>
<ul>
<li>在着色器属性之前创建一个标题文本。</li>
</ul>
<pre tabindex=0><code>  [Header(一组东西)] _Prop1(&quot;Prop1&quot;, Float) = 0
</code></pre></li>
</ul>
<h2 id=subshader-标签类型>SubShader 标签类型</h2>
<ul>
<li>
<p>Queue</p>
<ul>
<li>控制渲染顺序，指定该物体属于哪一个渲染队列，通过这种方式可以保证所有的透明物体可以在所有不透明物体后面被渲染，也可以自定义使用的渲染队列来控制物体的渲染顺序。</li>
</ul>
<pre tabindex=0><code>  Tags {&quot;Queue&quot; = &quot;Transparent&quot;}
</code></pre></li>
<li>
<p>RenderType</p>
<ul>
<li>对着色器进行分类，例如这是一个不透明的着色器，或是一个透明的着色器等。这可以被用于着色器替换（Shader Replacement）功能。</li>
</ul>
<pre tabindex=0><code>  Tags {&quot;RenderType&quot; = &quot;Opaque&quot;}
</code></pre></li>
<li>
<p>DisableBatching</p>
<ul>
<li>一些SubShader在使用Unity的批处理功能时会出现问题，例如使用了模型空间下的坐标进行顶点动画（批处理会合并所有相关的模型，而这些模型各自的模型空间就会消失）。这时可以通过该标签来直接指明是否对该SubShader使用批处理。</li>
</ul>
<pre tabindex=0><code>  Tags {&quot;DisableBatching&quot; = &quot;True&quot;}
</code></pre></li>
<li>
<p>ForceNoShadowCasting</p>
<ul>
<li>控制使用该SubShader的物体是否会投射阴影。</li>
</ul>
<pre tabindex=0><code>  Tags {&quot;ForceNoShadowCasting&quot; = &quot;True&quot;}
</code></pre></li>
<li>
<p>IgnoreProjector</p>
<ul>
<li>如果该标签值为"True"，那么使用该SubShader的物体将不会受Projector的影响，通常用于半透明物体。</li>
</ul>
<pre tabindex=0><code>  Tags {&quot;IgnoreProjector&quot; = &quot;True&quot;}
</code></pre></li>
<li>
<p>CanUseSpriteAtlas</p>
<ul>
<li>当该SubShader是用于精灵（sprites）时，将该标签设为 &ldquo;False&rdquo;。</li>
</ul>
<pre tabindex=0><code>  Tags {&quot;CanUseSpritesAtlas&quot; = &quot;False&quot;}
</code></pre></li>
<li>
<p>PreviewType</p>
<ul>
<li>指明材质面板将如何预览该材质，默认情况下，材质将显示为一个球形，我们可以通过把该标签的值设为 &ldquo;Plane&rdquo;、&ldquo;SkyBox&rdquo; 来改变预览类型。</li>
</ul>
<pre tabindex=0><code>  Tags {&quot;PreviewType&quot; = &quot;True&quot;}
</code></pre></li>
</ul>
<h2 id=pass-类型>Pass 类型</h2>
<h3 id=标签>标签</h3>
<ul>
<li>
<p>LightMode</p>
<ul>
<li>定义该Pass在Unity的渲染流水线中的角色。
<ul>
<li>Always
<ul>
<li>不管使用哪种渲染路径，该Pass总是会被渲染，但不会计算任何光照。</li>
</ul>
</li>
<li>ForwardBase
<ul>
<li>用于前向渲染，该Pass会计算环境光、最重要的平行光、逐顶点/SH光源和Lightmaps。</li>
</ul>
</li>
<li>ForwardAdd
<ul>
<li>用于前向渲染，该Pass会计算额外的逐像素光源，每个Pass对应一个光源。</li>
</ul>
</li>
<li>Deferred
<ul>
<li>用于延迟渲染，该Pass会渲染G缓冲（G-buffer）。</li>
</ul>
</li>
<li>ShadowCaster
<ul>
<li>把物体的深度信息渲染到阴影映射纹理（shadowmap）里或一张<strong>深度纹理</strong>中。</li>
</ul>
</li>
<li>PrepassBase
<ul>
<li>用于遗留的延迟渲染，该Pass会渲染法线和高光反射的指数部分。</li>
</ul>
</li>
<li>PrepassFinal
<ul>
<li>用于遗留的延迟渲染，该Pass通过合并纹理、光照和自发光来渲染得到最后的颜色。</li>
</ul>
</li>
<li>Vertex、VertexLMRGBM和VertexLM
<ul>
<li>用于遗留的顶点照明渲染。</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre tabindex=0><code>  Tags {&quot;LightMode&quot; = &quot;ForwardBase&quot;}
</code></pre></li>
<li>
<p>RequireOptions</p>
<ul>
<li>用于指定当满足某些条件时才渲染该Pass，它的值是一个由空格分隔的字符串。目前，Unity支持的选项有：SoftVegetation，在后面的版本中，可能会增加更多的选项。</li>
</ul>
<pre tabindex=0><code>  Tags {&quot;RequireOptions&quot; = &quot;SoftVegetation&quot;}
</code></pre></li>
</ul>
<h3 id=其他>其他</h3>
<ul>
<li>
<p>Name</p>
<ul>
<li>设置 Pass 的名称，可被调用。</li>
</ul>
<pre tabindex=0><code>  Pass
  {
      Name &quot;xxxxx&quot;
      ...
  }
</code></pre></li>
<li>
<p>CGPROGRAM</p>
<ul>
<li>Pass 中 CG 代码段的标志，可在其中编写 CG 代码。</li>
</ul>
<pre tabindex=0><code>  Pass
  {
      CGPROGRAM
      ...
      ENDCG
  }
</code></pre></li>
<li>
<p>CGINCLUDE</p>
<ul>
<li>类似于C++中头文件的功能，定义一系列代码，可以避免编写重复的函数。</li>
</ul>
<pre tabindex=0><code>  SubShader
  {
      CGINCLUDE
      ...
      ENDCG

      ...
  }

</code></pre></li>
</ul>
<h2 id=unity-定义的渲染队列>Unity 定义的渲染队列</h2>
<ul>
<li>
<p>Background</p>
<ul>
<li>1000，这个渲染队列会在任何其他队列前被渲染，我们通常使用该队列来渲染那些需要绘制在背景上的物体。</li>
</ul>
</li>
<li>
<p>Geometry</p>
<ul>
<li>2000，默认的渲染队列，大多数物体都使用这个队列，不透明物体使用这个队列。</li>
</ul>
</li>
<li>
<p>AlphaTest</p>
<ul>
<li>2450，需要透明度测试的物体使用这个队列，在 Unity 5 中它从 Geometry 队列中被单独分离出来，这是因为在所有不透明物体渲染之后再渲染它们会更加高效。</li>
</ul>
</li>
<li>
<p>Transparent</p>
<ul>
<li>3000，这个队列中的物体会在所有 Geometry 和AlphaTest 物体渲染后，再按<strong>从后往前</strong>的顺序进行渲染。任何使用了透明度混合（例如关闭了深度写入的 Shader）的物体都应该使用该队列。</li>
</ul>
</li>
<li>
<p>Overlay</p>
<ul>
<li>4000，该队列用于实现一些叠加效果，任何需要在最后渲染的物体都应该使用该队列。</li>
</ul>
</li>
</ul>
<h2 id=unity-内置的世界变量>Unity 内置的世界变量</h2>
<ul>
<li>
<p>_Time</p>
<ul>
<li>float4，t 是自该场景加载开始所经过的时间，4个分量的值分别为（t/20，t，2t，3t）。</li>
</ul>
</li>
<li>
<p>_SinTime</p>
<ul>
<li>float4，t 是时间的正弦值，4个分量的值分别为（t/8，t/4，t/2，t）。</li>
</ul>
</li>
<li>
<p>_CosTime</p>
<ul>
<li>float4，t 是时间的余弦值，4个分量的值分别为（t/8，t/4，t/2，t）。</li>
</ul>
</li>
<li>
<p>_unity_DeltaTime</p>
<ul>
<li>float4，dt 是时间增量，4个分量的值分别为（dt，1/dt，smoothDt，1/smoothDt）。</li>
</ul>
</li>
</ul>
<h2 id=常用语义>常用语义</h2>
<h3 id=应用阶段---顶点着色器>应用阶段 -> 顶点着色器</h3>
<ul>
<li>POSITION
<ul>
<li>模型空间的顶点位置，通常是float4。</li>
</ul>
</li>
<li>NORMAL
<ul>
<li>顶点法线，通常是float3。</li>
</ul>
</li>
<li>TANGENT
<ul>
<li>顶点切线，通常是float4。</li>
</ul>
</li>
<li>TEXCOORDn
<ul>
<li>该顶点的纹理坐标，n为0表示第一组纹理坐标，通常为float2或float4。</li>
</ul>
</li>
<li>COLOR
<ul>
<li>顶点颜色，通常为float4或fixed4。</li>
</ul>
</li>
</ul>
<h3 id=顶点着色器---片元着色器>顶点着色器 -> 片元着色器</h3>
<ul>
<li>SV_POSITION
<ul>
<li>裁剪空间的顶点坐标，结构体中必须包含一个用该语义修饰的变量。</li>
</ul>
</li>
<li>COLOR0
<ul>
<li>通常用于第一组输出颜色，非必需。</li>
</ul>
</li>
<li>COLOR1
<ul>
<li>通常用于第二组输出颜色，非必需。</li>
</ul>
</li>
<li>TEXCOORD0~TEXCOORD7
<ul>
<li>输出纹理坐标，非必需。</li>
</ul>
</li>
</ul>
<h3 id=片元着色器---输出>片元着色器 -> 输出</h3>
<ul>
<li>SV_Target
<ul>
<li>输出值将会存到渲染目标（render target）中。</li>
</ul>
</li>
</ul>
<h2 id=常用变量>常用变量</h2>
<h3 id=光照相关>光照相关</h3>
<ul>
<li>
<p>UNITY_LIGHTMODE_AMBIENT</p>
<ul>
<li>系统的环境光。</li>
</ul>
</li>
<li>
<p>_WorldSpaceLightPos0</p>
<ul>
<li>第一个直射光的世界坐标位置。</li>
</ul>
</li>
<li>
<p>_LightColor0</p>
<ul>
<li>第一个直射光的颜色。</li>
</ul>
</li>
</ul>
<p>光照变量需要使用 #include &ldquo;lighting.cginc&rdquo;。</p>
<h3 id=前向渲染>前向渲染</h3>
<ul>
<li>
<p>_LightColor0</p>
<ul>
<li>float4，该Pass处理的逐像素光源的颜色。</li>
</ul>
</li>
<li>
<p>_WorldSpaceLightPos0</p>
<ul>
<li>float4，_WorldSpaceLightPos0.xyz是该Pass处理的逐像素光源的位置，如果该光源是平行光，则w为0，其他w为1。</li>
</ul>
</li>
<li>
<p>_LightMatrix0</p>
<ul>
<li>float4x4，从世界空间到光源空间的变换矩阵，可以用于采用cookie和光强衰减（attenuation）纹理。</li>
</ul>
</li>
<li>
<p>unity_4LightPosX0，unity_4LightPosY0，unity_4LightPosZ0</p>
<ul>
<li>float4，仅用于Base Pass，前4个非重要的点光源在世界空间中的位置。</li>
</ul>
</li>
<li>
<p>unity_4LightAtten0</p>
<ul>
<li>float4，仅用于Base Pass，前4个非重要的点光源的衰减因子。</li>
</ul>
</li>
<li>
<p>unity_4LightColor</p>
<ul>
<li>half4[4]，仅用于Base Pass，存储了前4个非重要的点光源的颜色。</li>
</ul>
</li>
</ul>
<p>使用光照衰减等光照变量，需要用 #pragma multi_compile_fwdbase 、#pragma multi_compile_fwdadd。</p>
<h3 id=顶点照明渲染>顶点照明渲染</h3>
<ul>
<li>
<p>unity_LightColor</p>
<ul>
<li>half4[8]，光源颜色。</li>
</ul>
</li>
<li>
<p>unity_LightPosition</p>
<ul>
<li>float4[8]，xyz分量是视角空间中的光源位置，如果光源是平行光，那么z为0，其余为1。</li>
</ul>
</li>
<li>
<p>unity_LightAtten</p>
<ul>
<li>half4[8]，光源衰减因子，如果光源是聚光灯，x分量是cos（spotAngle/2），y分量是1/cos（spotAngle/4）；如果是其他类型的光源，x分量是-1，y分量是1。z分量是衰减的平方，w分量是光源范围开根号的结果。</li>
</ul>
</li>
<li>
<p>unity_SpotDirection</p>
<ul>
<li>float4[8]，如果光源是聚光灯的话，值为视角空间的聚光灯的位置，如果是其他光源类型，值为（0，0，1，0）。</li>
</ul>
</li>
</ul>
<h3 id=延迟渲染>延迟渲染</h3>
<ul>
<li>
<p>_LightColor</p>
<ul>
<li>float4 光源颜色。</li>
</ul>
</li>
<li>
<p>_LightMatrix0</p>
<ul>
<li>float4x4 从世界空间到光源空间的变换矩阵，可以用于采样cookie和光强衰减纹理。</li>
</ul>
</li>
</ul>
<h3 id=摄像机和屏幕参数>摄像机和屏幕参数</h3>
<ul>
<li>
<p>_WorldSpaceCameraPos</p>
<ul>
<li>float3，该摄像机在世界空间中的位置。</li>
</ul>
</li>
<li>
<p>_ProjectionParams</p>
<ul>
<li>float4，x = 1.0（或-1.0，如果正使用一个翻转的投影矩阵尽心渲染），y = Near，z = Far，w = 1.0 + 1.0/Far，其中 Near、Far 为近裁剪平面、远裁剪平面和摄像机的距离。</li>
</ul>
</li>
<li>
<p>_ScreenParams</p>
<ul>
<li>float4，x = width，y = height，z = 1.0 + 1.0/width，w = 1.0 + 1.0/height，其中 width、height 分别为该摄像机的渲染目标（render target）的像素宽和高。</li>
</ul>
</li>
<li>
<p>_ZBufferParams</p>
<ul>
<li>float4，x = 1 - Far/Near，y = Far/Near，z = x/Far，w = y/Far，该变量用于线性化Z缓存中的深度值。</li>
</ul>
</li>
<li>
<p>unity_OrthoParams</p>
<ul>
<li>float4，x = width，y = height，z 没有定义，w = 1.0（该相机为正交相机）或 w = 0.0（该相机为透视相机），其中 width、height 为正交投影摄像机的宽高。</li>
</ul>
</li>
<li>
<p>unity_CameraProjection</p>
<ul>
<li>float4x4，该相机的投影矩阵。</li>
</ul>
</li>
<li>
<p>unity_CameraInvProjection</p>
<ul>
<li>float4x4，该相机的投影矩阵逆矩阵。</li>
</ul>
</li>
<li>
<p>unity_CameraWorldClipPlanes[6]</p>
<ul>
<li>float4，该相机的6个裁剪平面在世界空间下的等式，依次为左、右、下、上、近、远裁剪平面。</li>
</ul>
</li>
</ul>
<h3 id=其他-1>其他</h3>
<ul>
<li>
<p>bump</p>
<ul>
<li>Unity内置的法线纹理，没有提供任何法线纹理时，就对应模型自带的法线信息。</li>
</ul>
</li>
<li>
<p>TANGENT_SPACE_ROTATION</p>
<ul>
<li>模型空间到切线空间变换矩阵rotation。</li>
</ul>
</li>
<li>
<p>_LightTexture0</p>
<ul>
<li>衰减查找纹理，通常只关心对角线上的纹理颜色值，这些值表明了在光源空间中不同位置的点的衰减值。如（0，0）表明与光源位置重合的点的衰减值，（1，1）点表明在光源空间中所关心的距离最远的点的衰减。</li>
</ul>
</li>
<li>
<p>_LightTextureB0</p>
<ul>
<li>光源使用cookie的衰减查找纹理。</li>
</ul>
</li>
<li>
<p>UNITY_ATTEN_CHANNEL</p>
<ul>
<li>衰减纹理中衰减值所在的分量。</li>
</ul>
</li>
</ul>
<h2 id=常用方法>常用方法</h2>
<h3 id=混合计算>混合计算</h3>
<ul>
<li>Blend SrcFactor DstFactor</li>
<li>最终颜色 = (源颜色 × SrcFactor) + (目标颜色 × DstFactor)</li>
</ul>
<h3 id=混合类型>混合类型</h3>
<ul>
<li>
<p>Source Color</p>
<ul>
<li>源颜色，指片元着色器产生的颜色值</li>
</ul>
</li>
<li>
<p>Destination Color</p>
<ul>
<li>目标颜色，指从颜色缓冲中读到的颜色值</li>
</ul>
</li>
<li>
<p>Blend SrcAlpha OneMinusSrcAlpha</p>
<ul>
<li>正常（normal），透明度混合。</li>
</ul>
</li>
<li>
<p>Blend OneMinusDstColor One</p>
<ul>
<li>柔和相加（Soft Addtive）。</li>
</ul>
</li>
<li>
<p>Blend DstColor Zero</p>
<ul>
<li>正片叠底（Multiply），即相乘。</li>
</ul>
</li>
<li>
<p>Blend DstColor SrcColor</p>
<ul>
<li>两倍相乘（2x Multiply）。</li>
</ul>
</li>
<li>
<p>BlendOp Min、Blend One One</p>
<ul>
<li>变暗（Darken）。</li>
</ul>
</li>
<li>
<p>BlendOp Max、Blend One One</p>
<ul>
<li>变亮（Lighten）。</li>
</ul>
</li>
<li>
<p>Blend OneMinusDstColor One</p>
<ul>
<li>滤色（Screen）。等同于 Blend One OneMinusSrcColor。</li>
</ul>
</li>
<li>
<p>Blend One One</p>
<ul>
<li>线性减淡（Linear Dodge）。</li>
</ul>
</li>
</ul>
<h3 id=前向渲染-1>前向渲染</h3>
<ul>
<li>
<p>float3 WorldSpaceLightDir(float4 v)</p>
<ul>
<li>仅可用于前向渲染中，输入一个模型空间中的顶点位置，返回世界空间中从该点到光源的光照方向，内部实现了UnityWorldSpaceLightDIr函数，没有归一化。</li>
</ul>
</li>
<li>
<p>float3 UnityWorldSpaceLightDIr(float4 v)</p>
<ul>
<li>仅可用于前向渲染中，输入一个世界空间中的顶点位置，返回世界空间中从该点到光源的光照方向，没有归一化。</li>
</ul>
</li>
<li>
<p>float3 ObjSpaceLightDir(float4 v)</p>
<ul>
<li>仅可用于前向渲染中，输入一个模型空间中的定点位置，返回模型空间中从该点到光源的光照方向，没有归一化。</li>
</ul>
</li>
<li>
<p>float3 Shade4PointLights(&mldr;)</p>
<ul>
<li>仅可用于前向渲染中，计算四个点光源的光照，它的参数是已经打包进矢量的光照数据，通常就是上述的内置光照变量，前向渲染通常会使用这个函数来计算逐顶点光照。</li>
</ul>
</li>
</ul>
<h3 id=顶点照明渲染-1>顶点照明渲染</h3>
<ul>
<li>
<p>float3 ShadeVertexLights (float4 vertex, float3 normal)</p>
<ul>
<li>输入模型空间的顶点位置和法线，计算四个逐顶点光源的光照以及环境光，内部实际实现上调用了ShadeVertexLightsFull函数。</li>
</ul>
</li>
<li>
<p>float3 ShadeVertexLightsFull (float4 vertex, float3 normal, int lightCount, bool spotLight)</p>
<ul>
<li>输入模型空间的顶点位置和法线，计算lightCount个光源的光照以及环境光，如果spotLight值为true，那么这些光源会被当成聚光灯来处理，虽然结果更加精确，但是更耗时；否则，按点光源处理。</li>
</ul>
</li>
</ul>
<h3 id=阴影相关>阴影相关</h3>
<ul>
<li>
<p>SHADOW_COORDS(X)</p>
<ul>
<li>声明一个用于对阴影纹理采样的坐标，X为下一个可用的插值寄存器的索引值。</li>
</ul>
</li>
<li>
<p>TRANSFER_SHADOW(o)</p>
<ul>
<li>用于在顶点着色器里计算上一步中声明的阴影纹理坐标。</li>
</ul>
</li>
<li>
<p>SHADOW_ATTENUATION</p>
<ul>
<li>在片元着色器中计算阴影值。</li>
</ul>
</li>
<li>
<p>UNITY_LIGHT_ATTENUATION</p>
<ul>
<li>计算光照衰减和阴影的宏。</li>
</ul>
</li>
</ul>
<p>阴影相关方法需要使用 #include &ldquo;AutoLight.cginc&rdquo;。</p>
<h3 id=其他-2>其他</h3>
<ul>
<li>
<p>UsePass</p>
<ul>
<li>复用其他 UnityShader 的 Pass。</li>
</ul>
<pre tabindex=0><code>UsePass &quot;Shader名/Pass名&quot;
</code></pre></li>
<li>
<p>GrabPass</p>
<ul>
<li>抓取屏幕并将结果存储在一张纹理中，以用于后续的 Pass 处理。</li>
</ul>
<pre tabindex=0><code>  GrabPass{ _RefractionTex }
  ...
  sampler2D _RefractionTex;
  ...
  float4 _RefractionTex_TexelSize;
  ...
  float2 offset = bump.xy * _Distortion * _RefractionTex_TexelSize.xy;
  i.scrPos.xy = offset * i.scrPos.z + i.scrPos.xy;		//切线空间下偏移采样坐标，模拟折射效果
  tex2D(_RefractionTex, i.scrPos.xy/i.scrPos.w)	//透视除法，得到真正的屏幕坐标进行采样
</code></pre></li>
<li>
<p>ColorMask</p>
<ul>
<li>ColorMask RGB | A | 0 | 其他任何R、G、B、A组合。</li>
<li>用于设置颜色通道的掩码，为0时不写入任何颜色通道，即不会输出任何颜色，配合ZWrite On可以实现半透明的深度写入。</li>
</ul>
</li>
<li>
<p>Cull</p>
<ul>
<li>Cull Back | Front | Off ，剔除。
<ul>
<li>Back：背对摄像机的渲染图元不会被渲染，默认情况下的剔除状态。</li>
<li>Front：面朝向摄像机的渲染图元不会被渲染。</li>
<li>Off：关闭剔除功能，所有的渲染图元都会被渲染，但由于这时需要渲染的图元数目会成倍增加，因此除非是用于特殊效果，如双面渲染的透视效果，通常情况不关闭剔除。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>reflect</p>
<ul>
<li>reflect（归一化入射光方向，归一化法线方向），其中物体反射到摄像机中的光线方向，可以由光路可逆的原则来反向求得，即可以计算视角方向关于顶点法线的反射方向来求得入射光线的方向。</li>
</ul>
</li>
<li>
<p>refract</p>
<ul>
<li>refract（归一化入射光方向，归一化法线方向，入射光所在介质的折射率和折射光所在介质的折射率的比值）：返回计算得到的折射方向，模为入射光线的模。</li>
</ul>
</li>
<li>
<p>texCUBE</p>
<ul>
<li>对立方体的纹理采样，采样时，可理解为光从中心指向某个顶点时与立方体的交点。</li>
</ul>
</li>
<li>
<p>tex2D</p>
<ul>
<li>2D纹理图采样。</li>
</ul>
</li>
<li>
<p>TRANSFORM_TEX</p>
<ul>
<li>使用纹理的属性值 _MainTex_ST 来对顶点纹理坐标进行变换，第一个参数为顶点纹理坐标，第二个参数为纹理名。</li>
</ul>
<pre tabindex=0><code>  // Transforms 2D UV by scale/bias property
  #define TRANSFORM_TEX(tex,name) (tex.xy * name##_ST.xy + name##_ST.zw)
</code></pre></li>
</ul>
<h2 id=光照模型>光照模型</h2>
<h3 id=漫反射>漫反射</h3>
<ul>
<li>
<p>兰伯特模型（Lambert）
<img src="/img/Unity/Shader/Math_Lambert.png?raw=true" alt=Math_Lambert.png>
</p>
<ul>
<li>c_light ：光源颜色</li>
<li>m_diffuse ：材质的漫反射颜色</li>
<li>n ：表面法线</li>
<li>I ：指向光源的单位矢量，点乘值取大于0，防止被从背后照来的光照亮</li>
</ul>
</li>
<li>
<p>半兰伯特光照模型
<img src="/img/Unity/Shader/Math_HalfLambert.png?raw=true" alt=Math_HalfLambert.png>
改善问题：光照无法到达的区域，模型的外观通常是全黑的，没有任何明暗变化，使得模型的背光区域看起来就像一个平面一样，失去了细节表现。和原兰伯特模型相比，少了max操作，对结果进行了α倍缩放和β偏移，通常都为0.5，将法线和光源的矢量点乘从[-1,1]偏移到[0,1]，即背光面，原兰伯特光照模型的点乘结果将映射到0处。</p>
</li>
</ul>
<h3 id=高光反射>高光反射</h3>
<ul>
<li>
<p>Phong模型
<img src="/img/Unity/Shader/Math_Phong.png?raw=true" alt=Math_Phong.png>
</p>
<ul>
<li>c_light ：入射光的颜色和强度</li>
<li>m_specular ：材质的高光反射系数</li>
<li>v ：视角方向</li>
<li>r ：反射方向（即 reflect(i，n)，入射方向（指向光源方向取反）、法线方向）</li>
</ul>
</li>
<li>
<p>Blinn Phong模型
<img src="/img/Unity/Shader/Math_BlinnPhong.png?raw=true" alt=Math_BlinnPhong.png>
</p>
<ul>
<li>h ：视角方向和指向光源方向相加后归一化
<img src="/img/Unity/Shader/Math_BlinnPhong_h.png?raw=true" alt=Math_BlinnPhong.png>
</li>
</ul>
</li>
</ul>
<h3 id=菲涅尔反射>菲涅尔反射</h3>
<ul>
<li>
<p>Schlick菲涅耳近似等式
<img src="/img/Unity/Shader/Math_SchlickFresnel.png?raw=true" alt=Math_SchlickFresnel.png>
</p>
<ul>
<li>F_0 ：反射系数，用于控制菲涅尔反射的强度</li>
<li>v ：视角方向</li>
<li>n ：表面法线</li>
</ul>
</li>
<li>
<p>Empricial菲涅耳近似等式
<img src="/img/Unity/Shader/Math_EmpricialFresnel.png?raw=true" alt=Math_EmpricialFresnel.png>
</p>
<ul>
<li>其中，bias、scale、power 为控制项</li>
</ul>
</li>
</ul>
<h2 id=渲染方程>渲染方程</h2>
<ul>
<li>渲染方程公式
<img src="/img/Unity/Shader/Math_Render.png?raw=true" alt=Math_Render.png>
<ul>
<li>给定观察视角 v，该方向上的出射辐射率 L_o(v) 等于该点向观察方向发出的自发光辐射率 L_e(v) 加上所有有效的入射光 L_i(w_i) 到达观察点的辐射率积分和。其中
<ul>
<li>v ：观察方向</li>
<li>L_o(v) ：由当前点出发，到达观察点的总光照</li>
<li>L_e(v) ：由当前点发出的自发光部分</li>
<li>∫_Ω ：对以当前点为球心的半球内的入射光照进行无穷小累加</li>
<li>f(w_i, v) ：描述了从某个方向出发，经过当前点反射后，有多少光照被反射到了观察方向</li>
<li>L_i(w_i) ：从某个方向出发，到达当前点的光照</li>
<li>n ⋅ w_i ：由于入射角度而对从该方向出发的光照亮度所造成的衰减</li>
<li>w_i ：入射方向位于以当前点为球心的半球内的某个入射光照</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id=深度纹理>深度纹理</h2>
<ul>
<li>
<p>深度纹理可以直接来自于真正的深度缓存，也可以是由一个单独的Pass渲染而得。</p>
<ul>
<li>当使用延迟渲染路径时，深度纹理可以被访问，因为延迟渲染会把这些信息渲染到 G-buffer 中。</li>
<li>当无法获取深度缓存时，深度和法线纹理是通过一个单独的 Pass 渲染的。
<ul>
<li>Unity会使用着色器替换（Shader Replacement）技术选择那些渲染类型（即SubShader的RenderType标签）为Opaque的物体，判断他们使用的渲染队列是否小于等于2500（Background、Geometry、AlphaTest），如果满足则渲染到深度和法线纹理中。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>获取深度纹理流程：</p>
<ul>
<li>设置 Camera.depthTextureMode 为 DepthTextureMode.Depth。</li>
<li>shader中声明 _CameraDepthTexture 变量来访问。</li>
</ul>
</li>
<li>
<p>获取深度和法线纹理：</p>
<ul>
<li>设置 Camera.depthTextureMode 为 DepthTextureMode.DepthNormals。</li>
<li>shader中声明 _CameraDepthNormalsTexture 变量来访问。</li>
</ul>
</li>
<li>
<p>SAMPLE_DEPTH_TEXTURE</p>
<ul>
<li>采样深度纹理的宏，为了避免平台差异（PS3、PSP2等）。绝大多数情况下，可直接使用 tex2D 采样即可。</li>
</ul>
<pre tabindex=0><code>  float d = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv);
</code></pre></li>
<li>
<p>SAMPLE_DEPTH_TEXTURE_PROJ</p>
<ul>
<li>投影纹理采样，通常用于阴影的实现中。</li>
<li>内部使用了 tex2Dproj 进行采样，纹理坐标的前两个分量会首先除以最后一个分量，如果有第四个分量，还会进行一次比较，再进行纹理采样。</li>
</ul>
<pre tabindex=0><code>  float d = SAMPLE_DEPTH_TEXTURE_PROJ(_CameraDepthTexture, UNITY_PROJ_COORD(i.scrPos));
</code></pre></li>
<li>
<p>纹理采样得到深度值，往往是非线性的，因为是裁剪空间下获取的，需要变换到线性空间下，如视角空间下的深度值。</p>
<ul>
<li>LinearEyeDepth
<ul>
<li>把深度纹理的采样结果转换到视角空间下的深度值。</li>
</ul>
</li>
<li>Linear01Depth
<ul>
<li>返回范围在[0, 1]的线性深度值，即 LinearEyeDepth / Far。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>DecodeDepthNormal</p>
<ul>
<li>采样并解码深度法线纹理，得到深度值和法线方向。</li>
</ul>
</li>
<li>
<p>场景的物体要想能输出深度到深度图里的，需要有一个 Pass 的 LightMode 为 ShadowCaster。</p>
<ul>
<li>自己增加一个 Pass，设置 LightMode。</li>
</ul>
<pre tabindex=0><code>  Pass
  {
      Name &quot;ShadowCaster&quot;

      Tags {&quot;LightMode&quot; = &quot;ShadowCaster&quot;}
  }
</code></pre><ul>
<li>设置 FallBack 的 Shader ，Shader 中的某一个 Pass 的 LightMode 为 ShadowCaster。</li>
</ul>
<pre tabindex=0><code>  // Diffuse 最终 FallBack 到 Legacy Shaders/VertexLit
  FallBack &quot;Diffuse&quot;
</code></pre></li>
</ul>
<h2 id=深度测试和深度写入>深度测试和深度写入</h2>
<ul>
<li>
<p>深度测试（ZTest）</p>
<ul>
<li>默认开启 LEqual，如果当前片元的深度值大于深度缓冲（z-buffer），即距离相机更远，则会被舍弃，否则将片元颜色更新到颜色缓存。</li>
</ul>
</li>
<li>
<p>深度写入（ZWrite）</p>
<ul>
<li>默认开启，如果当前片元的深度值小于深度缓冲，则更新深度缓冲的深度值，以及更新颜色缓存。</li>
</ul>
</li>
<li>
<p>shader默认会有 ZTest LEqual 和 ZWrite On。</p>
<ul>
<li>对于不透明物体，渲染队列比半透明物体小，先渲染，开启了深度测试和深度写入，只渲染距离最近的片元。</li>
<li>而半透明物体需要关闭深度写入 ZWrite Off，开启颜色混合，关闭深度写入让半透明物体在不透明物体前面，从远到近渲染。</li>
<li>但对半透明物体渲染时，如果模型本身有复杂的遮挡或者包含复杂的非凸网格的时候，关闭了深度写入就无法对模型进行像素级别的深度排序，就会因为排序错误而产生错误的透明效果。此时可以使用两个Pass，一个开启深度写入，但不输出任何颜色到颜色缓存，即ColorMask 0，但能得到像素级别的深度排序，另一个Pass再关闭深度写入，按常规半透明渲染方式渲染。</li>
</ul>
</li>
</ul>
<h2 id=模板缓冲>模板缓冲</h2>
<ul>
<li>StencilBuffer</li>
</ul>
<pre tabindex=0><code>    Stencil
    {
        Ref [_Stencil]
        Comp [_StencilComp]
        Pass [_StencilOp]
        ReadMask [_StencilReadMask]
        WriteMask [_StencilWriteMask]
    }
</code></pre><ul>
<li>
<p>Ref</p>
<ul>
<li>设定参考值，stencilbuffer里面的值会与其比较。</li>
<li>范围[0, 255]，默认为0。</li>
</ul>
</li>
<li>
<p>ReadMask</p>
<ul>
<li>在比较参考值和buffer值的时候用，用于读取buffer值里面的值。</li>
<li>范围[0, 255]，默认为255。</li>
</ul>
</li>
<li>
<p>WriteMask</p>
<ul>
<li>写入buffer值用。</li>
<li>范围[0, 255]，默认为255。</li>
</ul>
</li>
<li>
<p>Comp</p>
<ul>
<li>比较方式：
<ul>
<li>Never：永远不通过。</li>
<li>Less：小于。</li>
<li>Equal：等于。</li>
<li>LEqual：小于等于。</li>
<li>Greater：大于。</li>
<li>NotEqual：不等于。</li>
<li>GEqual：大于等于。</li>
<li>Always：永远通过。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Pass</p>
<ul>
<li>当模板测试和深度测试<strong>都通过</strong>的时候，进行的stencilOperation操作方法。
<ul>
<li>Keep：保持当前缓冲值。</li>
<li>Zero：模板缓冲值写入0。</li>
<li>Replace：替换模板缓冲值为 Ref 值。</li>
<li>IncrSat：模板缓冲值+1，上限为255。</li>
<li>DecrSat：模板缓冲值-1，下限为0。</li>
<li>Invert：翻转缓冲值的所有位。</li>
<li>IncrWrap：模板缓冲值+1，如果当前为255，则变为0。</li>
<li>DecrWrap：模板缓冲值-1，如果当前为0，则变为255。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Fail</p>
<ul>
<li>模板测试通过的时候执行的stencilOperation方法。</li>
</ul>
</li>
<li>
<p>ZFail</p>
<ul>
<li>在stencil测试通过，但是深度测试没有通过的时候执行的stencilOperation方法。</li>
</ul>
</li>
<li>
<p>模板测试方程为</p>
<ul>
<li>(ref & readMask) comparisonFunction (stencilBufferValue & readMask)</li>
</ul>
</li>
</ul>
<h2 id=常用概念>常用概念</h2>
<ul>
<li>
<p>亮度</p>
<ul>
<li>原颜色 * 亮度系数_Brightness。</li>
</ul>
</li>
<li>
<p>亮度值</p>
<ul>
<li>0.2125 * r + 0.7154 * g + 0.0721 * b。</li>
</ul>
</li>
<li>
<p>饱和度</p>
<ul>
<li>lerp（饱和度为0的颜色值（即用亮度构成的rgb），调整亮度后的颜色，插值属性）。</li>
</ul>
</li>
<li>
<p>对比度</p>
<ul>
<li>lerp（对比度为0的颜色值（即rgb为0.5），调整饱和度后的 y 暗色，插值属性）。</li>
</ul>
</li>
<li>
<p>梯度值 G</p>
<ul>
<li>G = |G~x~| + |G~y~|，梯度值越大，越可能是边界。</li>
<li>常见的边缘检测算子
<ul>
<li>Roberts</li>
</ul>
<pre tabindex=0><code class=language-math data-lang=math>G_x = \begin{bmatrix} -1&amp;0 \\ 0&amp;1 \end{bmatrix} ,
G_y = \begin{bmatrix} -1&amp;0 \\ 0&amp;1 \end{bmatrix}
</code></pre><ul>
<li>Prewitt</li>
</ul>
<pre tabindex=0><code class=language-math data-lang=math>G_x = \begin{bmatrix} -1&amp;-1&amp;-1 \\ 0&amp;0&amp;0 \\ 1&amp;1&amp;1 \end{bmatrix} ,
G_y = \begin{bmatrix} -1&amp;0&amp;1 \\ -1&amp;0&amp;1 \\ -1&amp;0&amp;1 \end{bmatrix}
</code></pre><ul>
<li>Sobel</li>
</ul>
<pre tabindex=0><code class=language-math data-lang=math>G_x = \begin{bmatrix} -1&amp;-2&amp;-1 \\ 0&amp;0&amp;0 \\ 1&amp;2&amp;1 \end{bmatrix} ,
G_y = \begin{bmatrix} -1&amp;0&amp;1 \\ -2&amp;0&amp;2 \\ -1&amp;0&amp;1 \end{bmatrix}
</code></pre></li>
</ul>
</li>
<li>
<p>高斯模糊</p>
<ul>
<li>水平模糊因子，y坐标不变，x坐标偏移为（-2, -1, 0, 1, 2）。</li>
</ul>
<pre tabindex=0><code>  offset[1] = float2(_MainTex_TexelSize.x * -2.0, 0.0);
  offset[2] = float2(_MainTex_TexelSize.x * -1.0, 0.0);
  offset[3] = float2(_MainTex_TexelSize.x * 1.0, 0.0);
  offset[4] = float2(_MainTex_TexelSize.x * 2.0, 0.0);
</code></pre><ul>
<li>垂直模糊因子，x坐标不变，y坐标偏移为（-2, -1, 0, 1, 2）。</li>
</ul>
<pre tabindex=0><code>  offset[1] = float2(0.0, _MainTex_TexelSize.y * -2.0);
  offset[2] = float2(0.0, _MainTex_TexelSize.y * -1.0);
  offset[3] = float2(0.0, _MainTex_TexelSize.y * 1.0);
  offset[4] = float2(0.0, _MainTex_TexelSize.y * 2.0);
</code></pre><ul>
<li>权重值，从中间向两侧递减。</li>
</ul>
<pre tabindex=0><code>  weight[5] = {0.0545, 0.2442, 0.4026, 0.2442, 0.0545};
</code></pre></li>
<li>
<p>LUT（lookup texture、lookup table）</p>
<ul>
<li>查找纹理或查找表，存储了复杂的光照计算，运行时只需要用光源方向、视角方向、法线方向等进行采样得到光照结果。</li>
</ul>
</li>
<li>
<p>移动端设备芯片</p>
<ul>
<li>PowerVR芯片（通常用于某些iOS和Android设备）
<ul>
<li>基于瓦片的延迟渲染（Tiled-based Deferred Rendering，TBDR）架构，把所有的渲染图像装入一个瓦片（tile）中，再由硬件找到可见的片元，只有这些片元才会执行片元着色器。</li>
</ul>
</li>
<li>Adreno（高通）和Mali（ARM）
<ul>
<li>基于瓦片（TBR）的GPU架构，使用Early-Z或相似的技术进行低精度的深度检测，剔除不需要渲染的片元。</li>
</ul>
</li>
<li>Tegra（英伟达）
<ul>
<li>传统架构设计。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id=内置封装方法>内置封装方法</h2>
<h3 id=unitycgcginc>UnityCG.cginc</h3>
<ul>
<li>LinearEyeDepth & Linear01Depth
<ul>
<li>将深度缓冲（z-buffer）从裁剪空间转到线性空间</li>
</ul>
</li>
</ul>
<pre tabindex=0><code>// Z buffer to linear 0..1 depth
inline float Linear01Depth( float z )
{
    return 1.0 / (_ZBufferParams.x * z + _ZBufferParams.y);
}
// Z buffer to linear depth
inline float LinearEyeDepth( float z )
{
    return 1.0 / (_ZBufferParams.z * z + _ZBufferParams.w);
}
</code></pre><ul>
<li>ObjSpaceLightDir
<ul>
<li>计算模型空间下的光照方向</li>
</ul>
</li>
</ul>
<pre tabindex=0><code>inline float3 ObjSpaceLightDir( in float4 v )
{
    float3 objSpaceLightPos = mul(unity_WorldToObject, _WorldSpaceLightPos0).xyz;
    #ifndef USING_LIGHT_MULTI_COMPILE
        return objSpaceLightPos.xyz - v.xyz * _WorldSpaceLightPos0.w;
    #else
        #ifndef USING_DIRECTIONAL_LIGHT
        return objSpaceLightPos.xyz - v.xyz;
        #else
        return objSpaceLightPos.xyz;
        #endif
    #endif
}
</code></pre><ul>
<li>ObjSpaceViewDir
<ul>
<li>计算模型空间下的视角方向</li>
</ul>
</li>
</ul>
<pre tabindex=0><code>inline float3 ObjSpaceViewDir( in float4 v )
{
    float3 objSpaceCameraPos = mul(unity_WorldToObject, float4(_WorldSpaceCameraPos.xyz, 1)).xyz;
    return objSpaceCameraPos - v.xyz;
}
</code></pre><ul>
<li>TANGENT_SPACE_ROTATION
<ul>
<li>得到模型空间到切线空间下的变换矩阵（输入变量定义为 v ，返回矩阵定义为 float3x3 rotation）</li>
<li>切线的 w 分量决定副法线的方向</li>
<li>切线空间下的点 A(a，b，c)，即在切线空间下的原点 O 沿三个轴 x、y、z 移动得到，对应模型空间下则为 O&rsquo;沿三个方向 x'、y'、z' 移动得到，即 O' + ax' + by' + cz'，可以得到切线空间到模型空间的变换矩阵为 x'、y'、z' 按列摆放的矩阵，由于该矩阵为正交矩阵，则模型空间到切线空间的变换矩阵为 x'、y'、z&rsquo;按行摆放的矩阵。</li>
</ul>
</li>
</ul>
<pre tabindex=0><code>#define TANGENT_SPACE_ROTATION \
    float3 binormal = cross( normalize(v.normal), normalize(v.tangent.xyz) ) * v.tangent.w; \
    float3x3 rotation = float3x3( v.tangent.xyz, binormal, v.normal )
</code></pre><ul>
<li>UnityObjectToClipPos
<ul>
<li>将坐标从模型空间变换到裁剪空间</li>
</ul>
</li>
</ul>
<pre tabindex=0><code>inline float4 UnityObjectToClipPos(in float3 pos)
{
#if defined(STEREO_CUBEMAP_RENDER_ON)
    return UnityObjectToClipPosODS(pos);
#else
    // More efficient than computing M*VP matrix product
    return mul(UNITY_MATRIX_VP, mul(unity_ObjectToWorld, float4(pos, 1.0)));
#endif
}
inline float4 UnityObjectToClipPos(float4 pos) // overload for float4; avoids &quot;implicit truncation&quot; warning for existing shaders
{
    return UnityObjectToClipPos(pos.xyz);
}

#endif

</code></pre><ul>
<li>UnpackNormal
<ul>
<li>将法线纹理解压成法线（从 [0,1] 映射到 [-1,1] ）</li>
</ul>
</li>
</ul>
<pre tabindex=0><code>inline fixed3 UnpackNormal(fixed4 packednormal)
{
#if defined(UNITY_NO_DXT5nm)
    return packednormal.xyz * 2 - 1;
#elif defined(UNITY_ASTC_NORMALMAP_ENCODING)
    return UnpackNormalDXT5nm(packednormal);
#else
    return UnpackNormalmapRGorAG(packednormal);
#endif
}
</code></pre><h3 id=unityshaderutilitiescginc>UnityShaderUtilities.cginc</h3>
<ul>
<li>UnityWorldToClipPos
<ul>
<li>将坐标从世界空间变换到裁剪空间（UnityShaderUtilities.cginc 中定义）</li>
</ul>
</li>
</ul>
<pre tabindex=0><code>inline float4 UnityWorldToClipPos( in float3 pos )
{
    return mul(UNITY_MATRIX_VP, float4(pos, 1.0));
}
</code></pre><h3 id=unityshadervariablescginc>UnityShaderVariables.cginc</h3>
<ul>
<li>Unity 内置变量</li>
</ul>
<pre tabindex=0><code>// Unity built-in shader source. Copyright (c) 2016 Unity Technologies. MIT license (see license.txt)

#ifndef UNITY_SHADER_VARIABLES_INCLUDED
#define UNITY_SHADER_VARIABLES_INCLUDED

#include &quot;HLSLSupport.cginc&quot;

#if defined (DIRECTIONAL_COOKIE) || defined (DIRECTIONAL)
#define USING_DIRECTIONAL_LIGHT
#endif

#if defined(UNITY_SINGLE_PASS_STEREO) || defined(UNITY_STEREO_INSTANCING_ENABLED) || defined(UNITY_STEREO_MULTIVIEW_ENABLED)
#define USING_STEREO_MATRICES
#endif

#if defined(USING_STEREO_MATRICES)
    #define glstate_matrix_projection unity_StereoMatrixP[unity_StereoEyeIndex]
    #define unity_MatrixV unity_StereoMatrixV[unity_StereoEyeIndex]
    #define unity_MatrixInvV unity_StereoMatrixInvV[unity_StereoEyeIndex]
    #define unity_MatrixVP unity_StereoMatrixVP[unity_StereoEyeIndex]

    #define unity_CameraProjection unity_StereoCameraProjection[unity_StereoEyeIndex]
    #define unity_CameraInvProjection unity_StereoCameraInvProjection[unity_StereoEyeIndex]
    #define unity_WorldToCamera unity_StereoWorldToCamera[unity_StereoEyeIndex]
    #define unity_CameraToWorld unity_StereoCameraToWorld[unity_StereoEyeIndex]
    #define _WorldSpaceCameraPos unity_StereoWorldSpaceCameraPos[unity_StereoEyeIndex]
#endif

#define UNITY_MATRIX_P glstate_matrix_projection
#define UNITY_MATRIX_V unity_MatrixV
#define UNITY_MATRIX_I_V unity_MatrixInvV
#define UNITY_MATRIX_VP unity_MatrixVP
#define UNITY_MATRIX_M unity_ObjectToWorld

#define UNITY_LIGHTMODEL_AMBIENT (glstate_lightmodel_ambient * 2)

// ----------------------------------------------------------------------------


CBUFFER_START(UnityPerCamera)
    // Time (t = time since current level load) values from Unity
    float4 _Time; // (t/20, t, t*2, t*3)
    float4 _SinTime; // sin(t/8), sin(t/4), sin(t/2), sin(t)
    float4 _CosTime; // cos(t/8), cos(t/4), cos(t/2), cos(t)
    float4 unity_DeltaTime; // dt, 1/dt, smoothdt, 1/smoothdt

#if !defined(USING_STEREO_MATRICES)
    float3 _WorldSpaceCameraPos;
#endif

    // x = 1 or -1 (-1 if projection is flipped)
    // y = near plane
    // z = far plane
    // w = 1/far plane
    float4 _ProjectionParams;

    // x = width
    // y = height
    // z = 1 + 1.0/width
    // w = 1 + 1.0/height
    float4 _ScreenParams;

    // Values used to linearize the Z buffer (http://www.humus.name/temp/Linearize%20depth.txt)
    // x = 1-far/near
    // y = far/near
    // z = x/far
    // w = y/far
    // or in case of a reversed depth buffer (UNITY_REVERSED_Z is 1)
    // x = -1+far/near
    // y = 1
    // z = x/far
    // w = 1/far
    float4 _ZBufferParams;

    // x = orthographic camera's width
    // y = orthographic camera's height
    // z = unused
    // w = 1.0 if camera is ortho, 0.0 if perspective
    float4 unity_OrthoParams;
#if defined(STEREO_CUBEMAP_RENDER_ON)
    //x-component is the half stereo separation value, which a positive for right eye and negative for left eye. The y,z,w components are unused.
    float4 unity_HalfStereoSeparation;
#endif
CBUFFER_END


CBUFFER_START(UnityPerCameraRare)
    float4 unity_CameraWorldClipPlanes[6];

#if !defined(USING_STEREO_MATRICES)
    // Projection matrices of the camera. Note that this might be different from projection matrix
    // that is set right now, e.g. while rendering shadows the matrices below are still the projection
    // of original camera.
    float4x4 unity_CameraProjection;
    float4x4 unity_CameraInvProjection;
    float4x4 unity_WorldToCamera;
    float4x4 unity_CameraToWorld;
#endif
CBUFFER_END



// ----------------------------------------------------------------------------

CBUFFER_START(UnityLighting)

    #ifdef USING_DIRECTIONAL_LIGHT
    half4 _WorldSpaceLightPos0;
    #else
    float4 _WorldSpaceLightPos0;
    #endif

    float4 _LightPositionRange; // xyz = pos, w = 1/range
    float4 _LightProjectionParams; // for point light projection: x = zfar / (znear - zfar), y = (znear * zfar) / (znear - zfar), z=shadow bias, w=shadow scale bias

    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    half4 unity_4LightAtten0;

    half4 unity_LightColor[8];


    float4 unity_LightPosition[8]; // view-space vertex light positions (position,1), or (-direction,0) for directional lights.
    // x = cos(spotAngle/2) or -1 for non-spot
    // y = 1/cos(spotAngle/4) or 1 for non-spot
    // z = quadratic attenuation
    // w = range*range
    half4 unity_LightAtten[8];
    float4 unity_SpotDirection[8]; // view-space spot light directions, or (0,0,1,0) for non-spot

    // SH lighting environment
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;

    // part of Light because it can be used outside of shadow distance
    fixed4 unity_OcclusionMaskSelector;
    fixed4 unity_ProbesOcclusion;
CBUFFER_END

CBUFFER_START(UnityLightingOld)
    half3 unity_LightColor0, unity_LightColor1, unity_LightColor2, unity_LightColor3; // keeping those only for any existing shaders; remove in 4.0
CBUFFER_END


// ----------------------------------------------------------------------------

CBUFFER_START(UnityShadows)
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4x4 unity_WorldToShadow[4];
    half4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
CBUFFER_END

// ----------------------------------------------------------------------------

CBUFFER_START(UnityPerDraw)
    float4x4 unity_ObjectToWorld;
    float4x4 unity_WorldToObject;
    float4 unity_LODFade; // x is the fade value ranging within [0,1]. y is x quantized into 16 levels
    float4 unity_WorldTransformParams; // w is usually 1.0, or -1.0 for odd-negative scale transforms
    float4 unity_RenderingLayer;
CBUFFER_END

#if defined(USING_STEREO_MATRICES)
GLOBAL_CBUFFER_START(UnityStereoGlobals)
    float4x4 unity_StereoMatrixP[2];
    float4x4 unity_StereoMatrixV[2];
    float4x4 unity_StereoMatrixInvV[2];
    float4x4 unity_StereoMatrixVP[2];

    float4x4 unity_StereoCameraProjection[2];
    float4x4 unity_StereoCameraInvProjection[2];
    float4x4 unity_StereoWorldToCamera[2];
    float4x4 unity_StereoCameraToWorld[2];

    float3 unity_StereoWorldSpaceCameraPos[2];
    float4 unity_StereoScaleOffset[2];
GLOBAL_CBUFFER_END
#endif

#if defined(USING_STEREO_MATRICES) &amp;&amp; defined(UNITY_STEREO_MULTIVIEW_ENABLED)
GLOBAL_CBUFFER_START(UnityStereoEyeIndices)
    float4 unity_StereoEyeIndices[2];
GLOBAL_CBUFFER_END
#endif

#if defined(UNITY_STEREO_MULTIVIEW_ENABLED) &amp;&amp; defined(SHADER_STAGE_VERTEX)
    #define unity_StereoEyeIndex UNITY_VIEWID
    UNITY_DECLARE_MULTIVIEW(2);
#elif defined(UNITY_STEREO_INSTANCING_ENABLED) || defined(UNITY_STEREO_MULTIVIEW_ENABLED)
    static uint unity_StereoEyeIndex;
#elif defined(UNITY_SINGLE_PASS_STEREO)
    GLOBAL_CBUFFER_START(UnityStereoEyeIndex)
        int unity_StereoEyeIndex;
    GLOBAL_CBUFFER_END
#endif

CBUFFER_START(UnityPerDrawRare)
    float4x4 glstate_matrix_transpose_modelview0;
CBUFFER_END


// ----------------------------------------------------------------------------

CBUFFER_START(UnityPerFrame)

    fixed4 glstate_lightmodel_ambient;
    fixed4 unity_AmbientSky;
    fixed4 unity_AmbientEquator;
    fixed4 unity_AmbientGround;
    fixed4 unity_IndirectSpecColor;

#if !defined(USING_STEREO_MATRICES)
    float4x4 glstate_matrix_projection;
    float4x4 unity_MatrixV;
    float4x4 unity_MatrixInvV;
    float4x4 unity_MatrixVP;
    int unity_StereoEyeIndex;
#endif

    fixed4 unity_ShadowColor;
CBUFFER_END


// ----------------------------------------------------------------------------

CBUFFER_START(UnityFog)
    fixed4 unity_FogColor;
    // x = density / sqrt(ln(2)), useful for Exp2 mode
    // y = density / ln(2), useful for Exp mode
    // z = -1/(end-start), useful for Linear mode
    // w = end/(end-start), useful for Linear mode
    float4 unity_FogParams;
CBUFFER_END


// ----------------------------------------------------------------------------
// Lightmaps

// Main lightmap
UNITY_DECLARE_TEX2D_HALF(unity_Lightmap);
// Directional lightmap (always used with unity_Lightmap, so can share sampler)
UNITY_DECLARE_TEX2D_NOSAMPLER_HALF(unity_LightmapInd);
// Shadowmasks
UNITY_DECLARE_TEX2D(unity_ShadowMask);

// Dynamic GI lightmap
UNITY_DECLARE_TEX2D(unity_DynamicLightmap);
UNITY_DECLARE_TEX2D_NOSAMPLER(unity_DynamicDirectionality);
UNITY_DECLARE_TEX2D_NOSAMPLER(unity_DynamicNormal);

CBUFFER_START(UnityLightmaps)
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
CBUFFER_END


// ----------------------------------------------------------------------------
// Reflection Probes

UNITY_DECLARE_TEXCUBE(unity_SpecCube0);
UNITY_DECLARE_TEXCUBE_NOSAMPLER(unity_SpecCube1);

CBUFFER_START(UnityReflectionProbes)
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    half4  unity_SpecCube0_HDR;

    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    half4  unity_SpecCube1_HDR;
CBUFFER_END


// ----------------------------------------------------------------------------
// Light Probe Proxy Volume

// UNITY_LIGHT_PROBE_PROXY_VOLUME is used as a shader keyword coming from tier settings and may be also disabled with nolppv pragma.
// We need to convert it to 0/1 and doing a second check for safety.
#ifdef UNITY_LIGHT_PROBE_PROXY_VOLUME
    #undef UNITY_LIGHT_PROBE_PROXY_VOLUME
    // Requires quite modern graphics support (3D float textures with filtering)
    // Note: Keep this in synch with the list from LightProbeProxyVolume::HasHardwareSupport &amp;&amp; SurfaceCompiler::IsLPPVAvailableForAnyTargetPlatform
    #if !defined(UNITY_NO_LPPV) &amp;&amp; (defined (SHADER_API_D3D11) || defined (SHADER_API_D3D12) || defined (SHADER_API_GLCORE) || defined (SHADER_API_PSSL) || defined(SHADER_API_VULKAN) || defined(SHADER_API_METAL) || defined(SHADER_API_SWITCH) || defined(SHADER_API_GLES3))
        #define UNITY_LIGHT_PROBE_PROXY_VOLUME 1
    #else
        #define UNITY_LIGHT_PROBE_PROXY_VOLUME 0
    #endif
#else
    #define UNITY_LIGHT_PROBE_PROXY_VOLUME 0
#endif

#if UNITY_LIGHT_PROBE_PROXY_VOLUME
    UNITY_DECLARE_TEX3D_FLOAT(unity_ProbeVolumeSH);

    CBUFFER_START(UnityProbeVolume)
        // x = Disabled(0)/Enabled(1)
        // y = Computation are done in global space(0) or local space(1)
        // z = Texel size on U texture coordinate
        float4 unity_ProbeVolumeParams;

        float4x4 unity_ProbeVolumeWorldToObject;
        float3 unity_ProbeVolumeSizeInv;
        float3 unity_ProbeVolumeMin;
    CBUFFER_END
#endif

static float4x4 unity_MatrixMVP = mul(unity_MatrixVP, unity_ObjectToWorld);
static float4x4 unity_MatrixMV = mul(unity_MatrixV, unity_ObjectToWorld);
static float4x4 unity_MatrixTMV = transpose(unity_MatrixMV);
static float4x4 unity_MatrixITMV = transpose(mul(unity_WorldToObject, unity_MatrixInvV));
// make them macros so that they can be redefined in UnityInstancing.cginc
#define UNITY_MATRIX_MVP    unity_MatrixMVP
#define UNITY_MATRIX_MV     unity_MatrixMV
#define UNITY_MATRIX_T_MV   unity_MatrixTMV
#define UNITY_MATRIX_IT_MV  unity_MatrixITMV

// ----------------------------------------------------------------------------
//  Deprecated

// There used to be fixed function-like texture matrices, defined as UNITY_MATRIX_TEXTUREn. These are gone now; and are just defined to identity.
#define UNITY_MATRIX_TEXTURE0 float4x4(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1)
#define UNITY_MATRIX_TEXTURE1 float4x4(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1)
#define UNITY_MATRIX_TEXTURE2 float4x4(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1)
#define UNITY_MATRIX_TEXTURE3 float4x4(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1)

#endif

</code></pre>
<hr>
<ul class=pager>
<li class=previous>
<a href=/post/unity/optimization/drawcalloptimization/ data-toggle=tooltip data-placement=top title="Unity篇 — Draw Call">&larr;
Previous Post</a>
</li>
<li class=next>
<a href=/post/render/graphics/graphics_shadow/ data-toggle=tooltip data-placement=top title="图形学篇 — 阴影">Next
Post &rarr;</a>
</li>
</ul>
<div id=disqus-comment></div>
</div>
<div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container">
<div class=side-catalog>
<hr class="hidden-sm hidden-xs">
<h5>
<a class=catalog-toggle href=#>CATALOG</a>
</h5>
<ul class=catalog-body></ul>
</div>
</div>
<div class="col-lg-11 col-lg-offset-1
col-md-10 col-md-offset-1
sidebar-container">
</div>
</div>
</div>
</article>
<footer>
<div class=container>
<div class=row>
<div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
<ul class="list-inline text-center">
</ul>
<p class="copyright text-muted">
Copyright &copy; Xun's Blog 2024
<br>
<a href=https://themes.gohugo.io/hugo-theme-cleanwhite>CleanWhite Hugo Theme</a> by <a href=https://zhaohuabing.com>Huabing</a> |
<iframe style=margin-left:2px;margin-bottom:-5px frameborder=0 scrolling=0 width=100px height=20px src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true"></iframe>
</p>
</div>
</div>
</div>
</footer>
<script>function loadAsync(f,b){var c=document,d='script',a=c.createElement(d),e=c.getElementsByTagName(d)[0];a.src=f,b&&a.addEventListener('load',function(a){b(null,a)},!1),e.parentNode.insertBefore(a,e)}</script>
<script>$('#tag_cloud').length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:'#bbbbee',end:'#0085a1'}},$('#tag_cloud a').tagcloud()})</script>
<script>loadAsync("https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.js",function(){var a=document.querySelector("nav");a&&FastClick.attach(a)})</script>
<script type=text/javascript>function generateCatalog(a){_containerSelector='div.post-container';var h=$(_containerSelector),c,d,e,f,g,b;return c=h.find('h1,h2,h3,h4,h5,h6'),$(a).html(''),c.each(function(){d=$(this).prop('tagName').toLowerCase(),g="#"+$(this).prop('id'),e=$(this).text(),b=$('<a href="'+g+'" rel="nofollow">'+e+'</a>'),f=$('<li class="'+d+'_nav"></li>').append(b),$(a).append(f)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(a){a.preventDefault(),$('.side-catalog').toggleClass("fold")}),loadAsync("/js/jquery.nav.js",function(){$('.catalog-body').onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script>
</body>
</html>
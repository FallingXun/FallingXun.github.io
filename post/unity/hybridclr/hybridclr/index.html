<!doctype html><html lang=zh-cn>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta property="og:site_name" content="Xun's Blog">
<meta property="og:type" content="article">
<meta property="og:image" content="https://fallingxun.github.io//">
<meta property="twitter:image" content="https://fallingxun.github.io//">
<meta name=title content="Unity篇 — HybridCLR 热更新">
<meta property="og:title" content="Unity篇 — HybridCLR 热更新">
<meta property="twitter:title" content="Unity篇 — HybridCLR 热更新">
<meta name=description content>
<meta property="og:description" content>
<meta property="twitter:description" content>
<meta property="twitter:card" content="summary">
<meta name=keyword content>
<link rel="shortcut icon" href=/img/favicon.ico>
<title>Unity篇 — HybridCLR 热更新-</title>
<link rel=canonical href=/post/unity/hybridclr/hybridclr/>
<link rel=stylesheet href=/css/iDisqus.min.css>
<link rel=stylesheet href=/css/bootstrap.min.css>
<link rel=stylesheet href=/css/hugo-theme-cleanwhite.min.css>
<link rel=stylesheet href=/css/zanshang.css>
<link href=//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css rel=stylesheet type=text/css>
<script src=/js/jquery.min.js></script>
<script src=/js/bootstrap.min.js></script>
<script src=/js/hux-blog.min.js></script>
</head>
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
<div class=container-fluid>
<div class="navbar-header page-scroll">
<button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=/>Xun's Blog</a>
</div>
<div id=huxblog_navbar>
<div class=navbar-collapse>
<ul class="nav navbar-nav navbar-right">
<li>
<a href=/>Home</a>
</li>
<li>
<a href=/categories/googleplay%E7%B3%BB%E5%88%97>googleplay系列</a>
</li>
<li>
<a href=/categories/lua%E7%B3%BB%E5%88%97>lua系列</a>
</li>
<li>
<a href=/categories/tmp%E7%B3%BB%E5%88%97>tmp系列</a>
</li>
<li>
<a href=/categories/unity%E7%B3%BB%E5%88%97>unity系列</a>
</li>
<li>
<a href=/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%B3%BB%E5%88%97>图形学系列</a>
</li>
<li>
<a href=/categories/%E6%B8%B2%E6%9F%93%E7%B3%BB%E5%88%97>渲染系列</a>
</li>
<li>
<a href=/categories/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97>算法系列</a>
</li>
</ul>
</div>
</div>
</div>
</nav>
<script>var $body=document.body,$toggle=document.querySelector('.navbar-toggle'),$navbar=document.querySelector('#huxblog_navbar'),$collapse=document.querySelector('.navbar-collapse');$toggle.addEventListener('click',handleMagic);function handleMagic(a){$navbar.className.indexOf('in')>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf('in')<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script>
<style type=text/css>header.intro-header{background-image:url('/')}</style>
<header class=intro-header>
<div class=container>
<div class=row>
<div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
<div class=post-heading>
<div class=tags>
<a class=tag href=/tags/hybridclr title=HybridCLR>
HybridCLR
</a>
<a class=tag href=/tags/%E7%83%AD%E6%9B%B4%E6%96%B0 title=热更新>
热更新
</a>
</div>
<h1>Unity篇 — HybridCLR 热更新</h1>
<h2 class=subheading></h2>
<span class=meta>
Posted by
Xun
on
Sunday, January 29, 2023
</span>
</div>
</div>
</div>
</div>
</header>
<article>
<div class=container>
<div class=row>
<div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container">
<p>HybridCLR 是近些年新出的热热更方案。相较于 Lua ，HybridCLR 是基于 C# 的热更新方案，在 Unity 中使用可以获得使用纯 C# 语言的便利性。</p>
<h2 id=基础概念>基础概念</h2>
<ul>
<li>在了解 HybridCLR 之前，需要了解一些程序编译执行相关的基础概念，才能更加清楚地理解框架的原理。</li>
</ul>
<h3 id=clicommon-language-infrastructure>CLI（Common Language Infrastructure）</h3>
<ul>
<li>通用语言架构，是一个开放的技术规范，它为跨平台和跨语言的软件开发提供了一个统一的框架。</li>
</ul>
<h3 id=ilintermediate-language>IL（Intermediate Language）</h3>
<ul>
<li>中间语言，也被称为 MSIL（Microsoft Intermediate Language）或 CIL（Common Intermediate Language），是一种低级的、面向堆栈的编程语言，由高级语言（如 C#、VB.NET 等）编译而成。</li>
</ul>
<h3 id=clrcommon-language-runtime>CLR（Common Language Runtime）</h3>
<ul>
<li>公共语言运行时，是一个执行环境，负责管理 .NET 程序的执行。通过即时编译（JIT）技术，将 IL 代码在运行时转换为特定平台的本地机器码，从而实现跨平台性，并提供了垃圾回收机制来自动回收不再使用的内存，从而减少内存泄漏的可能性。</li>
</ul>
<h3 id=jitjust-in-time-compilation>JIT（Just-In-Time Compilation）</h3>
<ul>
<li>即时编译，也称为动态翻译或运行时编译，是一种执行计算机代码的方法，这种方法设计在程序执行过程中而不是在执行之前进行编译。通常，这包括源代码或更常见的字节码到机器码的转换，然后直接执行。实现 JIT 编译器的系统通常会不断地分析正在执行的代码，并确定代码中可被即时编译加速的部分，在这些部分中，由编译或重新编译带来的性能提高将超过编译该代码的开销。</li>
<li>JIT 编译是两种传统的机器代码翻译方法（提前编译、解释器）的结合，它结合了两者的优点和缺点。大致来说，JIT编译，通过解释器的开销以及编译和链接（解释之外）的开销，结合了编译代码的速度与解释的灵活性。JIT 编译是动态编译的一种形式，允许自适应优化，比如动态重编译和特定于微架构的加速。因此，在理论上，JIT 编译比静态编译能够产生更快的执行速度。解释和 JIT 编译特别适合于动态编程语言，因为运行时系统可以处理后期绑定的数据类型并实施安全保证。</li>
</ul>
<h3 id=aotahead-of-time-compilation>AOT（Ahead-Of-Time Compilation）</h3>
<ul>
<li>提前编译，通常是在执行程序之前（构建时），将高级编程语言编译为低级语言的行为，以减少运行时需要执行的工作量。它通常与将高级编程语言（例如 C 或 C++）或中间表示（例如 Java 字节码或通用中间语言 CIL 代码）编译为原生代码，以便生成的二进制文件可以像标准编译器一样执行。在这种情况下使用时，它通常被视为即时(JIT) 编译的对立面。</li>
</ul>
<h3 id=mono>Mono</h3>
<ul>
<li>Mono 是一种由 Xamarin 公司开发的开源项目，它包含了一个 C# 语言的编译器及代码运行引擎，可将 ECMA CIL 字节码转换为原生代码，使得开发者可以在Linux、Mac OS X、Windows等不同操作系统上编写 .NET 应用程序。在 Unity中，Mono 可以将 C# 代码编译成中间语言（IL，Intermediate Language），然后通过 Mono VM 解释执行，如图所示：
<img src="/img/Unity/HybridCLR/HybridCLR_1.png?raw=true" alt=HybridCLR_1.png>
</li>
<li>代码生成器有三种模式：
<ul>
<li>即时编译（JIT）：运行时会在代码运行时将 ECMA CIL 字节码转换为原生代码。</li>
<li>提前编译（AOT）：此代码转换 ECMA CIL 字节码（通常位于 .exe 或 .dll 文件中）并生成存储在操作系统、体系结构和 CPU 特定文件中的原生代码。此操作模式编译了通常在运行时完成的大部分代码，但有一些例外，例如 trampolines 和其他管理代码，仍然需要 JIT 才能运行，因此 AOT 映像并非完全独立。</li>
<li>完全提前编译（Full AOT）：某些平台（例如 iPhone）使用技术或法律手段禁止 JIT 代码。这对于 Mono 运行时来说是一个重大问题，因为它使用 JIT 或更多低级代码生成宏动态生成大量代码。为了解决这个问题，AOT 编译器能够在 Full AOT 或 Only AOT 模式下运行，在这种模式下，它会生成并保存 AOT 映像中的所有必要代码，因此在运行时无需生成任何代码。有两种类型的代码需要注意：
<ul>
<li>wrapper 方法，其 IL 代码是运行时通过在 <code>add_wrappers()</code> 方法中动态生成，然后作为额外方法通知并执行。</li>
<li>trampolines 和其他小型手动生成的代码片段，在 <code>emit_trampolines()</code> 方法中以临时方式处理。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id=il2cpp>IL2CPP</h3>
<ul>
<li>然而，由于存在一些困难，Unity 后续改为使用 IL2CPP 方案（过渡），主要原因如下：
<ul>
<li>VM 维护成本高。为了实现跨平台，Mono 要为每一个平台实现 VM ，并且随 Unity 版本升级，还要持续不断更新，工作量非常大。</li>
<li>Mono 版权受限。尽管 Mono 是开源项目，但是商用版有一定的版权限制，而低版本的 Mono 不能使用 C# 的很多新特性，因此只能一直使用低版本。</li>
<li>ARM64 不支持。在以前，Mono arm64 AOT 引擎和运行模块不是开源的，并且 Unity 没有使用它们的适当许可证(<a href=https://discussions.unity.com/t/why-doesnt-mono-support-arm64/187302>引自 Unity 问答</a>)。</li>
<li>IL2CPP 运行效率高。根据 <a href="https://www.youtube.com/watch?v=Bfa9ILwlsFw">Unite 2014</a> 官方实验数据，以 Mono 32 和 IL2CPP 64 对比，在 Windows 下，执行耗时降低了 45.6% ，在 OSX 下耗时降低了 58.2% 。
<ul>
<li>
<img src="/img/Unity/HybridCLR/HybridCLR_3.png?raw=true" alt=HybridCLR_3.png>
</li>
<li>
<img src="/img/Unity/HybridCLR/HybridCLR_4.png?raw=true" alt=HybridCLR_4.png>
</li>
</ul>
</li>
</ul>
</li>
<li>作为 Mono 的替代方案，IL2CPP 的执行流程如图所示：
<img src="/img/Unity/HybridCLR/HybridCLR_2.png?raw=true" alt=HybridCLR_2.png>
</li>
<li>Mono 将 IL 代码放到 Mono VM 下解释执行，而 IL2CPP 则是修改了后续的步骤，将 IL 代码，经过 IL2CPP 将 IL 代码转成 C++ 代码，再由各个平台的 C++ 编译器编译成可执行的原生汇编代码，由 IL2CPP VM 执行。其中，IL2CPP VM 和 Mono VM 不同，不会执行 IL 加载和动态解析的工作，主要提供 GC 管理等工作，保持 C# 原来的内存管理方式。</li>
</ul>
<h2 id=unity-执行流程>Unity 执行流程</h2>
<h3 id=初始化>初始化</h3>
<ul>
<li>Unity 启动时，会执行 <code>il2cpp::vm::Runtime::Init</code> 方法，初始化 il2cpp 虚拟机，初始化代码如下：</li>
</ul>
<pre tabindex=0><code>// libil2cpp/vm/Runtime.cpp
...

    bool Runtime::Init(const char* domainName)
    {
        os::FastAutoLock lock(&amp;s_InitLock);

        IL2CPP_ASSERT(s_RuntimeInitCount &gt;= 0);
        if (s_RuntimeInitCount++ &gt; 0)
            return true;

        SanityChecks();

        os::Initialize();
        os::Locale::Initialize();
        MetadataAllocInitialize();

        // NOTE(gab): the runtime_version needs to change once we
        // will support multiple runtimes.
        // For now we default to the one used by unity and don't
        // allow the callers to change it.
        s_FrameworkVersion = framework_version_for(&quot;v4.0.30319&quot;);

        os::Image::Initialize();
        os::Thread::Init();

        // This should be filled in by generated code.
        IL2CPP_ASSERT(g_CodegenRegistration != NULL);
        g_CodegenRegistration();

        if (!MetadataCache::Initialize())
        {
            s_RuntimeInitCount--;
            return false;
        }

        Assembly::Initialize();
        gc::GarbageCollector::Initialize();

        // Thread needs GC initialized
        Thread::Initialize();

        // Reflection needs GC initialized
        Reflection::Initialize();

        register_allocator(il2cpp::utils::Memory::Malloc);

        memset(&amp;il2cpp_defaults, 0, sizeof(Il2CppDefaults));

        const Il2CppAssembly* assembly = Assembly::Load(&quot;mscorlib.dll&quot;);

        // It is not possible to use DEFAULTS_INIT_TYPE for managed types for which we have a native struct, if the
        // native struct does not map the complete managed type.
        // Which is the case for: Il2CppThread, Il2CppAppDomain, Il2CppCultureInfo, Il2CppReflectionProperty,
        // Il2CppDateTimeFormatInfo, Il2CppNumberFormatInfo

        il2cpp_defaults.corlib = Assembly::GetImage(assembly);
        DEFAULTS_INIT(object_class, &quot;System&quot;, &quot;Object&quot;);
        DEFAULTS_INIT(void_class, &quot;System&quot;, &quot;Void&quot;);
        DEFAULTS_INIT_TYPE(boolean_class, &quot;System&quot;, &quot;Boolean&quot;, bool);
        DEFAULTS_INIT_TYPE(byte_class, &quot;System&quot;, &quot;Byte&quot;, uint8_t);
        DEFAULTS_INIT_TYPE(sbyte_class, &quot;System&quot;, &quot;SByte&quot;, int8_t);
        DEFAULTS_INIT_TYPE(int16_class, &quot;System&quot;, &quot;Int16&quot;, int16_t);
        DEFAULTS_INIT_TYPE(uint16_class, &quot;System&quot;, &quot;UInt16&quot;, uint16_t);
        DEFAULTS_INIT_TYPE(int32_class, &quot;System&quot;, &quot;Int32&quot;, int32_t);
        DEFAULTS_INIT_TYPE(uint32_class, &quot;System&quot;, &quot;UInt32&quot;, uint32_t);
        DEFAULTS_INIT(uint_class, &quot;System&quot;, &quot;UIntPtr&quot;);
        DEFAULTS_INIT_TYPE(int_class, &quot;System&quot;, &quot;IntPtr&quot;, intptr_t);
        DEFAULTS_INIT_TYPE(int64_class, &quot;System&quot;, &quot;Int64&quot;, int64_t);
        DEFAULTS_INIT_TYPE(uint64_class, &quot;System&quot;, &quot;UInt64&quot;, uint64_t);
        DEFAULTS_INIT_TYPE(single_class, &quot;System&quot;, &quot;Single&quot;, float);
        DEFAULTS_INIT_TYPE(double_class, &quot;System&quot;, &quot;Double&quot;, double);
        DEFAULTS_INIT_TYPE(char_class, &quot;System&quot;, &quot;Char&quot;, Il2CppChar);
        DEFAULTS_INIT(string_class, &quot;System&quot;, &quot;String&quot;);
        DEFAULTS_INIT(enum_class, &quot;System&quot;, &quot;Enum&quot;);
        DEFAULTS_INIT(array_class, &quot;System&quot;, &quot;Array&quot;);
#if !IL2CPP_TINY
        DEFAULTS_INIT_TYPE(delegate_class, &quot;System&quot;, &quot;Delegate&quot;, Il2CppDelegate);
        DEFAULTS_INIT_TYPE(multicastdelegate_class, &quot;System&quot;, &quot;MulticastDelegate&quot;, Il2CppMulticastDelegate);
        DEFAULTS_INIT(asyncresult_class, &quot;System.Runtime.Remoting.Messaging&quot;, &quot;AsyncResult&quot;);
        DEFAULTS_INIT_TYPE(async_call_class, &quot;System&quot;, &quot;MonoAsyncCall&quot;, Il2CppAsyncCall);
        DEFAULTS_INIT(manualresetevent_class, &quot;System.Threading&quot;, &quot;ManualResetEvent&quot;);
#endif // !IL2CPP_TINY
        //DEFAULTS_INIT(typehandle_class, &quot;System&quot;, &quot;RuntimeTypeHandle&quot;);
        //DEFAULTS_INIT(methodhandle_class, &quot;System&quot;, &quot;RuntimeMethodHandle&quot;);
        //DEFAULTS_INIT(fieldhandle_class, &quot;System&quot;, &quot;RuntimeFieldHandle&quot;);
        DEFAULTS_INIT(systemtype_class, &quot;System&quot;, &quot;Type&quot;);
#if !IL2CPP_TINY
        DEFAULTS_INIT_TYPE(monotype_class, &quot;System&quot;, &quot;MonoType&quot;, Il2CppReflectionMonoType);
#endif
        //DEFAULTS_INIT(exception_class, &quot;System&quot;, &quot;Exception&quot;);
        //DEFAULTS_INIT(threadabortexcepXtion_class, &quot;System.Threading&quot;, &quot;ThreadAbortException&quot;);
        DEFAULTS_INIT_TYPE(thread_class, &quot;System.Threading&quot;, &quot;Thread&quot;, Il2CppThread);
        DEFAULTS_INIT_TYPE(internal_thread_class, &quot;System.Threading&quot;, &quot;InternalThread&quot;, Il2CppInternalThread);
        DEFAULTS_INIT_TYPE(runtimetype_class, &quot;System&quot;, &quot;RuntimeType&quot;, Il2CppReflectionRuntimeType);
#if !IL2CPP_TINY
        DEFAULTS_INIT(appdomain_class, &quot;System&quot;, &quot;AppDomain&quot;);
        DEFAULTS_INIT(appdomain_setup_class, &quot;System&quot;, &quot;AppDomainSetup&quot;);
        DEFAULTS_INIT(field_info_class, &quot;System.Reflection&quot;, &quot;FieldInfo&quot;);
        DEFAULTS_INIT(method_info_class, &quot;System.Reflection&quot;, &quot;MethodInfo&quot;);
        DEFAULTS_INIT(property_info_class, &quot;System.Reflection&quot;, &quot;PropertyInfo&quot;);
        DEFAULTS_INIT_TYPE(event_info_class, &quot;System.Reflection&quot;, &quot;EventInfo&quot;, Il2CppReflectionEvent);
        DEFAULTS_INIT_TYPE(mono_event_info_class, &quot;System.Reflection&quot;, &quot;MonoEventInfo&quot;, Il2CppReflectionMonoEventInfo);
        DEFAULTS_INIT_TYPE(stringbuilder_class, &quot;System.Text&quot;, &quot;StringBuilder&quot;, Il2CppStringBuilder);
        DEFAULTS_INIT_TYPE(stack_frame_class, &quot;System.Diagnostics&quot;, &quot;StackFrame&quot;, Il2CppStackFrame);
        DEFAULTS_INIT(stack_trace_class, &quot;System.Diagnostics&quot;, &quot;StackTrace&quot;);
        DEFAULTS_INIT_TYPE(typed_reference_class, &quot;System&quot;, &quot;TypedReference&quot;, Il2CppTypedRef);
#endif
        DEFAULTS_INIT(generic_ilist_class, &quot;System.Collections.Generic&quot;, &quot;IList`1&quot;);
        DEFAULTS_INIT(generic_icollection_class, &quot;System.Collections.Generic&quot;, &quot;ICollection`1&quot;);
        DEFAULTS_INIT(generic_ienumerable_class, &quot;System.Collections.Generic&quot;, &quot;IEnumerable`1&quot;);
        DEFAULTS_INIT(generic_ireadonlylist_class, &quot;System.Collections.Generic&quot;, &quot;IReadOnlyList`1&quot;);
        DEFAULTS_INIT(generic_ireadonlycollection_class, &quot;System.Collections.Generic&quot;, &quot;IReadOnlyCollection`1&quot;);
        DEFAULTS_INIT(generic_nullable_class, &quot;System&quot;, &quot;Nullable`1&quot;);
#if !IL2CPP_TINY
        DEFAULTS_INIT(version, &quot;System&quot;, &quot;Version&quot;);
        DEFAULTS_INIT(culture_info, &quot;System.Globalization&quot;, &quot;CultureInfo&quot;);
        DEFAULTS_INIT_TYPE(assembly_class, &quot;System.Reflection&quot;, &quot;Assembly&quot;, Il2CppReflectionAssembly);
        DEFAULTS_INIT_TYPE(assembly_name_class, &quot;System.Reflection&quot;, &quot;AssemblyName&quot;, Il2CppReflectionAssemblyName);
#endif // !IL2CPP_TINY
        DEFAULTS_INIT_TYPE(mono_assembly_class, &quot;System.Reflection&quot;, &quot;MonoAssembly&quot;, Il2CppReflectionAssembly);
#if !IL2CPP_TINY
        DEFAULTS_INIT_TYPE(mono_field_class, &quot;System.Reflection&quot;, &quot;MonoField&quot;, Il2CppReflectionField);
        DEFAULTS_INIT_TYPE(mono_method_class, &quot;System.Reflection&quot;, &quot;MonoMethod&quot;, Il2CppReflectionMethod);
        DEFAULTS_INIT_TYPE(mono_method_info_class, &quot;System.Reflection&quot;, &quot;MonoMethodInfo&quot;, Il2CppMethodInfo);
        DEFAULTS_INIT_TYPE(mono_property_info_class, &quot;System.Reflection&quot;, &quot;MonoPropertyInfo&quot;, Il2CppPropertyInfo);
        DEFAULTS_INIT_TYPE(parameter_info_class, &quot;System.Reflection&quot;, &quot;ParameterInfo&quot;, Il2CppReflectionParameter);
        DEFAULTS_INIT_TYPE(mono_parameter_info_class, &quot;System.Reflection&quot;, &quot;MonoParameterInfo&quot;, Il2CppReflectionParameter);
        DEFAULTS_INIT_TYPE(module_class, &quot;System.Reflection&quot;, &quot;Module&quot;, Il2CppReflectionModule);

        DEFAULTS_INIT_TYPE(pointer_class, &quot;System.Reflection&quot;, &quot;Pointer&quot;, Il2CppReflectionPointer);
        DEFAULTS_INIT_TYPE(exception_class, &quot;System&quot;, &quot;Exception&quot;, Il2CppException);
        DEFAULTS_INIT_TYPE(system_exception_class, &quot;System&quot;, &quot;SystemException&quot;, Il2CppSystemException);
        DEFAULTS_INIT_TYPE(argument_exception_class, &quot;System&quot;, &quot;ArgumentException&quot;, Il2CppArgumentException);
        DEFAULTS_INIT_TYPE(marshalbyrefobject_class, &quot;System&quot;, &quot;MarshalByRefObject&quot;, Il2CppMarshalByRefObject);
        DEFAULTS_INIT_TYPE(il2cpp_com_object_class, &quot;System&quot;, &quot;__Il2CppComObject&quot;, Il2CppComObject);
        DEFAULTS_INIT_TYPE(safe_handle_class, &quot;System.Runtime.InteropServices&quot;, &quot;SafeHandle&quot;, Il2CppSafeHandle);
        DEFAULTS_INIT_TYPE(sort_key_class, &quot;System.Globalization&quot;, &quot;SortKey&quot;, Il2CppSortKey);
        DEFAULTS_INIT(dbnull_class, &quot;System&quot;, &quot;DBNull&quot;);
        DEFAULTS_INIT_TYPE_OPTIONAL(error_wrapper_class, &quot;System.Runtime.InteropServices&quot;, &quot;ErrorWrapper&quot;, Il2CppErrorWrapper);
        DEFAULTS_INIT(missing_class, &quot;System.Reflection&quot;, &quot;Missing&quot;);
        DEFAULTS_INIT(attribute_class, &quot;System&quot;, &quot;Attribute&quot;);
        DEFAULTS_INIT(customattribute_data_class, &quot;System.Reflection&quot;, &quot;CustomAttributeData&quot;);
        DEFAULTS_INIT(value_type_class, &quot;System&quot;, &quot;ValueType&quot;);
        DEFAULTS_INIT(key_value_pair_class, &quot;System.Collections.Generic&quot;, &quot;KeyValuePair`2&quot;);
        DEFAULTS_INIT(system_guid_class, &quot;System&quot;, &quot;Guid&quot;);
#endif // !IL2CPP_TINY

#if !IL2CPP_TINY
        DEFAULTS_INIT(threadpool_wait_callback_class, &quot;System.Threading&quot;, &quot;_ThreadPoolWaitCallback&quot;);
        DEFAULTS_INIT(mono_method_message_class, &quot;System.Runtime.Remoting.Messaging&quot;, &quot;MonoMethodMessage&quot;);

        il2cpp_defaults.threadpool_perform_wait_callback_method = (MethodInfo*)vm::Class::GetMethodFromName(
            il2cpp_defaults.threadpool_wait_callback_class, &quot;PerformWaitCallback&quot;, 0);
#endif

        DEFAULTS_INIT_OPTIONAL(sbyte_shared_enum, &quot;System&quot;, &quot;SByteEnum&quot;);
        DEFAULTS_INIT_OPTIONAL(int16_shared_enum, &quot;System&quot;, &quot;Int16Enum&quot;);
        DEFAULTS_INIT_OPTIONAL(int32_shared_enum, &quot;System&quot;, &quot;Int32Enum&quot;);
        DEFAULTS_INIT_OPTIONAL(int64_shared_enum, &quot;System&quot;, &quot;Int64Enum&quot;);

        DEFAULTS_INIT_OPTIONAL(byte_shared_enum, &quot;System&quot;, &quot;ByteEnum&quot;);
        DEFAULTS_INIT_OPTIONAL(uint16_shared_enum, &quot;System&quot;, &quot;UInt16Enum&quot;);
        DEFAULTS_INIT_OPTIONAL(uint32_shared_enum, &quot;System&quot;, &quot;UInt32Enum&quot;);
        DEFAULTS_INIT_OPTIONAL(uint64_shared_enum, &quot;System&quot;, &quot;UInt64Enum&quot;);

        Image::InitNestedTypes(il2cpp_defaults.corlib);

        const Il2CppAssembly* systemDll = Assembly::Load(&quot;System&quot;);
        if (systemDll != NULL)
            il2cpp_defaults.system_uri_class = Class::FromName(Assembly::GetImage(systemDll), &quot;System&quot;, &quot;Uri&quot;);

        // This will only exist if there was at least 1 winmd file present during conversion
        const Il2CppAssembly* windowsRuntimeMetadataAssembly = Assembly::Load(&quot;WindowsRuntimeMetadata&quot;);
        if (windowsRuntimeMetadataAssembly != NULL)
        {
            const Il2CppImage* windowsRuntimeMetadataImage = Assembly::GetImage(windowsRuntimeMetadataAssembly);
            il2cpp_defaults.ireference_class = Class::FromName(windowsRuntimeMetadataImage, &quot;Windows.Foundation&quot;, &quot;IReference`1&quot;);
            il2cpp_defaults.ireferencearray_class = Class::FromName(windowsRuntimeMetadataImage, &quot;Windows.Foundation&quot;, &quot;IReferenceArray`1&quot;);
            il2cpp_defaults.ikey_value_pair_class = Class::FromName(windowsRuntimeMetadataImage, &quot;Windows.Foundation.Collections&quot;, &quot;IKeyValuePair`2&quot;);
            il2cpp_defaults.ikey_value_pair_class = Class::FromName(windowsRuntimeMetadataImage, &quot;Windows.Foundation.Collections&quot;, &quot;IKeyValuePair`2&quot;);
            il2cpp_defaults.windows_foundation_uri_class = Class::FromName(windowsRuntimeMetadataImage, &quot;Windows.Foundation&quot;, &quot;Uri&quot;);
            il2cpp_defaults.windows_foundation_iuri_runtime_class_class = Class::FromName(windowsRuntimeMetadataImage, &quot;Windows.Foundation&quot;, &quot;IUriRuntimeClass&quot;);
        }

        Class::Init(il2cpp_defaults.string_class);

        os::Socket::Startup();

#if IL2CPP_MONO_DEBUGGER
        il2cpp::utils::Debugger::Init();
#endif

        Il2CppDomain* domain = Domain::GetCurrent();

        Il2CppThread* mainThread = Thread::Attach(domain);
        Thread::SetMain(mainThread);

#if !IL2CPP_TINY
        Il2CppAppDomainSetup* setup = (Il2CppAppDomainSetup*)Object::NewPinned(il2cpp_defaults.appdomain_setup_class);

        Il2CppAppDomain* ad = (Il2CppAppDomain*)Object::NewPinned(il2cpp_defaults.appdomain_class);
        gc::WriteBarrier::GenericStore(&amp;ad-&gt;data, domain);
        gc::WriteBarrier::GenericStore(&amp;domain-&gt;domain, ad);
        gc::WriteBarrier::GenericStore(&amp;domain-&gt;setup, setup);
#endif

        domain-&gt;domain_id = 1; // Only have a single domain ATM.

        domain-&gt;friendly_name = basepath(domainName);

        LastError::InitializeLastErrorThreadStatic();

        gc::GarbageCollector::InitializeFinalizer();

        MetadataCache::InitializeGCSafe();

        String::InitializeEmptyString(il2cpp_defaults.string_class);
        InitializeStringEmpty();

        g_il2cpp_is_fully_initialized = true;

        // Force binary serialization in Mono to use reflection instead of code generation.
    #undef SetEnvironmentVariable // Get rid of windows.h #define.
        os::Environment::SetEnvironmentVariable(&quot;MONO_REFLECTION_SERIALIZER&quot;, &quot;yes&quot;);
        os::Environment::SetEnvironmentVariable(&quot;MONO_XMLSERIALIZER_THS&quot;, &quot;no&quot;);

#if !IL2CPP_TINY
        Domain::ContextInit(domain);
        Domain::ContextSet(domain-&gt;default_context);
#endif

        VerifyApiVersion();

#if IL2CPP_MONO_DEBUGGER
        il2cpp::utils::Debugger::Start();
#endif

        std::string executablePath = os::Path::GetExecutablePath();
        SetConfigStr(executablePath);

        if (utils::Environment::GetNumMainArgs() == 0)
        {
            // If main args were never set, we default to 1 arg that is the executable path
            const char* mainArgs[] = { executablePath.c_str() };
            utils::Environment::SetMainArgs(mainArgs, 1);
        }

        vm::MetadataCache::ExecuteEagerStaticClassConstructors();
        vm::MetadataCache::ExecuteModuleInitializers();

        return true;
    }

...
</code></pre><ul>
<li>初始化的内容很多，但主要关心的有几个：
<ul>
<li>代码注册。</li>
<li>初始化 MetadataCache 。</li>
</ul>
</li>
</ul>
<h4 id=代码注册>代码注册</h4>
<ul>
<li><code>g_CodegenRegistration()</code> 会对编译生成的代码内容进行注册，具体逻辑实现在构建后生成的 <code>il2CppCodeRegistration.cpp</code> 中，如下：</li>
</ul>
<pre tabindex=0><code>// Classes/Native/il2CppCodeRegistration.cpp（构建后生成）
void s_Il2CppCodegenRegistration()
{
	il2cpp_codegen_register (&amp;g_CodeRegistration, &amp;g_MetadataRegistration, &amp;s_Il2CppCodeGenOptions);
}
#if RUNTIME_IL2CPP
typedef void (*CodegenRegistrationFunction)();
CodegenRegistrationFunction g_CodegenRegistration = s_Il2CppCodegenRegistration;
#endif

</code></pre><ul>
<li>注册的内容有：
<ul>
<li><code>g_CodeRegistration</code> : 指向 <code>Il2CppCodeRegistration</code> 类型的指针，表示当前注册的代码信息，注册到：
<ul>
<li>il2cpp::vm::GlobalMetadata->s_GlobalMetadata_CodeRegistration</li>
<li>il2cpp::vm::MetadataCache->s_Il2CppCodeRegistration</li>
</ul>
</li>
<li><code>g_MetadataRegistration</code> ：指向 <code>Il2CppMetadataRegistration</code> 类型的指针，表示与代码相关的元数据信息，注册到：
<ul>
<li>il2cpp::vm::GlobalMetadata->s_Il2CppMetadataRegistration</li>
<li>il2cpp::vm::MetadataCache->s_MetadataCache_Il2CppMetadataRegistration</li>
</ul>
</li>
<li><code>s_Il2CppCodeGenOptions</code> ：指向 <code>Il2CppCodeGenOptions</code> 类型的指针，包含代码生成过程中的选项和配置，注册到：
<ul>
<li>il2cpp::vm::MetadataCache->s_Il2CppCodeGenOptions</li>
</ul>
</li>
</ul>
</li>
<li>以 hybridclr 的 Demo 工程为例，构建后的内容如下:</li>
</ul>
<pre tabindex=0><code>// Classes/Native/il2CppCodeRegistration.cpp

IL2CPP_EXTERN_C const Il2CppCodeRegistration g_CodeRegistration;
const Il2CppCodeRegistration g_CodeRegistration = 
{
	1,                                          // uint32_t reversePInvokeWrapperCount;
	g_ReversePInvokeWrapperPointers,            // const Il2CppMethodPointer* reversePInvokeWrappers;
	5880,                                       // uint32_t genericMethodPointersCount;
	g_Il2CppGenericMethodPointers,              // const Il2CppMethodPointer* genericMethodPointers;
	g_Il2CppGenericAdjustorThunks,              // const Il2CppMethodPointer* genericAdjustorThunks;
	1970,                                       // uint32_t invokerPointersCount;
	g_Il2CppInvokerPointers,                    // const InvokerMethod* invokerPointers;
	293,                                        // uint32_t unresolvedVirtualCallCount;
	g_UnresolvedVirtualMethodPointers,          // const Il2CppMethodPointer* unresolvedVirtualCallPointers;
	162,                                        // uint32_t interopDataCount;
	g_Il2CppInteropData,                        // Il2CppInteropData* interopData;
	0,                                          // uint32_t windowsRuntimeFactoryCount;
	NULL,                                       // Il2CppWindowsRuntimeFactoryTableEntry* windowsRuntimeFactoryTable;
	20,                                         // uint32_t codeGenModulesCount;
	g_CodeGenModules,                           // const Il2CppCodeGenModule** codeGenModules;
};
IL2CPP_EXTERN_C_CONST Il2CppMetadataRegistration g_MetadataRegistration;
static const Il2CppCodeGenOptions s_Il2CppCodeGenOptions = 
{
	true,                                       // bool enablePrimitiveValueTypeGenericSharing;
	7,                                          // int maximumRuntimeGenericDepth;
};
</code></pre><pre tabindex=0><code>// Classes/Native/Il2CppMetadataRegistration.c

IL2CPP_EXTERN_C const Il2CppMetadataRegistration g_MetadataRegistration;
const Il2CppMetadataRegistration g_MetadataRegistration = 
{
	973,                                        // int32_t genericClassesCount;
	g_Il2CppGenericTypes,                       // Il2CppGenericClass* const * genericClasses;
	547,                                        // int32_t genericInstsCount;
	g_Il2CppGenericInstTable,                   // const Il2CppGenericInst* const * genericInsts;
	6690,                                       // int32_t genericMethodTableCount;
	g_Il2CppGenericMethodFunctions,             // const Il2CppGenericMethodFunctionsDefinitions* genericMethodTable;
	5600,                                       // int32_t typesCount;
	g_Il2CppTypeTable,                          // const Il2CppType* const * types;
	7228,                                       // int32_t methodSpecsCount;
	g_Il2CppMethodSpecTable,                    // Il2CppMethodSpec* methodSpecs;
	2270,                                       // FieldIndex fieldOffsetsCount;
	g_FieldOffsetTable,                         // const int32_t** fieldOffsets;
	2270,                                       // TypeDefinitionIndex typeDefinitionsSizesCount;
	g_Il2CppTypeDefinitionSizesTable,           // const Il2CppTypeDefinitionSizes** typeDefinitionsSizes;
	0,                                          // const size_t metadataUsagesCount;
	NULL,                                       // void** const* metadataUsages;
};
</code></pre><h4 id=初始化-metadatacache>初始化 MetadataCache</h4>
<ul>
<li>通过 <code>il2cpp::vm::MetadataCache::Initialize</code> <code>=></code> <code>il2cpp::vm::GlobalMetadata::Initialize</code> 方法，加载 <code>global-metadata.dat</code> 文件。<code>global-metadata.dat</code> 文件存储了所有编译后的编译后的 IL 代码所需要的所有信息，包括类型信息、方法信息、字段信息等，解析后以 <code>Il2CppGlobalMetadataHeader</code> 结构使用，其内容如下：</li>
</ul>
<pre tabindex=0><code>// libil2cpp/vm/GlobalMetadataFileInternals.h

typedef struct Il2CppGlobalMetadataHeader
{
    int32_t sanity;
    int32_t version;
    int32_t stringLiteralOffset; // string data for managed code
    int32_t stringLiteralSize;
    int32_t stringLiteralDataOffset;
    int32_t stringLiteralDataSize;
    int32_t stringOffset; // string data for metadata
    int32_t stringSize;
    int32_t eventsOffset; // Il2CppEventDefinition
    int32_t eventsSize;
    int32_t propertiesOffset; // Il2CppPropertyDefinition
    int32_t propertiesSize;
    int32_t methodsOffset; // Il2CppMethodDefinition
    int32_t methodsSize;
    int32_t parameterDefaultValuesOffset; // Il2CppParameterDefaultValue
    int32_t parameterDefaultValuesSize;
    int32_t fieldDefaultValuesOffset; // Il2CppFieldDefaultValue
    int32_t fieldDefaultValuesSize;
    int32_t fieldAndParameterDefaultValueDataOffset; // uint8_t
    int32_t fieldAndParameterDefaultValueDataSize;
    int32_t fieldMarshaledSizesOffset; // Il2CppFieldMarshaledSize
    int32_t fieldMarshaledSizesSize;
    int32_t parametersOffset; // Il2CppParameterDefinition
    int32_t parametersSize;
    int32_t fieldsOffset; // Il2CppFieldDefinition
    int32_t fieldsSize;
    int32_t genericParametersOffset; // Il2CppGenericParameter
    int32_t genericParametersSize;
    int32_t genericParameterConstraintsOffset; // TypeIndex
    int32_t genericParameterConstraintsSize;
    int32_t genericContainersOffset; // Il2CppGenericContainer
    int32_t genericContainersSize;
    int32_t nestedTypesOffset; // TypeDefinitionIndex
    int32_t nestedTypesSize;
    int32_t interfacesOffset; // TypeIndex
    int32_t interfacesSize;
    int32_t vtableMethodsOffset; // EncodedMethodIndex
    int32_t vtableMethodsSize;
    int32_t interfaceOffsetsOffset; // Il2CppInterfaceOffsetPair
    int32_t interfaceOffsetsSize;
    int32_t typeDefinitionsOffset; // Il2CppTypeDefinition
    int32_t typeDefinitionsSize;
    int32_t imagesOffset; // Il2CppImageDefinition
    int32_t imagesSize;
    int32_t assembliesOffset; // Il2CppAssemblyDefinition
    int32_t assembliesSize;
    int32_t fieldRefsOffset; // Il2CppFieldRef
    int32_t fieldRefsSize;
    int32_t referencedAssembliesOffset; // int32_t
    int32_t referencedAssembliesSize;
    int32_t attributesInfoOffset; // Il2CppCustomAttributeTypeRange
    int32_t attributesInfoSize;
    int32_t attributeTypesOffset; // TypeIndex
    int32_t attributeTypesSize;
    int32_t unresolvedVirtualCallParameterTypesOffset; // TypeIndex
    int32_t unresolvedVirtualCallParameterTypesSize;
    int32_t unresolvedVirtualCallParameterRangesOffset; // Il2CppMetadataRange
    int32_t unresolvedVirtualCallParameterRangesSize;
    int32_t windowsRuntimeTypeNamesOffset; // Il2CppWindowsRuntimeTypeNamePair
    int32_t windowsRuntimeTypeNamesSize;
    int32_t windowsRuntimeStringsOffset; // const char*
    int32_t windowsRuntimeStringsSize;
    int32_t exportedTypeDefinitionsOffset; // TypeDefinitionIndex
    int32_t exportedTypeDefinitionsSize;
} Il2CppGlobalMetadataHeader;
</code></pre><ul>
<li><code>global-metadata.dat</code> 解析完成后，主要执行的操作有：
<ul>
<li>会根据得到的数据，申请各种类型的内存块，如：程序集表、镜像表、类型表、方法表、泛型方法表等。</li>
<li>将 <code>g_MetadataRegistration->genericClasses</code> 存储到 <code>GenericMetadata.s_GenericClassSet</code> 中。</li>
<li>从解析得到的数据中，获取镜像地址，创建镜像对象到 <code>MetadataCache.s_ImagesTable</code> ，绑定对应的程序集，将数据设置到镜像上，并将 <code>g_CodeRegistration->codeGenModules</code> 中对应的模块数据设置到镜像上。</li>
<li>从解析得到的数据中，获取程序集地址，创建程序集对象到 <code>MetadataCache.s_AssembliesTable</code> ，绑定对应的镜像，将程序集注册到 <code>il2cpp::vm.s_Assemblies</code> 中。</li>
</ul>
</li>
<li>hybridclr 的 Demo 工程的模块数据如下：</li>
</ul>
<pre tabindex=0><code>// Classes/Native/il2CppCodeRegistration.cpp

...

IL2CPP_EXTERN_C const Il2CppCodeGenModule* g_CodeGenModules[];
const Il2CppCodeGenModule* g_CodeGenModules[20] = 
{
	(&amp;g_AssemblyU2DCSharp_CodeGenModule),
	(&amp;g_HybridCLR_Runtime_CodeGenModule),
	(&amp;g_Mono_Security_CodeGenModule),
	(&amp;g_System_CodeGenModule),
	(&amp;g_System_Configuration_CodeGenModule),
	(&amp;g_System_Core_CodeGenModule),
	(&amp;g_System_Xml_CodeGenModule),
	(&amp;g_UnityEngine_AssetBundleModule_CodeGenModule),
	(&amp;g_UnityEngine_AudioModule_CodeGenModule),
	(&amp;g_UnityEngine_CodeGenModule),
	(&amp;g_UnityEngine_CoreModule_CodeGenModule),
	(&amp;g_UnityEngine_GameCenterModule_CodeGenModule),
	(&amp;g_UnityEngine_IMGUIModule_CodeGenModule),
	(&amp;g_UnityEngine_InputLegacyModule_CodeGenModule),
	(&amp;g_UnityEngine_SharedInternalsModule_CodeGenModule),
	(&amp;g_UnityEngine_TextRenderingModule_CodeGenModule),
	(&amp;g_UnityEngine_UIModule_CodeGenModule),
	(&amp;g_UnityEngine_UI_CodeGenModule),
	(&amp;g_UnityEngine_UnityWebRequestModule_CodeGenModule),
	(&amp;g_mscorlib_CodeGenModule),
};

...
</code></pre><ul>
<li>以 <code>Assembly-CSharp.dll</code> 为例，每个模块数据以 <code>Il2CppCodeGenModule</code> 结构保存。</li>
</ul>
<pre tabindex=0><code>// Classes/Native/Assembly-CSharp_CodeGen.c 

...

IL2CPP_EXTERN_C const Il2CppCodeGenModule g_AssemblyU2DCSharp_CodeGenModule;
const Il2CppCodeGenModule g_AssemblyU2DCSharp_CodeGenModule = 
{
	&quot;Assembly-CSharp.dll&quot;,                      // const char* moduleName;
	33,                                         // const uint32_t methodPointerCount;
	s_methodPointers,                           // const Il2CppMethodPointer* methodPointers;
	0,                                          // const uint32_t adjustorThunkCount;
	NULL,                                       // const Il2CppTokenAdjustorThunkPair* adjustorThunks;
	s_InvokerIndices,                           // const int32_t* invokerIndices;
	0,                                          // const uint32_t reversePInvokeWrapperCount;
	NULL,                                       // const Il2CppTokenIndexMethodTuple* reversePInvokeWrapperIndices;
	0,                                          // const uint32_t rgctxRangesCount;
	NULL,                                       // const Il2CppTokenRangePair* rgctxRanges;
	0,                                          // const uint32_t rgctxsCount;
	NULL,                                       // const Il2CppRGCTXDefinition* rgctxs;
	NULL,                                       // const Il2CppDebuggerMetadataRegistration *debuggerMetadata;
	g_AssemblyU2DCSharp_AttributeGenerators,    // const CustomAttributesCacheGenerator* customAttributeCacheGenerator;
	NULL, // module initializer,                // const Il2CppMethodPointer moduleInitializer;
	NULL,                                       // TypeDefinitionIndex* staticConstructorTypeIndices;
	NULL,                                       // const Il2CppMetadataRegistration* metadataRegistration; // Per-assembly mode only
	NULL,                                       // const Il2CppCodeRegistration* codeRegistaration; // Per-assembly mode only
};
</code></pre><h3 id=方法调用>方法调用</h3>
<ul>
<li>当调用 C# 的方法时，通过 <code>libiPhone-lib.a(Runtime_ScriptingBackend_Il2Cpp_0.o)</code> 的 <code>scripting_method_invoke(ScriptingMethodPtr, ScriptingObjectPtr, ScriptingArguments&, ScriptingExceptionPtr*, bool)</code> 方法，调用 il2cpp 的 <code>il2cpp_runtime_invoke</code> 方法。</li>
</ul>
<pre tabindex=0><code>// libil2cpp/il2cpp-api.cpp
...

Il2CppObject* il2cpp_runtime_invoke(const MethodInfo *method,
    void *obj, void **params, Il2CppException **exc)
{
    // Our embedding API has historically taken pointers to unboxed value types, rather than Il2CppObjects.
    // However, with the introduction of adjustor thunks, our invokees expect us to pass them Il2CppObject*, or at least something that
    // ressembles boxed value type. Since it's not going to access any of the Il2CppObject* fields,
    // it's fine to just subtract sizeof(Il2CppObject) from obj pointer
    if (method-&gt;klass-&gt;valuetype)
        obj = static_cast&lt;Il2CppObject*&gt;(obj) - 1;

    return Runtime::Invoke(method, obj, params, exc);
}

...
</code></pre><pre tabindex=0><code>// libil2cpp/vm/Runtime.cpp

...

    Il2CppObject* Runtime::Invoke(const MethodInfo *method, void *obj, void **params, Il2CppException **exc)
    {
        if (exc)
            il2cpp::gc::WriteBarrier::GenericStore(exc, NULL);

        // we wrap invoker call in try/catch here, rather than emitting a try/catch
        // in every invoke call as that blows up the code size.
        try
        {
            RaiseExecutionEngineExceptionIfMethodIsNotFound(method);

            if (!Method::IsInstance(method) &amp;&amp; method-&gt;klass &amp;&amp; method-&gt;klass-&gt;has_cctor &amp;&amp; !method-&gt;klass-&gt;cctor_finished)
                ClassInit(method-&gt;klass);

            return (Il2CppObject*)method-&gt;invoker_method(method-&gt;methodPointer, method, obj, params);
        }
        catch (Il2CppExceptionWrapper&amp; ex)
        {
            if (exc)
                il2cpp::gc::WriteBarrier::GenericStore(exc, ex.ex);
            return NULL;
        }
    }

...
</code></pre><ul>
<li>最终通过 <code>MethodInfo</code> 方法对象，来执行对应的方法。需要的信息有：
<ul>
<li><code>MethodInfo->invoker_method</code></li>
<li><code>MethodInfo->methodPointer</code></li>
<li></li>
</ul>
</li>
<li>而 <code>MethodInfo</code> 的信息，需要通过类的初始化得到。对于静态方法，调用的时候，会通过 <code>Runtime::ClassInit</code> 执行类初始化。对于实例方法，则是通过 <code>il2cpp_object_new</code> 方法，在创建实例对象时进行初始化。无论哪种方法，最终都是通过 <code>Class::Init</code> 方法进行初始化。</li>
</ul>
<pre tabindex=0><code>// libil2cpp/vm/Class.cpp
...

    bool Class::Init(Il2CppClass *klass)
    {
        IL2CPP_ASSERT(klass);

        if (!klass-&gt;initialized)
        {
            il2cpp::os::FastAutoLock lock(&amp;g_MetadataLock);
            InitLocked(klass, lock);
        }

        return true;
    }

...

    static bool InitLocked(Il2CppClass *klass, const il2cpp::os::FastAutoLock&amp; lock)
    {
        ...
        
        SetupMethodsLocked(klass, lock);
        ...

        return true;
    }

...
1
    void SetupMethodsLocked(Il2CppClass *klass, const il2cpp::os::FastAutoLock&amp; lock)
    {
        if ((!klass-&gt;method_count &amp;&amp; !klass-&gt;rank) || klass-&gt;methods)
            return;

        if (klass-&gt;generic_class)
        {
            InitLocked(GenericClass::GetTypeDefinition(klass-&gt;generic_class), lock);
            GenericClass::SetupMethods(klass);
        }
        else if (klass-&gt;rank)
        {
            InitLocked(klass-&gt;element_class, lock);
            SetupVTable(klass, lock);
        }
        else
        {
            if (klass-&gt;method_count == 0)
            {
                klass-&gt;methods = NULL;
                return;
            }

            klass-&gt;methods = (const MethodInfo**)MetadataCalloc(klass-&gt;method_count, sizeof(MethodInfo*));
            MethodInfo* methods = (MethodInfo*)MetadataCalloc(klass-&gt;method_count, sizeof(MethodInfo));
            MethodInfo* newMethod = methods;

            MethodIndex end = klass-&gt;method_count;

            for (MethodIndex index = 0; index &lt; end; ++index)
            {
                Il2CppMetadataMethodInfo methodInfo = MetadataCache::GetMethodInfo(klass, index);

                newMethod-&gt;name = methodInfo.name;

                if (klass-&gt;valuetype)
                {
                    Il2CppMethodPointer adjustorThunk = MetadataCache::GetAdjustorThunk(klass-&gt;image, methodInfo.token);
                    if (adjustorThunk != NULL)
                        newMethod-&gt;methodPointer = adjustorThunk;
                }

                // We did not find an adjustor thunk, or maybe did not need to look for one. Let's get the real method pointer.
                if (newMethod-&gt;methodPointer == NULL)
                    newMethod-&gt;methodPointer = MetadataCache::GetMethodPointer(klass-&gt;image, methodInfo.token);

                newMethod-&gt;invoker_method = MetadataCache::GetMethodInvoker(klass-&gt;image, methodInfo.token);

                newMethod-&gt;klass = klass;
                newMethod-&gt;return_type = methodInfo.return_type;

                newMethod-&gt;parameters_count = (uint8_t)methodInfo.parameterCount;

                ParameterInfo* parameters = (ParameterInfo*)MetadataCalloc(methodInfo.parameterCount, sizeof(ParameterInfo));
                ParameterInfo* newParameter = parameters;
                for (uint16_t paramIndex = 0; paramIndex &lt; methodInfo.parameterCount; ++paramIndex)
                {
                    Il2CppMetadataParameterInfo paramInfo = MetadataCache::GetParameterInfo(klass, methodInfo.handle, paramIndex);
                    newParameter-&gt;name = paramInfo.name;
                    newParameter-&gt;position = paramIndex;
                    newParameter-&gt;token = paramInfo.token;
                    newParameter-&gt;parameter_type = paramInfo.type;

                    newParameter++;
                }
                newMethod-&gt;parameters = parameters;

                newMethod-&gt;flags = methodInfo.flags;
                newMethod-&gt;iflags = methodInfo.iflags;
                newMethod-&gt;slot = methodInfo.slot;
                newMethod-&gt;is_inflated = false;
                newMethod-&gt;token = methodInfo.token;
                newMethod-&gt;methodMetadataHandle = methodInfo.handle;
                newMethod-&gt;genericContainerHandle = MetadataCache::GetGenericContainerFromMethod(methodInfo.handle);
                if (newMethod-&gt;genericContainerHandle)
                    newMethod-&gt;is_generic = true;

                klass-&gt;methods[index] = newMethod;

                newMethod++;
            }
        }
    }

...
</code></pre><pre tabindex=0><code>// libil2cpp/vm/MetadataCache.cpp
...

Il2CppMethodPointer il2cpp::vm::MetadataCache::GetMethodPointer(const Il2CppImage* image, uint32_t token)
{
    uint32_t rid = GetTokenRowId(token);
    uint32_t table =  GetTokenType(token);
    if (rid == 0)
        return NULL;

    IL2CPP_ASSERT(rid &lt;= image-&gt;codeGenModule-&gt;methodPointerCount);

    return image-&gt;codeGenModule-&gt;methodPointers[rid - 1];
}

InvokerMethod il2cpp::vm::MetadataCache::GetMethodInvoker(const Il2CppImage* image, uint32_t token)
{
    uint32_t rid = GetTokenRowId(token);
    uint32_t table = GetTokenType(token);
    if (rid == 0)
        return NULL;

    int32_t index = image-&gt;codeGenModule-&gt;invokerIndices[rid - 1];

    if (index == kMethodIndexInvalid)
        return NULL;

    IL2CPP_ASSERT(index &gt;= 0 &amp;&amp; static_cast&lt;uint32_t&gt;(index) &lt; s_Il2CppCodeRegistration-&gt;invokerPointersCount);
    return s_Il2CppCodeRegistration-&gt;invokerPointers[index];
}

...
</code></pre><ul>
<li>可以看到，<code>invoker_method</code> 使用的是 <code>g_CodeRegistration</code> 中的 <code>g_Il2CppInvokerPointers</code> ，<code>methodPointer</code> 使用的是 <code>g_CodeRegistration</code> 的 <code>g_CodeGenModules</code> 中对应模块的 <code>s_methodPointers</code>。以 <code>LoadDll.cs</code> 的 <code>Start</code> 方法为例，C# 代码如下：</li>
</ul>
<pre tabindex=0><code>...
// Assets/Main/LoadDll.cs
...

public class LoadDll : MonoBehaviour
{

    void Start()
    {
        StartCoroutine(DownLoadAssets(this.StartGame));
    }

    ...
}

</code></pre><ul>
<li>构建后生成的代码如下：</li>
</ul>
<pre tabindex=0><code>// Classes/Native/Assembly-CSharp_CodeGen.c
...

// C# LoadDll.Start 方法的 methodPointer
// 0x0000000A System.Void LoadDll::Start()
extern void LoadDll_Start_mDFFD4CEFDDC803966E45E8D7D915007650963687 (void);

...

static Il2CppMethodPointer s_methodPointers[33] = 
{
    ...
	LoadDll_Start_mDFFD4CEFDDC803966E45E8D7D915007650963687,
	...
};

...

const Il2CppCodeGenModule g_AssemblyU2DCSharp_CodeGenModule = 
{
	&quot;Assembly-CSharp.dll&quot;,
	33,
	s_methodPointers,
	0,
	NULL,
	s_InvokerIndices,
	0,
	NULL,
	0,
	NULL,
	0,
	NULL,
	NULL,
	g_AssemblyU2DCSharp_AttributeGenerators,
	NULL, // module initializer,
	NULL,
	NULL,
	NULL,
};
</code></pre><pre tabindex=0><code>// Classes/Native/Il2CppInvokerTable.cpp
...

// C# LoadDll.Start 方法的 invoker_method
void* RuntimeInvoker_TrueVoid_t700C6383A2A510C2CF4DD86DABD5CA9FF70ADAC5 (Il2CppMethodPointer methodPointer, const RuntimeMethod* methodMetadata, void* obj, void** args)
{
	typedef void (*Func)(void* obj, const RuntimeMethod* method);
	((Func)methodPointer)(obj, methodMetadata);
	return NULL;
}

...
</code></pre><ul>
<li>通过使用 <code>invoker_method</code> ，所有 C# 方法将统一成相同形式，由 C++ 调用，其参数说明如下：
<ul>
<li><code>methodPointer</code> ：C# 编译成 C++ 的方法。</li>
<li><code>methodMetadata</code> ：C# 方法的元数据。</li>
<li><code>obj</code> ：C# 方法执行时的实例对象，静态方法时则为空。</li>
<li><code>args</code> ： C# 方法执行的参数对象。</li>
</ul>
</li>
<li>其中，<code>RuntimeInvoker_True</code> 表示该方法为实例方法，<code>RuntimeInvoker_False</code> 则为静态方法，静态方法调用 <code>methodPointer</code> 时，则不会传入 <code>obj</code> 参数。</li>
</ul>
<h2 id=hybridclr-执行流程>HybridCLR 执行流程</h2>
<h3 id=动态加载程序集>动态加载程序集</h3>
<ul>
<li>动态加载程序集，需要调用 C# 的几个方法之一：
<ul>
<li><code>System.Reflection.Assembly.Load(byte[] rawAssembly)</code></li>
<li><code>System.Reflection.Assembly.LoadFile(string path)</code></li>
<li><code>System.Reflection.Assembly.LoadFrom(string assemblyFile)</code></li>
</ul>
</li>
<li>其中，<code>LoadFile</code> 和 <code>LoadFrom</code> 最终调用的是 <code>il2cpp::icalls::mscorlib::System::Reflection::Assembly::LoadFrom</code> ，其实现如下</li>
</ul>
<pre tabindex=0><code>// libil2cpp/icalls/mscorlib/System.Reflection/Assembly.cpp
    ...

    Il2CppReflectionAssembly* Assembly::LoadFrom(Il2CppString* assemblyFile, bool refonly)
    {
        IL2CPP_ASSERT(!refonly &amp;&amp; &quot;This icall is not supported by il2cpp when refonly=true&quot;);

        // Our implementation is going to behave a bit different.  We can't actually load any assembly.  If we didn't know about the assembly at conversion time,
        // then we won't be able to do anything.
        // On the other hand, if the name of the assembly matches the name of an assembly that we converted, then lets return the assembly that we know about.
        std::string utf8Path = utils::StringUtils::Utf16ToUtf8(utils::StringUtils::GetChars(assemblyFile));
        std::string fileName = utils::PathUtils::BasenameNoExtension(utf8Path);

        const Il2CppAssembly* foundAssembly = vm::MetadataCache::GetAssemblyByName(fileName.c_str());

        if (!foundAssembly)
        {
            vm::Exception::Raise(vm::Exception::GetFileLoadException(fileName.c_str()));
            IL2CPP_UNREACHABLE;
        }

        return vm::Reflection::GetAssemblyObject(foundAssembly);
    }

    ...
</code></pre><pre tabindex=0><code>// libil2cpp/vm/MetadataCache.cpp

...

const Il2CppAssembly* il2cpp::vm::MetadataCache::GetAssemblyByName(const char* nameToFind)
{
    for (int i = 0; i &lt; s_AssembliesCount; i++)
    {
        const Il2CppAssembly* assembly = s_AssembliesTable + i;

        const char* assemblyName = assembly-&gt;aname.name;

        if (strcmp(assemblyName, nameToFind) == 0)
            return assembly;
    }

    return NULL;
}

...
</code></pre><ul>
<li>可以看到，如果使用路径或文件名加载，最终会从 <code>MetadataCache.s_AssembliesTable</code> 中查找程序集，前面提到 <code>MetadataCache.s_AssembliesTable</code> 是从 <code>global-metadata.dat</code> 中解析得到的，所以没办法动态加载。</li>
<li><code>Load(byte[] rawAssembly)</code> 的实现如下：</li>
</ul>
<pre tabindex=0><code>// libil2cpp/icalls/mscorlib/System/AppDomain.cpp

...

    Il2CppAssembly* AppDomain::LoadAssemblyRaw(Il2CppAppDomain* self, Il2CppArray* rawAssembly, Il2CppArray* rawSymbolStore, void* /* System.Security.Policy.Evidence */ securityEvidence, bool refonly)
    {
        NOT_SUPPORTED_IL2CPP(AppDomain::LoadAssemblyRaw, &quot;This icall is not supported by il2cpp.&quot;);

        return 0;
    }

...
</code></pre><ul>
<li>Unity 的默认流程，也不支持通过 <code>Load(byte[] rawAssembly)</code> 方法动态加载程序集，因此 HybridCLR 修改了 <code>AppDomain::LoadAssemblyRaw</code> 方法的实现：</li>
</ul>
<pre tabindex=0><code>// libil2cpp/icalls/mscorlib/System/AppDomain.cpp

...

    Il2CppReflectionAssembly* AppDomain::LoadAssemblyRaw(Il2CppAppDomain* self, Il2CppArray* rawAssembly, Il2CppArray* rawSymbolStore, void* /* System.Security.Policy.Evidence */ securityEvidence, bool refonly)
    {
        //NOT_SUPPORTED_IL2CPP(AppDomain::LoadAssemblyRaw, &quot;This icall is not supported by il2cpp.&quot;);
        // return 0;
        if (!rawAssembly)
        {
            il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetArgumentNullException(&quot;rawAssembly is null&quot;));
        }
        const char* rawSymbolStoreBytes;
        size_t rawSymbolStoreLength;
        if (rawSymbolStore)
        {
			rawSymbolStoreBytes = (const char*)il2cpp::vm::Array::GetFirstElementAddress(rawSymbolStore);
			rawSymbolStoreLength = il2cpp::vm::Array::GetByteLength(rawSymbolStore);
		}
        else
        {
            rawSymbolStoreBytes = nullptr;
            rawSymbolStoreLength = 0;
        }
        const Il2CppAssembly* assembly = il2cpp::vm::MetadataCache::LoadAssemblyFromBytes(
            il2cpp::vm::Array::GetFirstElementAddress(rawAssembly),
            il2cpp::vm::Array::GetByteLength(rawAssembly),
            rawSymbolStoreBytes,
            rawSymbolStoreLength);
        return vm::Reflection::GetAssemblyObject(assembly);
    }

...
</code></pre><pre tabindex=0><code>// libil2cpp/vm/MetadataCache.cpp
...

void il2cpp::vm::MetadataCache::RegisterInterpreterAssembly(Il2CppAssembly* assembly)
{
    il2cpp::vm::Assembly::Register(assembly);
    s_cliAssemblies.push_back(assembly);
}

const Il2CppAssembly* il2cpp::vm::MetadataCache::LoadAssemblyFromBytes(const char* assemblyBytes, size_t length, const char* rawSymbolStoreBytes, size_t rawSymbolStoreLength)
{
    Il2CppAssembly* newAssembly = hybridclr::metadata::Assembly::LoadFromBytes(assemblyBytes, length, rawSymbolStoreBytes, rawSymbolStoreLength);
    il2cpp::os::FastAutoLock lock(&amp;il2cpp::vm::g_MetadataLock);

    // avoid register placeholder assembly twicely.
    for (Il2CppAssembly* ass : s_cliAssemblies)
    {
        if (ass == newAssembly)
        {
            il2cpp::vm::Assembly::InvalidateAssemblyList();
            return ass;
        }
    }
    RegisterInterpreterAssembly(newAssembly);

    return newAssembly;
}

...
</code></pre><ul>
<li>动态加载的程序集，除了注册到 <code>il2cpp::vm::MetadataCache.s_cliAssemblies</code> 以外，也和 AOT 加载的程序集一样，注册到 <code>il2cpp::vm.s_Assemblies</code> 中。</li>
</ul>
<h3 id=程序集解析>程序集解析</h3>
<ul>
<li>动态加载的二进制数据，将会以 PE 文件结构进行解析，主要方法为 <code>RawImageBase::Load</code> 。其中主要工作有：
<ul>
<li>解析 PE Headers 。</li>
<li>解析 Section Headers，找出 CLI Header，定位出 CLI 数据段。</li>
<li>解析出所有 Stream 。Stream 是 CLI 中最底层的数据结构之一，CLI 将元数据根据特性分为几个大类:
<ul>
<li>#~ 流。包含所有 Tables 定义，是最核心的元数据结构。</li>
<li>#Strings 流。包括代码中非文档类型的字符串，如类型名、字段名等等。</li>
<li>#GUID 流。</li>
<li>#Blob 流。一些元数据类型过于复杂，以 Blob 格式保存。还有一些数据如数组初始化数据列表，也常常保存到 Blob 流。</li>
<li>#- 流。</li>
<li>#Pdb 流。用于调试。</li>
</ul>
</li>
</ul>
</li>
<li>文件结构解析完成后，还需要进行后续的处理：
<ul>
<li>Tables Metadata 解析。</li>
<li>Table 解析。</li>
<li>Metadata 高级元数据结构解析。</li>
</ul>
</li>
<li>解析完成后，各种类型的元数据都存在 <code>RawImageBase._tableRowMetas</code> 中，每个类型按其各自的结构存储，类型和部分数据结构定义如下：</li>
</ul>
<pre tabindex=0><code>// libil2cpp/hybridclr/metadata/Tables.h

    enum class TableType
    {
        MODULE,
        TYPEREF,
        TYPEDEF,
        FIELD_POINTER,
        FIELD,
        METHOD_POINTER,
        METHOD,
        PARAM_POINTER,
        PARAM,
        INTERFACEIMPL,
        MEMBERREF, /* 0xa */
        CONSTANT,
        CUSTOMATTRIBUTE,
        FIELDMARSHAL,
        DECLSECURITY,
        CLASSLAYOUT,
        FIELDLAYOUT, /* 0x10 */
        STANDALONESIG,
        EVENTMAP,
        EVENT_POINTER,
        EVENT,
        PROPERTYMAP,
        PROPERTY_POINTER,
        PROPERTY,
        METHODSEMANTICS,
        METHODIMPL,
        MODULEREF, /* 0x1a */
        TYPESPEC,
        IMPLMAP,
        FIELDRVA,
        UNUSED6,
        UNUSED7,
        ASSEMBLY, /* 0x20 */
        ASSEMBLYPROCESSOR,
        ASSEMBLYOS,
        ASSEMBLYREF,
        ASSEMBLYREFPROCESSOR,
        ASSEMBLYREFOS,
        FILE,
        EXPORTEDTYPE,
        MANIFESTRESOURCE,
        NESTEDCLASS,
        GENERICPARAM, /* 0x2a */
        METHODSPEC,
        GENERICPARAMCONSTRAINT,
        UNUSED8,
        UNUSED9,
        UNUSED10,
        /* Portable PDB tables */
        DOCUMENT, /* 0x30 */
        METHODBODY,
        LOCALSCOPE,
        LOCALVARIABLE,
        LOCALCONSTANT,
        IMPORTSCOPE,
        STATEMACHINEMETHOD,
        CUSTOMDEBUGINFORMATION,
    };


    // 0
    struct TbModule
    {
        uint16_t generation;
        uint32_t name;
        uint32_t mvid;
        uint32_t encid;
        uint32_t encBaseId;
    };

    // 1
    struct TbTypeRef
    {
        uint32_t resolutionScope;
        uint32_t typeName;
        uint32_t typeNamespace;
    };

    // 2
    struct TbTypeDef
    {
        uint32_t flags;
        uint32_t typeName;
        uint32_t typeNamespace;
        uint32_t extends;
        uint32_t fieldList;
        uint32_t methodList;
    };

    // 3 FIELD_POINTER

    // 4
    struct TbField
    {
        uint32_t flags;
        uint32_t name;
        uint32_t signature;
    };

    // 5 METHOD_POINTER
        
    // 6
    struct TbMethod
    {
        uint32_t rva;
        uint16_t implFlags;
        uint16_t flags;
        uint32_t name;
        uint32_t signature;
        uint32_t paramList;
    };

    // 7 PARAM_POINTER

    // 8
    struct TbParam
    {
        uint16_t flags;
        uint16_t sequence;
        uint32_t name;
    };

...

</code></pre><h3 id=方法调用-1>方法调用</h3>
<ul>
<li>前面提到，Unity 的方法执行过程，会对类进行初始化，通过 <code>MetadataCache::GetMethodInvoker</code> 和 <code>MetadataCache::GetMethodPointer</code> 来获取方法的 <code>invoker_method</code> 和 <code>methodPointer</code> 。<code>MetadataCache::GetMethodPointer</code> 和 <code>MetadataCache::GetMethodInvoker</code> 代码如下：</li>
</ul>
<pre tabindex=0><code>// libil2cpp/vm/MetadataCache.cpp

...

Il2CppMethodPointer il2cpp::vm::MetadataCache::GetMethodPointer(const Il2CppImage* image, uint32_t token)
{
    uint32_t rid = GetTokenRowId(token);
    uint32_t table =  GetTokenType(token);
    if (rid == 0)
        return NULL;

    if (hybridclr::metadata::IsInterpreterImage(image))
    {
        return hybridclr::metadata::MetadataModule::GetMethodPointer(image, token);
    }

    IL2CPP_ASSERT(rid &lt;= image-&gt;codeGenModule-&gt;methodPointerCount);

    return image-&gt;codeGenModule-&gt;methodPointers[rid - 1];
}


InvokerMethod il2cpp::vm::MetadataCache::GetMethodInvoker(const Il2CppImage* image, uint32_t token)
{
    uint32_t rid = GetTokenRowId(token);
    uint32_t table = GetTokenType(token);
    if (rid == 0)
        return NULL;
    if (hybridclr::metadata::IsInterpreterImage(image))
    {
        return hybridclr::metadata::MetadataModule::GetMethodInvoker(image, token);
    }
    int32_t index = image-&gt;codeGenModule-&gt;invokerIndices[rid - 1];

    if (index == kMethodIndexInvalid)
        return NULL;

    IL2CPP_ASSERT(index &gt;= 0 &amp;&amp; static_cast&lt;uint32_t&gt;(index) &lt; s_Il2CppCodeRegistration-&gt;invokerPointersCount);
    return s_Il2CppCodeRegistration-&gt;invokerPointers[index];
}

...
</code></pre><ul>
<li>与原版相比，均多了一个 <code>IsInterpreterImage</code> 方法判断的分支，其实现如下：</li>
</ul>
<pre tabindex=0><code>// libil2cpp/hybridclr/metadata/MetadataUtil.h

...

    inline bool IsInterpreterIndex(int32_t index)
    {
        //return DecodeImageIndex(index) != 0;
        return index != kInvalidIndex &amp;&amp; ((uint32_t)index &amp; ~kMetadataIndexMaskA) != 0;
    }

...

    inline bool IsInterpreterImage(const Il2CppImage* image)
    {
        return IsInterpreterIndex(image-&gt;token);
    }

...
</code></pre><ul>
<li>其中，<code>~kMetadataIndexMaskA</code> 的值为 <code>0xF0000000</code> ，即 <code>Il2CppImage.token</code> 的高 4 位用于区分是动态加载的程序集，还是 AOT 的程序集。实际项目生成的<code>globalmetadata.dat</code> 中，这些元数据 id 的值都较小，最大也不过几十万级别，所以使用 id 分高位低位这种方式来标记。<code>token</code> 的具体含义如下：
<ul>
<li>第 0 ~ 21 位（共 22 位）：元数据的 id 标识范围，镜像 id 不使用这个区间，保证不会影响到 AOT 生成的 id。</li>
<li>第 22 ~ 31 位（共 10 位）：镜像 id 标识，动态加载的镜像 id ，AOT 生成的为 0。
<ul>
<li>第 22 ~ 29 位：不同的镜像类型的 id ，按加载顺序增长。</li>
<li>第 30 ~ 31 位：镜像的类型标识（优先按二进制文件大小划分）。</li>
</ul>
</li>
</ul>
</li>
<li>当镜像类型为 0 时，id 的范围会从 0x40 开始（<code>libil2cpp::hybridclr::metadata.s_nextImageIndexByKind[0]</code>），即此时最小的镜像 id 为 00 0100 0000 ，确保能够被识别为动态加载的程序集。</li>
<li>动态加载的程序集中的方法，初始化后存在了 <code>libil2cpp::hybridclr::metadata::InterpreterImage._methodDefines</code> 中。<code>hybridclr::metadata::MetadataModule::GetMethodInvoker</code> 方法，通过方法的 token ，从 <code>_methodDefines</code> 获取 <code>Il2CppMethodDefinition</code> 结构的方法声明，通过 <code>InterpreterModule::GetMethodInvoker</code> 方法获取 <code>InvokerMethod</code> 方法对象，其代码如下：</li>
</ul>
<pre tabindex=0><code>// libil2cpp/hybridclr/interpreter/InterpreterImage.cpp
...

	static void* InterpreterInvoke(Il2CppMethodPointer methodPointer, const MethodInfo* method, void* __this, void** __args)
	{
		InterpMethodInfo* imi = method-&gt;interpData ? (InterpMethodInfo*)method-&gt;interpData : InterpreterModule::GetInterpMethodInfo(method);
		StackObject* args = (StackObject*)alloca(sizeof(StackObject) * imi-&gt;argStackObjectSize);
		bool isInstanceMethod = metadata::IsInstanceMethod(method);
		if (isInstanceMethod)
		{
			if (IS_CLASS_VALUE_TYPE(method-&gt;klass))
			{
				__this = (Il2CppObject*)__this + (methodPointer != method-&gt;methodPointerCallByInterp);
			}
			args[0].ptr = __this;
		}
		MethodArgDesc* argDescs = imi-&gt;args + isInstanceMethod;
		ConvertInvokeArgs(args + isInstanceMethod, method, argDescs, __args);
		if (method-&gt;return_type-&gt;type == IL2CPP_TYPE_VOID)
		{
			Interpreter::Execute(method, args, nullptr);
			return nullptr;
		}
		else
		{
			StackObject* ret = (StackObject*)alloca(sizeof(StackObject) * imi-&gt;retStackObjectSize);
			Interpreter::Execute(method, args, ret);
			return TranslateNativeValueToBoxValue(method-&gt;return_type, ret);
		}
	}

...
</code></pre><ul>
<li>HybridCLR 将参数都放到 StackObject 类型的数组中，并传入元数据方法对象，使用 <code>Interpreter::Execute</code> 来执行方法。其实现如下：</li>
</ul>
<pre tabindex=0><code>// libil2cpp/hybridclr/interpreter//Interpreter_Execute.cpp

...

	void Interpreter::Execute(const MethodInfo* methodInfo, StackObject* args, void* ret)
	{
		MachineState&amp; machine = InterpreterModule::GetCurrentThreadMachineState();
		InterpFrameGroup interpFrameGroup(machine);

		const InterpMethodInfo* imi;
		InterpFrame* frame;
		StackObject* localVarBase;
		byte* ipBase;
		byte* ip;

		Il2CppException* lastUnwindException;
		StackObject* tempRet = nullptr;

		PREPARE_NEW_FRAME_FROM_NATIVE(methodInfo, args, ret);

	LoopStart:
		try
		{
			for (;;)
			{
				switch (*(HiOpcodeEnum*)ip)
				{

                    ...

				default:
					RaiseExecutionEngineException(&quot;&quot;);
					break;
				}                   
			}
		ExitEvalLoop:;
		}
		catch (Il2CppExceptionWrapper ex)
		{
			PREPARE_EXCEPTION(ex.ex, 0);
			FIND_NEXT_EX_HANDLER_OR_UNWIND();
		}
		return;
	UnWindFail:
		IL2CPP_ASSERT(lastUnwindException);
		IL2CPP_ASSERT(interpFrameGroup.GetFrameCount() == 0);
		il2cpp::vm::Exception::Raise(lastUnwindException);
	}

</code></pre><ul>
<li>简单来说，<code>Interpreter::Execute</code> 实现了解释器功能，将 IL 代码逐行解释执行，过程中使用的变量如下：
<ul>
<li><code>InterpFrameGroup interpFrameGroup</code>
<ul>
<li>解释帧组，用于管理解释帧的进出栈及执行。</li>
</ul>
</li>
<li><code>const InterpMethodInfo* imi</code>
<ul>
<li>解释方法，包含了方法的元数据、参数类型等，以及缓存了转换后的结果。</li>
</ul>
</li>
<li><code>InterpFrame* frame</code>
<ul>
<li>解释帧，记录了需要执行的方法、参数等相关指针地址。</li>
</ul>
</li>
<li><code>StackObject* localVarBase</code>
<ul>
<li>参数指针，指向解释帧的首个参数。</li>
</ul>
</li>
<li><code>byte* ipBase</code>
<ul>
<li>解释方法指针，指向解释帧的首个方法。</li>
</ul>
</li>
<li><code>byte* ip</code>
<ul>
<li>解释方法指针，初始化时指向解释帧的首个方法，随着帧执行，会指向当前帧的下一个方法。</li>
</ul>
</li>
<li><code>Il2CppException* lastUnwindException</code>
<ul>
<li>上异常信息。</li>
</ul>
</li>
<li><code>StackObject* tempRet</code>
<ul>
<li>临时返回值。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id=解释帧>解释帧</h4>
<ul>
<li>hybridclr 指令结构如下（引自 <a href=https://hybridclr.doc.code-philosophy.com/blog/instructions>HybridCLR 官方博客</a>）:
<img src="/img/Unity/HybridCLR/HybridCLR_5.png?raw=true" alt=HybridCLR_5.png>
其中指令的前 2 字节是 opcode ，剩下的指令数据为指令 param 。param 分为几种类型：
<ul>
<li>数据逻辑地址。</li>
<li>普通常量。</li>
<li>resolve 后的数据。</li>
<li>resolve 后的数据的指针。</li>
<li>其他一些辅助数据。</li>
<li>为了保证param内存对齐访问而插入的 padding 参数。</li>
</ul>
</li>
<li>每个解释帧对象，即对应一个需要执行的方法，其结构如下：</li>
</ul>
<pre tabindex=0><code>// libil2cpp/hybridclr/ubteroreter/InterpreterDefs.h

...

		struct InterpFrame
		{
			const MethodInfo* method;           // 需要执行的元方法
			StackObject* stackBasePtr;          // 方法对应的参数指针
			int32_t oldStackTop;                // 上一个方法的栈顶，即当前方法的起始栈
			void* ret;                          // 返回值指针
			byte* ip;                           // 方法对应的指令地址指针

			ExceptionFlowInfo* exFlowBase;
			int32_t exFlowCount;
			int32_t exFlowCapaticy;

			int32_t oldLocalPoolBottomIdx;

			ExceptionFlowInfo* GetCurExFlow() const
			{
				return exFlowCount &gt; 0 ? exFlowBase + exFlowCount - 1 : nullptr;
			}

			ExceptionFlowInfo* GetPrevExFlow() const
			{
				return exFlowCount &gt; 1 ? exFlowBase + exFlowCount - 2 : nullptr;
			}
		};

...

</code></pre><ul>
<li>从动态加载的程序集中，可以得到方法的元数据，执行时会有对应的参数，然而元数据方法无法直接执行，需要进行转换，通过解释帧对象，将不同的方法以及其不同的调用参数进行封装，得到一个统一大小的执行对象放到栈上依次执行。</li>
<li>每个方法会由多条转换后的指令组成，单条指令执行完成后，就会重复 <code>LoopStart</code> 循环，继续执行下一条。当前方法执行完成后，会执行 <code>LEAVE_FRAME</code> 方法，如果当前方法是由其他解释帧中的指令调起的，则找到上一个解释帧。由于每一条指令执行完成的时候都会将 <code>ip</code> 指向下一个指令的起始位置，所以回到上一个解释帧时，会将 <code>ip</code> 的地址赋给 <code>frame->ip</code> ，使其还未执行的指令开始继续执行。</li>
</ul>
<h4 id=解释方法>解释方法</h4>
<ul>
<li>从解释帧中了解到，方法的执行是从 <code>Interpreter::Execute</code> 方法中的 <code>ip</code> 指向的地址开始，而 <code>ip</code> 初始化是设置为 <code>imi->codes</code> ，即设置为解释方法的地址。也就是说，解释方法需要完成从元数据到可执行指令的转换过程。</li>
<li>解释方法的创建过程如下：
<ul>
<li><code>Interpreter::Execute</code>（libil2cpp/hybridclr/interpreter/Interpreter_Execute.cpp）</li>
<li><code>PREPARE_NEW_FRAME_FROM_NATIVE</code>（libil2cpp/hybridclr/interpreter/Interpreter_Execute.cpp）</li>
<li><code>InterpreterModule::GetInterpMethodInfo</code>（libil2cpp/hybridclr/interpreter/InterpreterModule.cpp）</li>
<li><code>HiTransform::Transform</code>（libil2cpp/hybridclr/transform/Transform.cpp）</li>
</ul>
</li>
<li>程序集解析完后，对应的方法会以 <code>TbMethod</code> 的结构存储，通过 <code>metadata::MethodBodyCache::GetMethodBody</code> 方法，从中获取方法体信息，方法对应的 IL 代码即为 <code>MethodBody.ilcodes</code>。在 IL 代码中，每条指令都由操作码（Opcode）和操作数（Operand）组成。根据操作码，每条指令会生成对应的中间表示 IR（Intermediate Representation），再设置到解释方法的 <code>codes</code> ，当操作码为调用方法时，主要代码如下：</li>
</ul>
<pre tabindex=0><code>// libil2cpp/hybridclr/transform/TransformContext.cpp

...

	void TransformContext::TransformBodyImpl(int32_t depth, int32_t localVarOffset)
	{
        ...

		ipBase = body.ilcodes;
		ip = body.ilcodes;
		ipOffset = 0;

        ...

        for (;;)
		{
            ...

            switch ((OpcodeValue)*ip)
			{
                ...

			case OpcodeValue::CALL:
			{
				uint32_t token = (uint32_t)GetI4LittleEndian(ip + 1);
				ip += 5;
				shareMethod = const_cast&lt;MethodInfo*&gt;(image-&gt;GetMethodInfoFromToken(tokenCache, token, klassContainer, methodContainer, genericContext));
				IL2CPP_ASSERT(shareMethod);
			}

		LabelCall:
			{
				if (TryAddInstinctInstruments(shareMethod))
				{
					continue;
				}

#if HYBRIDCLR_UNITY_2021_OR_NEW
				if (!shareMethod-&gt;has_full_generic_sharing_signature)
#endif
				{
					if (!InitAndGetInterpreterDirectlyCallMethodPointer(shareMethod))
					{
						RaiseAOTGenericMethodNotInstantiatedException(shareMethod);
					}
				}

				bool resolvedIsInstanceMethod = IsInstanceMethod(shareMethod);
				int32_t resolvedTotalArgNum = shareMethod-&gt;parameters_count + resolvedIsInstanceMethod;
				int32_t needDataSlotNum = (resolvedTotalArgNum + 3) / 4;
				int32_t callArgEvalStackIdxBase = evalStackTop - resolvedTotalArgNum;
				uint32_t methodDataIndex = GetOrAddResolveDataIndex(shareMethod);

				if (hybridclr::metadata::IsInterpreterImplement(shareMethod))
				{
					uint16_t argBaseOffset = (uint16_t)GetEvalStackOffset(callArgEvalStackIdxBase);

					if (ShouldBeInlined(shareMethod, depth) &amp;&amp; TransformSubMethodBody(*this, shareMethod, depth + 1, argBaseOffset))
					{

					}
					else
					{
						if (IsReturnVoidMethod(shareMethod))
						{
							CreateAddIR(ir, CallInterp_void);
							ir-&gt;methodInfo = methodDataIndex;
							ir-&gt;argBase = argBaseOffset;
						}
						else
						{
							CreateAddIR(ir, CallInterp_ret);
							ir-&gt;methodInfo = methodDataIndex;
							ir-&gt;argBase = argBaseOffset;
							ir-&gt;ret = argBaseOffset;
						}
					}
					PopStackN(resolvedTotalArgNum);
					if (!IsReturnVoidMethod(shareMethod))
					{
						PushStackByType(shareMethod-&gt;return_type);
					}
					continue;
				}
#if HYBRIDCLR_UNITY_2021_OR_NEW
				if (!shareMethod-&gt;has_full_generic_sharing_signature)
#endif
				{
					if (TryAddCallCommonInstruments(shareMethod, methodDataIndex))
					{
						continue;
					}
				}



				Managed2NativeCallMethod managed2NativeMethod = InterpreterModule::GetManaged2NativeMethodPointer(shareMethod, false);
				IL2CPP_ASSERT(managed2NativeMethod);
				uint32_t managed2NativeMethodDataIdx = GetOrAddResolveDataIndex((void*)managed2NativeMethod);

				int32_t argIdxDataIndex;
				uint16_t* __argIdxs;
				AllocResolvedData(resolveDatas, needDataSlotNum, argIdxDataIndex, __argIdxs);

				if (resolvedIsInstanceMethod)
				{
					__argIdxs[0] = GetEvalStackOffset(callArgEvalStackIdxBase);
				}

				for (uint8_t i = 0; i &lt; shareMethod-&gt;parameters_count; i++)
				{
					int32_t curArgIdx = i + resolvedIsInstanceMethod;
					__argIdxs[curArgIdx] = evalStack[callArgEvalStackIdxBase + curArgIdx].locOffset;
				}

				PopStackN(resolvedTotalArgNum);

				if (!IsReturnVoidMethod(shareMethod))
				{
					PushStackByType(shareMethod-&gt;return_type);
					interpreter::LocationDataType locDataType = GetLocationDataTypeByType(shareMethod-&gt;return_type);
					if (interpreter::IsNeedExpandLocationType(locDataType))
					{
						CreateAddIR(ir, CallNativeInstance_ret_expand);
						ir-&gt;type = resolvedIsInstanceMethod ? HiOpcodeEnum::CallNativeInstance_ret_expand : HiOpcodeEnum::CallNativeStatic_ret_expand;
						ir-&gt;managed2NativeMethod = managed2NativeMethodDataIdx;
						ir-&gt;methodInfo = methodDataIndex;
						ir-&gt;argIdxs = argIdxDataIndex;
						ir-&gt;ret = GetEvalStackTopOffset();
						ir-&gt;retLocationType = (uint8_t)locDataType;
					}
					else
					{
						CreateAddIR(ir, CallNativeInstance_ret);
						ir-&gt;type = resolvedIsInstanceMethod ? HiOpcodeEnum::CallNativeInstance_ret : HiOpcodeEnum::CallNativeStatic_ret;
						ir-&gt;managed2NativeMethod = managed2NativeMethodDataIdx;
						ir-&gt;methodInfo = methodDataIndex;
						ir-&gt;argIdxs = argIdxDataIndex;
						ir-&gt;ret = GetEvalStackTopOffset();
					}
				}
				else
				{
					CreateAddIR(ir, CallNativeInstance_void);
					ir-&gt;type = resolvedIsInstanceMethod ? HiOpcodeEnum::CallNativeInstance_void : HiOpcodeEnum::CallNativeStatic_void;
					ir-&gt;managed2NativeMethod = managed2NativeMethodDataIdx;
					ir-&gt;methodInfo = methodDataIndex;
					ir-&gt;argIdxs = argIdxDataIndex;
				}
				continue;
			}

                ...

            }

            ...
        }
    }
...

</code></pre><ul>
<li>可以看到，当调用不同的方法时，IR 的参数值不一样。
<ul>
<li>AOT 方法：
<ul>
<li>AOT 方法的参数数量不定，在编译时就已经确定了数据的处理方式和内存布局。编译器会根据函数的逻辑和变量的使用情况，为每个变量分配合适的寄存器或内存空间，并在生成的机器码中直接使用这些寄存器或内存地址来进行数据的访问和操作，则执行过程需要精确地知道每个参数的具体地址<strong>偏移</strong>，因此将每个参数都记录到 <code>resolvedDatas</code> 中。此外，调用 AOT 方法还需要通过桥接函数完成解释器方法参数到 Native abi 方法的转换，为了避免运行时查找的开销，所以提前计算了对应的桥接函数并缓存起来，并记录到 <code>resolvedDatas</code> 中。</li>
</ul>
</li>
<li>Interpreter 方法：
<ul>
<li>Interpreter 方法会将参数按顺序压到栈上，对于局部变量的赋值和使用，也会相应地在栈上进行数据的存储和读取，因此只需要一个 <code>argBase</code> 参数指定首个参数的逻辑地址，而不需要使用 <code>resolvedDatas</code> 记录。此外，由于是直接对指令解释执行，所以也不需要桥接函数，省去了 <code>Manged2Native -> Native2Managed</code> 的过程。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id=桥接函数>桥接函数</h4>
<ul>
<li>方法执行过程，会经常出现托管（Managed）代码和本机（Native）代码的相互调用。但两者无法直接相互调用，主要有以下原因：
<ul>
<li>运行环境不同。托管代码运行在公共语言运行库（CLR）中，受 CLR 的管理和约束，而本机代码运行在操作系统的原生环境中，不经过 CLR 管理。</li>
<li>调用约定差异。托管代码通常使用栈来传递参数，并且遵循特定的调用约定，如 <code>__stdcall</code> 或 <code>__cdecl</code> 等，返回值通常也在栈上，并根据函数的声明来确定返回值类型和大小。而本机代码可能使用不同的调用约定，或者直接通过寄存器传递参数，返回值可能直接通过寄存器，或者其他方式返回。</li>
<li>数据类型不兼容。托管代码中的基本数据类型（如 C# 中的 int、float 等）与本机代码中的基本数据类型（如 C++ 中的 int、float 等）虽然名称相同，但在内存布局、表示范围等方面可能存在差异。例如，在某些平台上，托管代码中的 int 可能是 32 位的，而本机代码中的 int 可能是 64 位的。此外，对于结构体、类等复杂数据类型，托管代码中的复杂数据类型通常包含元数据，用于支持反射等特性，而本机代码中的复杂数据类型则没有这些额外的信息。因此，在相互调用时，无法直接传递和处理这些复杂数据类型。</li>
<li>内存管理方式不同。托管代码使用托管堆来分配内存，托管对象具有自动的垃圾回收机制，由 CLR 进行管理，而本机代码使用非托管堆来分配内存，本机对象的生命周期需要开发者自行管理。</li>
</ul>
</li>
<li>为了实现两者交互，需要使用桥接函数。AOT 的桥接函数获取代码如下：</li>
</ul>
<pre tabindex=0><code>// libil2cpp/hybridclr/interpreter/InterpreterModule.cpp

...

	Managed2NativeCallMethod InterpreterModule::GetManaged2NativeMethodPointer(const MethodInfo* method, bool forceStatic)
	{
		if (method-&gt;methodPointerCallByInterp == NotSupportNative2Managed 
#if HYBRIDCLR_UNITY_2021_OR_NEW
			|| method-&gt;has_full_generic_sharing_signature
#endif
			)
		{
			return Managed2NativeCallByReflectionInvoke;
		}
		char sigName[1000];
		ComputeSignature(method, !forceStatic, sigName, sizeof(sigName) - 1);
		auto it = s_managed2natives.find(sigName);
		return it != s_managed2natives.end() ? it-&gt;second : Managed2NativeCallByReflectionInvoke;
	}

...
</code></pre><ul>
<li>根据方法的元数据，通过 <code>ComputeSignature</code> 方法计算出一个字符串表示。每个类型的值，都对应一个标识符，具体如下：</li>
</ul>
<table>
<thead>
<tr>
<th style=text-align:center>类型</th>
<th style=text-align:center>标识符</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center>void</td>
<td style=text-align:center>v</td>
</tr>
<tr>
<td style=text-align:center>IntPtr</td>
<td style=text-align:center>i</td>
</tr>
<tr>
<td style=text-align:center>sbyte</td>
<td style=text-align:center>i1</td>
</tr>
<tr>
<td style=text-align:center>short</td>
<td style=text-align:center>i2</td>
</tr>
<tr>
<td style=text-align:center>int</td>
<td style=text-align:center>i4</td>
</tr>
<tr>
<td style=text-align:center>long</td>
<td style=text-align:center>i8</td>
</tr>
<tr>
<td style=text-align:center>enum 类型</td>
<td style=text-align:center>定义类型对应的签名，如：<code>enum Color:short {}</code> 为 i2</td>
</tr>
<tr>
<td style=text-align:center>float</td>
<td style=text-align:center>r4</td>
</tr>
<tr>
<td style=text-align:center>double</td>
<td style=text-align:center>r8</td>
</tr>
<tr>
<td style=text-align:center>UintPtr</td>
<td style=text-align:center>u</td>
</tr>
<tr>
<td style=text-align:center>class 类型</td>
<td style=text-align:center>u</td>
</tr>
<tr>
<td style=text-align:center>指针类型</td>
<td style=text-align:center>u</td>
</tr>
<tr>
<td style=text-align:center>byte</td>
<td style=text-align:center>u1</td>
</tr>
<tr>
<td style=text-align:center>bool</td>
<td style=text-align:center>u1</td>
</tr>
<tr>
<td style=text-align:center>char</td>
<td style=text-align:center>u2</td>
</tr>
<tr>
<td style=text-align:center>ushort</td>
<td style=text-align:center>u2</td>
</tr>
<tr>
<td style=text-align:center>uint</td>
<td style=text-align:center>u4</td>
</tr>
<tr>
<td style=text-align:center>ulong</td>
<td style=text-align:center>u8</td>
</tr>
<tr>
<td style=text-align:center>TypeReference</td>
<td style=text-align:center>typedbyref</td>
</tr>
<tr>
<td style=text-align:center>struct</td>
<td style=text-align:center>全局唯一 struct 签名, 如： <code>s1</code>、<code>s7</code> ，在 <code>libil2cpp/codegen/hybridclr/generated/MethodBridge.cpp</code> 中定义</td>
</tr>
</tbody>
</table>
<ul>
<li>计算得到的结果为：<code>返回值类型</code> + <code>实例对象类型（如果有）</code> + <code>参数 1 类型</code> + <code>参数 2 类型</code> + <code>.....</code> 。</li>
<li>通过方法标识，可以从 <code>hybridclr::interpreter::g_managed2nativeStub</code> 中找到对应的桥接方法，如：</li>
</ul>
<pre tabindex=0><code>// libil2cpp/hybridclr/generated/MethodBridge.cpp

const Managed2NativeMethodInfo hybridclr::interpreter::g_managed2nativeStub[] = 
{
    ...

	{&quot;vi&quot;, __M2N_vi},

    ...
}

...

static void __M2N_vi(const MethodInfo* method, uint16_t* argVarIndexs, StackObject* localVarBase, void* ret)
{
    typedef void (*NativeMethod)(intptr_t __arg0, const MethodInfo* method);
    ((NativeMethod)(method-&gt;methodPointerCallByInterp))(M2NFromValueOrAddress&lt;intptr_t&gt;(localVarBase+argVarIndexs[0]), method);
}

...

</code></pre><ul>
<li><code>M2N</code> 的桥接方法都是 <code>Managed2NativeCallMethod</code> 类型的方法，具有四个参数：
<ul>
<li><code>const MethodInfo* method</code> ：方法的元数据信息。</li>
<li><code>uint16_t* argVarIndexs</code> ：方法的所有参数在 <code>resolveDatas</code> 中的索引，<code>resolveDatas</code> 中记录了对应的地址偏移信息。</li>
<li><code>StackObject* localVarBase</code> ：解释帧的首个参数指针，结合 <code>argVarIndexs</code> 就能得到参数具体地址。</li>
<li><code>void* ret</code>：方法执行后的返回值。</li>
</ul>
</li>
<li>设置桥接方法的指针地址到对应的 IR 对象上，如：调用无返回值的实例方法，创建的 IR 对象类型为 <code>CallNativeInstance_void</code> ，其结构如下：</li>
</ul>
<pre tabindex=0><code>//  libil2cpp/hybridclr/interpreter/Instruction.h

...
	enum class HiOpcodeEnum : uint16_t
	{
        ...

        CallNativeInstance_void,

        ...
    }

	struct IRCommon
	{
		HiOpcodeEnum type;
	};

    ...

	struct IRCallNativeInstance_void : IRCommon
	{
		uint8_t __pad2;     // 内存对齐用
		uint8_t __pad3;     // 内存对齐用
		uint32_t managed2NativeMethod;
		uint32_t methodInfo;
		uint32_t argIdxs;
	};

...
</code></pre><ul>
<li>执行时的处理如下：</li>
</ul>
<pre tabindex=0><code>	void Interpreter::Execute(const MethodInfo* methodInfo, StackObject* args, void* ret)
	{
        ...

	LoopStart:
		try
		{
			for (;;)
			{
				switch (*(HiOpcodeEnum*)ip)
				{
                
                ...

				case HiOpcodeEnum::CallNativeInstance_void:
				{
					uint32_t __managed2NativeMethod = *(uint32_t*)(ip + 4);
					uint32_t __methodInfo = *(uint32_t*)(ip + 8);
					uint32_t __argIdxs = *(uint32_t*)(ip + 12);
				    uint16_t* _resolvedArgIdxs = ((uint16_t*)&amp;imi-&gt;resolveDatas[__argIdxs]);
				    CHECK_NOT_NULL_THROW((localVarBase + _resolvedArgIdxs[0])-&gt;obj);
				    ((Managed2NativeCallMethod)imi-&gt;resolveDatas[__managed2NativeMethod])(((MethodInfo*)imi-&gt;resolveDatas[__methodInfo]), _resolvedArgIdxs, localVarBase, nullptr);
				    ip += 16;
				    continue;
				}

                ...
				}
			}
		ExitEvalLoop:;
		}
		catch (Il2CppExceptionWrapper ex)
		{
			PREPARE_EXCEPTION(ex.ex, 0);
			FIND_NEXT_EX_HANDLER_OR_UNWIND();
		}
		return;
	UnWindFail:
		IL2CPP_ASSERT(lastUnwindException);
		IL2CPP_ASSERT(interpFrameGroup.GetFrameCount() == 0);
		il2cpp::vm::Exception::Raise(lastUnwindException);
	}

...

</code></pre><ul>
<li>前面提到，执行时的 <code>ip</code> 指向的是解释方法的地址，即转换后的 IR 对象，根据不同类型的 IR 对象，对应的执行方法会从指定的地址偏移上获取对应的参数和方法进行处理。以 <code>vi</code> 方法标识为例，执行 <code>M2N</code> 方法时，最终会调用 <code>method->methodPointerCallByInterp</code> ，而 <code>method->methodPointerCallByInterp</code> 是通过 <code>MetadataCache::GetMethodPointer</code> 方法获取的，当调用的是 AOT 方法时，则会获取到 <code>s_methodPointers</code> 中对应的方法，类型为 <code>Il2CppMethodPointer</code> 。如果调用的方法是动态加载的，最终也同样需要返回 <code>Il2CppMethodPointer</code> 对象，获取的代码如下：</li>
</ul>
<pre tabindex=0><code>// libil2cpp/hybridclr/interpreter/InterpreterModule.cpp

    ...

	template&lt;typename T&gt;
	const Il2CppMethodPointer GetNative2ManagedMethod(const T* method, bool forceStatic)
	{
		char sigName[1000];
		ComputeSignature(method, !forceStatic, sigName, sizeof(sigName) - 1);
		auto it = s_native2manageds.find(sigName);
		return it != s_native2manageds.end() ? it-&gt;second : InterpreterModule::NotSupportNative2Managed;
	}

    ...

</code></pre><ul>
<li>和 <code>M2N</code> 桥接方法一样，<code>N2M</code> 桥接方法同样也是要先计算方法标识，再从 <code>hybridclr::interpreter::g_native2managedStub</code> 中获取对应的方法，如：</li>
</ul>
<pre tabindex=0><code>// libil2cpp/hybridclr/generated/MethodBridge.cpp
...

const Native2ManagedMethodInfo hybridclr::interpreter::g_native2managedStub[] = 
{
    ...

    {&quot;vi&quot;, (Il2CppMethodPointer)__N2M_vi},

    ...
}

...

static void __N2M_vi(intptr_t __arg0, const MethodInfo* method)
{
    
	constexpr int __ARG_OFFSET_0__ = 0;
	constexpr int __ARG_SIZE_0__ = (sizeof(__arg0) + 7)/8;      //内存对齐
	constexpr int __TOTAL_ARG_SIZE__ = __ARG_OFFSET_0__ + __ARG_SIZE_0__;

    StackObject args[__TOTAL_ARG_SIZE__];
	*(intptr_t*)(args + __ARG_OFFSET_0__) = __arg0;

    Interpreter::Execute(method, args, nullptr);
}

...
</code></pre><ul>
<li>执行对应的 <code>N2M</code> 桥接函数时，则再次调起 <code>Interpreter::Execute</code> ，对方法的内容进行解释执行，即实现了动态加载的方法的运行。</li>
</ul>
<h4 id=泛型共享机制>泛型共享机制</h4>
<ul>
<li>在 C# 中，泛型类的所有方法都可以共用，如：<code>List&lt;int></code> 、<code>List&lt;string></code> 和 <code>List&lt;object></code> 都使用相同的 <code>Add</code> 方法。当 IL2CPP 将 List 转换为 C++ 代码后，为了避免泛型代码膨胀，节约内存，在保证代码逻辑正确性的情况下对于一些能够共享代码，只生成一份代码，此技术称为<strong>泛型共享机制</strong>。</li>
<li>调用泛型方法，同样也需要 <code>invoker_method</code> 和 <code>methodPointer</code> ，以 <code>invoker_method</code> 为例，其获取代码如下：</li>
</ul>
<pre tabindex=0><code>// libil2cpp/vm/MetadataCache.cpp

...

InvokerMethod il2cpp::vm::MetadataCache::GetInvokerMethodPointer(const MethodInfo* methodDefinition, const Il2CppGenericContext* context)
{
    Il2CppGenericMethod method = { 0 };
    method.methodDefinition = const_cast&lt;MethodInfo*&gt;(methodDefinition);
    method.context.class_inst = context-&gt;class_inst;
    method.context.method_inst = context-&gt;method_inst;

    Il2CppMethodTableMapIter iter = s_MethodTableMap.find(&amp;method);
    if (iter != s_MethodTableMap.end())
    {
        IL2CPP_ASSERT(iter-&gt;second-&gt;invokerIndex &gt;= 0);
        if (static_cast&lt;uint32_t&gt;(iter-&gt;second-&gt;invokerIndex) &lt; s_Il2CppCodeRegistration-&gt;invokerPointersCount)
            return s_Il2CppCodeRegistration-&gt;invokerPointers[iter-&gt;second-&gt;invokerIndex];
        return NULL;
    }
    // get the shared version if it exists
    method.context.class_inst = GetSharedInst(context-&gt;class_inst);
    method.context.method_inst = GetSharedInst(context-&gt;method_inst);

    iter = s_MethodTableMap.find(&amp;method);
    if (iter != s_MethodTableMap.end())
    {
        IL2CPP_ASSERT(iter-&gt;second-&gt;invokerIndex &gt;= 0);
        if (static_cast&lt;uint32_t&gt;(iter-&gt;second-&gt;invokerIndex) &lt; s_Il2CppCodeRegistration-&gt;invokerPointersCount)
            return s_Il2CppCodeRegistration-&gt;invokerPointers[iter-&gt;second-&gt;invokerIndex];
        return NULL;
    }

    return NULL;
}

...

</code></pre><ul>
<li>可以看到，获取对应方法时，先根据泛型上下文 <code>context</code> 对象的 <code>class_inst</code> 和 <code>method_inst</code> ，从 <code>MetadataCache.s_MethodTableMap</code> 中查找。如果没有找到，则通过 <code>GetSharedInst</code> 计算其共享类型，然后再次进行查找。<code>GetSharedInst</code> 的实现如下：</li>
</ul>
<pre tabindex=0><code>// libil2cpp/vm/MetadataCache.cpp

...

static const Il2CppGenericInst* GetSharedInst(const Il2CppGenericInst* inst)
{
    if (inst == NULL)
        return NULL;

    il2cpp::metadata::Il2CppTypeVector types;
    for (uint32_t i = 0; i &lt; inst-&gt;type_argc; ++i)
    {
        if (il2cpp::vm::Type::IsReference(inst-&gt;type_argv[i]))
            types.push_back(&amp;il2cpp_defaults.object_class-&gt;byval_arg);
        else
        {
            const Il2CppType* type = inst-&gt;type_argv[i];
            if (s_Il2CppCodeGenOptions-&gt;enablePrimitiveValueTypeGenericSharing)
            {
                if (IsShareableEnum(type))
                {
                    const Il2CppType* underlyingType = il2cpp::vm::Type::GetUnderlyingType(type);
                    switch (underlyingType-&gt;type)
                    {
                        case IL2CPP_TYPE_I1:
                            type = &amp;il2cpp_defaults.sbyte_shared_enum-&gt;byval_arg;
                            break;
                        case IL2CPP_TYPE_I2:
                            type = &amp;il2cpp_defaults.int16_shared_enum-&gt;byval_arg;
                            break;
                        case IL2CPP_TYPE_I4:
                            type = &amp;il2cpp_defaults.int32_shared_enum-&gt;byval_arg;
                            break;
                        case IL2CPP_TYPE_I8:
                            type = &amp;il2cpp_defaults.int64_shared_enum-&gt;byval_arg;
                            break;
                        case IL2CPP_TYPE_U1:
                            type = &amp;il2cpp_defaults.byte_shared_enum-&gt;byval_arg;
                            break;
                        case IL2CPP_TYPE_U2:
                            type = &amp;il2cpp_defaults.uint16_shared_enum-&gt;byval_arg;
                            break;
                        case IL2CPP_TYPE_U4:
                            type = &amp;il2cpp_defaults.uint32_shared_enum-&gt;byval_arg;
                            break;
                        case IL2CPP_TYPE_U8:
                            type = &amp;il2cpp_defaults.uint64_shared_enum-&gt;byval_arg;
                            break;
                        default:
                            IL2CPP_ASSERT(0 &amp;&amp; &quot;Invalid enum underlying type&quot;);
                            break;
                    }
                }
            }

            if (il2cpp::vm::Type::IsGenericInstance(type))
            {
                const Il2CppGenericInst* sharedInst = GetSharedInst(type-&gt;data.generic_class-&gt;context.class_inst);
                Il2CppGenericClass* gklass = il2cpp::metadata::GenericMetadata::GetGenericClass(type-&gt;data.generic_class-&gt;type, sharedInst);
                Il2CppClass* klass = il2cpp::vm::GenericClass::GetClass(gklass);
                type = &amp;klass-&gt;byval_arg;
            }
            types.push_back(type);
        }
    }

    const Il2CppGenericInst* sharedInst = il2cpp::vm::MetadataCache::GetGenericInst(types);

    return sharedInst;
}

...

</code></pre><ul>
<li>共享类型的计算规则如下：
<ul>
<li>引用类型统一使用 <code>System.Object</code>，主要包括：
<ul>
<li>IL2CPP_TYPE_STRING（字符串）</li>
<li>IL2CPP_TYPE_SZARRAY（单元素零界数组）</li>
<li>IL2CPP_TYPE_CLASS（类）</li>
<li>IL2CPP_TYPE_OBJECT（对象）</li>
<li>IL2CPP_TYPE_ARRAY（数组）</li>
<li>IL2CPP_TYPE_GENERICINST（非值类型的泛型实例），如：<code>Dictionary&lt;int, string></code> 的共享类型为 <code>object</code> 。</li>
</ul>
</li>
<li>枚举以其基础类型计算，主要包括：
<ul>
<li>IL2CPP_TYPE_I1（<code>System.SByteEnum</code>）</li>
<li>IL2CPP_TYPE_I2（<code>System.Int16Enum</code>）</li>
<li>IL2CPP_TYPE_I4（<code>System.Int32Enum</code>）</li>
<li>IL2CPP_TYPE_I8（<code>System.Int64Enum</code>）</li>
<li>IL2CPP_TYPE_U1（<code>System.ByteEnum</code>）</li>
<li>IL2CPP_TYPE_U2（<code>System.UInt16Enum</code>）</li>
<li>IL2CPP_TYPE_U4（<code>System.UInt32Enum</code>）</li>
<li>IL2CPP_TYPE_U8（<code>System.UInt64Enum</code>）</li>
</ul>
</li>
<li>值类型的泛型实例，为其实例类型的共享类型组成的泛型类型，如：<code>ValueTuple&lt;int, string></code> 的共享类型为 <code>ValueTuple&lt;int, object></code> 。</li>
</ul>
</li>
<li>获取 <code>methodPointer</code> 方法和 <code>invoker_method</code> 基本一致，都是从 <code>s_Il2CppCodeRegistration</code> 中通过自身类型或共享类型进行查找，不同的是 <code>invoker_method</code> 是从 <code>s_Il2CppCodeRegistration->invokerPointers</code> 中查找，而 <code>methodPointer</code> 是从 <code>s_Il2CppCodeRegistration->genericMethodPointers</code> 中查找。</li>
<li>以<code>List&lt;string></code> 的 <code>Add</code> 方法为例，生成 C++ 代码后为：</li>
</ul>
<pre tabindex=0><code>// System.Void System.Collections.Generic.List`1&lt;System.String&gt;::Add(T)
inline void List_1_Add_m627ED3F7C50096BB8934F778CB980E79483BD2AE (List_1_t6C9F81EDBF0F4A31A9B0DA372D2EF34BDA3A1AF3 * __this, String_t* ___item0, const RuntimeMethod* method)
{
	((  void (*) (List_1_t6C9F81EDBF0F4A31A9B0DA372D2EF34BDA3A1AF3 *, String_t*, const RuntimeMethod*))List_1_Add_mE5B3CBB3A625606D9BC4337FEAAF1D66BCB6F96E_gshared)(__this, ___item0, method);
}

...

// System.Collections.Generic.List`1&lt;System.String&gt;
struct List_1_t6C9F81EDBF0F4A31A9B0DA372D2EF34BDA3A1AF3  : public RuntimeObject
{

...

};


// System.Void System.Collections.Generic.List`1&lt;System.Object&gt;::Add(T)
IL2CPP_EXTERN_C IL2CPP_METHOD_ATTR void List_1_Add_mE5B3CBB3A625606D9BC4337FEAAF1D66BCB6F96E_gshared (List_1_t3F94120C77410A62EAE48421CF166B83AB95A2F5 * __this, RuntimeObject * ___item0, const RuntimeMethod* method)
{
	...
}
</code></pre><ul>
<li>执行 <code>List&lt;string>.Add</code> 时，实际上在 C++ 中执行的是 <code>List&lt;object>.Add</code> 的方法，执行完成后，再将返回值由 <code>List&lt;object></code> 转换为 <code>List&lt;string></code> 返回。这里 IL2CPP 欺骗了 C++ 编译器，由于 C# 编译器已经强制要求 <code>List&lt;string></code> 中只能是对 <code>List&lt;T></code> 对象使用 <code>string</code> 类型进行操作，因此 IL2CPP 可以安全地欺骗 C++ 编译器。</li>
<li>对于 AOT 中使用过的泛型类型，会生成对应的代码（不能被裁剪）到 <code>global-metadata.bat</code> 中，初始化的时候通过 <code>MetadataCache::InitializeGCSafe</code> 添加到 <code>MetadataCache.s_MethodTableMap</code> 中。基于泛型共享机制，此时在热更代码中调用对应可共享类型，就能直接使用。</li>
</ul>
<h4 id=补充元数据技术>补充元数据技术</h4>
<ul>
<li>引用类型能通过泛型共享机制实现共享，而值类型则不能共享，主要有以下情况（引自 Hybridclr 文档）：
<ul>
<li>值类型有不同大小，不同大小的值类型需要使用不同的参数类型。</li>
<li>内存对齐问题。如：
<pre tabindex=0><code>// 


struct A
{
    short x;
    short y;
};


struct B
{
    int x;
};


{
    short x;
    T v;


}
</code></pre>其中，<code>GenericDemo&lt;A></code> 的 size = 6 ，alignment = 2 ，v 的偏移为 2 ，而 <code>GenericDemo&lt;B></code> 的 size = 8 ，alignment = 4 ，v 的偏移为 4 。由于 v 偏移不同，对于 <code>GetValue</code> 方法，无法使用相同的 C++ 代码让这两个类型都能正常工作。</li>
<li>ABI 问题。相同大小及对齐的结构体，在x64 ABI是等效的，可以用同等大小的结构体来作共享泛型实例化，但在 arm64 ABI 中却不行。如：
<pre tabindex=0><code>struct IntVec3 { int32_t x, y, z; }; 


</code></pre>其中，<code>IntVec3</code> 以引用的方式传参，而 <code>FloatVec3</code> 的三个字段分别放在三个浮点数寄存器中。</li>
</ul>
</li>
<li>由于值类型不能泛型共享，泛型实例（类或函数）的泛型参数中如果出现值类型，这个泛型实例必须在 AOT 提前实例化。如果泛型参数类型是热更新代码中定义的值类型，则会导致无法使用 <code>List&lt;热更新值类型></code> 这类代码，使得开发过程出现诸多不便。</li>
<li>对于热更新值类型，AOT 泛型方法无法执行，而热更新代码中的泛型方法可以正常执行，实际上是因为热更新代码中有原始的 IL 指令，因此可以根据泛型参数实例化出对应的泛型方法最终代码，而 AOT 方法没有获得原始 IL 指令的方法，因为在 IL 代码转成 C++ 代码后已经丢弃了。基于此情况，HybridCLR 提出了基于补充元数据的泛型函数实例化技术，通过补充 AOT 泛型的原始 IL 方法信息，从而解决泛型实例在热更新中的调用问题。</li>
<li>需要补充的是 AOT 中的方法，首先需要将对应的程序集进行动态加载，然后通过调用 <code>RuntimeApi::LoadMetadataForAOTAssembly</code> 方法，将 AOT 的补充程序集进行解析，和热更程序集加载类似，但由于 AOT 已经存在有同名的程序集，所以补充的程序集没有添加到 <code>s_Assemblies</code> 中，而是存在了 <code>AOTHomologousImage</code> 中，通过 <code>AOTHomologousImage::FindImageByAssembly</code> 方法获取。</li>
<li>没有补充元数据时，热更新值类型的 AOT 泛型方法通过 <code>GenericMethod::GetMethod</code> 获取到的方法，其 <code>methodPointer</code> 为空，HybridCLR 修改了 <code>GenericMethod::GetMethod</code> 的实现，增加了补充元数据后的处理：</li>
</ul>
<pre tabindex=0><code>// libil2cpp/metadata/GenericMethod.cpp
...
    const MethodInfo* GenericMethod::GetMethod(const Il2CppGenericMethod* gmethod, bool copyMethodPtr)
    {
        // This can be NULL only when we have hit the generic recursion depth limit.
        if (gmethod == NULL)
        {
            MethodInfo* newMethod = (MethodInfo*)MetadataCalloc(1, sizeof(MethodInfo));
            newMethod-&gt;methodPointer = AGenericMethodWhichIsTooDeeplyNestedWasInvoked;
            return newMethod;
        }

        // First check for an already constructed generic method using the shared/reader lock
        MethodInfo* existingMethod;
        if (s_GenericMethodMap.TryGet(gmethod, &amp;existingMethod))
            return existingMethod;

        return CreateMethodLocked(gmethod, copyMethodPtr);
    }

    const MethodInfo* GenericMethod::CreateMethodLocked(const Il2CppGenericMethod* gmethod, bool copyMethodPtr)
    {
        ...

        newMethod-&gt;invoker_method = MetadataCache::GetInvokerMethodPointer(methodDefinition, &amp;gmethod-&gt;context);
        newMethod-&gt;methodPointer = MetadataCache::GetMethodPointer(methodDefinition, &amp;gmethod-&gt;context, true, true);

        bool isAdjustorThunkMethod = newMethod-&gt;klass-&gt;valuetype &amp;&amp; hybridclr::metadata::IsInstanceMethod(newMethod);
        if (newMethod-&gt;methodPointer == nullptr)
        {
            if ((hybridclr::metadata::IsInterpreterMethod(newMethod) || hybridclr::metadata::MetadataModule::IsImplementedByInterpreter(newMethod)))
            {
                newMethod-&gt;invoker_method = hybridclr::interpreter::InterpreterModule::GetMethodInvoker(newMethod);
                newMethod-&gt;methodPointerCallByInterp = hybridclr::interpreter::InterpreterModule::GetMethodPointer(newMethod);
                if (isAdjustorThunkMethod)
                {
                    newMethod-&gt;virtualMethodPointerCallByInterp = hybridclr::interpreter::InterpreterModule::GetAdjustThunkMethodPointer(newMethod);
                }
                else
                {
                    newMethod-&gt;virtualMethodPointerCallByInterp = newMethod-&gt;methodPointerCallByInterp;
                }
                newMethod-&gt;methodPointer = newMethod-&gt;virtualMethodPointerCallByInterp;
                newMethod-&gt;isInterpterImpl = true;
                newMethod-&gt;initInterpCallMethodPointer = true;
            }
            else
            {
                // not init anything
            }
        }
        else
        {
            newMethod-&gt;virtualMethodPointerCallByInterp = newMethod-&gt;methodPointer;
            newMethod-&gt;methodPointerCallByInterp = isAdjustorThunkMethod ? MetadataCache::GetMethodPointer(methodDefinition, &amp;gmethod-&gt;context, false, true) : newMethod-&gt;methodPointer;
            newMethod-&gt;initInterpCallMethodPointer = true;
        }

        ...
    }

</code></pre><ul>
<li>然而，在 <code>InterpreterModule::GetMethodInvoker</code> -> <code>InterpreterModule::GetInterpMethodInfo</code> -> <code>HiTransform::Transform</code> -> <code>metadata::MetadataModule::GetUnderlyingInterpreterImage</code> 中，由于是解释执行，取的是解释程序集镜像 <code>InterpreterImage</code>，而 AOT 的补充程序集镜像是 <code>AOTHomologousImage</code> ，所以需要在 <code>GetUnderlyingInterpreterImage</code> 中特殊处理，代码如下：</li>
</ul>
<pre tabindex=0><code>// libil2cpp/hybridclr/metadata/MetadataModule.cpp

...

    Image* MetadataModule::GetUnderlyingInterpreterImage(const MethodInfo* methodInfo)
    {
        return metadata::IsInterpreterMethod(methodInfo) ? hybridclr::metadata::MetadataModule::GetImage(methodInfo-&gt;klass)
            : (metadata::Image*)hybridclr::metadata::AOTHomologousImage::FindImageByAssembly(
                methodInfo-&gt;klass-&gt;rank ? il2cpp_defaults.corlib-&gt;assembly : methodInfo-&gt;klass-&gt;image-&gt;assembly);
    }

...

</code></pre><ul>
<li>如果方法为解释方法，则直接获取解释程序集，否则需要获取方法所属 AOT 程序集的补充程序集。其中有一个特殊细节，对于 T[] 的成员函数，<code>methodInfo->klass</code> 指向了类型 T 所属的程序集，而不是 mscorlib 程序集，所以再做了特殊处理，数组类型指向 <code>il2cpp_defaults.corlib->assembly</code> 。</li>
<li><code>HiTransform::Transform</code> 方法中，通过执行 <code>metadata::MethodBodyCache::GetMethodBody(image, methodInfo->token)</code> 来获取方法的 <code>MethBody</code> ，对于 AOT 泛型方法，传入的 token 是 AOT 程序集中的 token ，而不是补充程序集中的 token 。加载补充程序集有两种模式：
<ul>
<li>CONSISTENT ：补充程序集的元数据和 AOT 中的完全精确一致，即两者的 token 也相同，可以直接使用。</li>
<li>SUPERSET ：补充程序集的元数据和 AOT 中的不一致，需要在初始化时计算原始 AOT 方法的 token 和补充元数据方法的 token 的映射关系。
<ul>
<li>调用 <code>SuperSetAOTHomologousImage::InitTypes1</code> ，遍历补充程序集中所有类型，通过 <code>TypeHandleFromName</code> 方法找到 AOT 中的类型，将补充程序集的类型加入到 <code>_aotTypeIndex2TypeDefs</code> 中，key 值为 AOT 类型的索引偏移值。</li>
<li>调用 <code>SuperSetAOTHomologousImage::InitMethods</code> ，遍历补充程序集中的所有方法，通过 <code>FindMatchMethod</code> 方法找到 AOT 中同名且参数类型和返回值类型都相同的方法，如果是泛型方法则将补充程序集的方法加入到 <code>_token2MethodDefs</code> 中，key 值为 AOT 方法的 token 。</li>
</ul>
</li>
</ul>
</li>
<li>对于 AOT 程序集中的类型、方法、变量，在解释执行过程中，为了提高执行性能，都需要保持使用原有 AOT 中生成的，所以无论哪种加载模式，在初始化补充程序集时，都需要做好绑定，以 SUPERSET 模式为例，即：
<ul>
<li><code>_typeDefs[index].aotTypeDef</code> 通过 <code>il2cpp::vm::Image::TypeHandleFromName</code> 方法查找并绑定，通过 <code>Image::GetClassFromToken</code> -> <code>...</code> -> <code>SuperSetAOTHomologousImage::GetIl2CppTypeFromRawTypeDefIndex</code> 方法获取。</li>
<li><code>_methodDefs[index].aotMethodDef</code> 通过 <code>FindMatchMethod</code> 方法查找并绑定，通过 <code>Image::GetMethodInfoFromToken</code> -> <code>...</code> -> <code>SuperSetAOTHomologousImage::GetMethodDefinitionFromRawIndex</code> 方法获取。</li>
<li><code>_fields[index].aotFieldDef</code> 通过 <code>FindMatchField</code> 方法查找并绑定，通过 <code>Image::GetFieldInfoFromToken</code> -> <code>...</code> -> <code>SuperSetAOTHomologousImage::ReadFieldRefInfoFromFieldDefToken</code> 方法获取。</li>
</ul>
</li>
</ul>
<h4 id=完全泛型共享>完全泛型共享</h4>
<ul>
<li>旧的泛型共享技术只能对 class 类型进行泛型共享，即只有引用类型（如类、接口等）的泛型实例可以共享代码。对于值类型（如整数、结构体等），则无法进行泛型共享。自 Unity 2021.3.x LTS版本起，IL2CPP 开始支持完全泛型共享机制，泛型参数无论是任何类型（包含值类型）都可以共享。这意味着无论是类、结构体还是其他数据类型，只要符合泛型约束条件，就可以实现泛型共享。HybridCLR 通过这个机制实现了不需要补充元数据也能支持 AOT 泛型，则不需要补充元数据，从而减小了内存的占用。此外，由于不需要解释执行，运行性能也得到了提升。不同版本开启完全泛型共享的方式如下：
<ul>
<li>2020 版本不支持完全泛型共享。</li>
<li>2021 版本需要设置 IL2CPP Code Generation 选项为 faster(smaller build) 。</li>
<li>2022 版本默认开启完全泛型共享，无法关闭。如果设置 IL2CPP Code Generation 选项为 faster(smaller build) 则能进一步减少包体。</li>
</ul>
</li>
<li>HybridCLR 文档说明，faster (smaller build) 会对泛型函数性能有较大影响（15% 甚至更高），因此建议不要开启这个选项。所以如果是 2021 版本并且没有内存压力情况下，建议使用补充元数据技术方案（HyBridCLR 完全泛型共享方案仅在商业版中提供）。</li>
</ul>
<h2 id=总结>总结</h2>
<ul>
<li>总的来说，目前 HyBridCLR 是主流的 Unity 热更新方案中唯一彻底支持原生 C# 泛型的方案，通过实现一套 IL 代码解释器，可以在运行时在 C++ 中直接解释执行动态加载的 IL 代码，从而达到热更新的目的。HyBridCLR 的细节内容还有很多，如：PE 文件结构解析、IL 指令集实现、VTable 虚表、GC 管理、多线程等，这里主要介绍 IL2CPP 的基础概念和 HybridCLR 的基本运作流程。相较于 Lua 而言，真正意义上的纯 C# 的开发对很多 Unity 开发者来说是比较友好的，可以减少学习另一门语言的成本，同时可以使用 Unity 的分析器进行性能调优，但 Lua 目前也在大部分项目中使用，大部分开发者都具备足够的使用经验，因此需要根据项目的实际情况选择适合的热更新方案。</li>
</ul>
<h2 id=参考>参考</h2>
<ul>
<li><a href=https://en.wikipedia.org/wiki/Just-in-time_compilation>Wikipedia : Just-in-time compilation</a></li>
<li><a href=https://en.wikipedia.org/wiki/Ahead-of-time_compilation>Wikipedia : Ahead-of-time_compilation</a></li>
<li><a href=https://www.mono-project.com/docs/advanced/runtime/docs/aot/#full-aot-mode>Mono : Ahead of Time Compilation (AOT)</a></li>
<li><a href=https://unity.com/blog/engine-platform/an-introduction-to-ilcpp-internals>Unity Blog : An introduction to IL2CPP internals</a></li>
<li><a href=https://unity.com/blog/engine-platform/il2cpp-internals-method-calls>Unity Blog : IL2CPP internals: Method calls</a></li>
<li><a href=https://unity.com/blog/engine-platform/il2cpp-internals-a-tour-of-generated-code>Unity Blog : IL2CPP internals: A tour of generated code</a></li>
<li><a href=https://unity.com/blog/engine-platform/il2cpp-internals-generic-sharing-implementation>Unity Blog : IL2CPP Internals: Generic sharing implementation</a></li>
<li><a href=https://hybridclr.doc.code-philosophy.com/blog>HybridCLR</a></li>
<li><a href=https://www.zhihu.com/column/c_1489549396035870720>知乎专栏 - HybridCLR c#热更新</a></li>
</ul>
<hr>
<ul class=pager>
<li class=previous>
<a href=/post/unity/ugui/eventsystem/ data-toggle=tooltip data-placement=top title="Unity篇 — 事件系统">&larr;
Previous Post</a>
</li>
<li class=next>
<a href=/post/unity/optimization/drawcalloptimization/ data-toggle=tooltip data-placement=top title="Unity篇 — Draw Call">Next
Post &rarr;</a>
</li>
</ul>
<div id=disqus-comment></div>
</div>
<div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container">
<div class=side-catalog>
<hr class="hidden-sm hidden-xs">
<h5>
<a class=catalog-toggle href=#>CATALOG</a>
</h5>
<ul class=catalog-body></ul>
</div>
</div>
<div class="col-lg-11 col-lg-offset-1
col-md-10 col-md-offset-1
sidebar-container">
</div>
</div>
</div>
</article>
<footer>
<div class=container>
<div class=row>
<div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
<ul class="list-inline text-center">
</ul>
<p class="copyright text-muted">
Copyright &copy; Xun's Blog 2025
<br>
<a href=https://themes.gohugo.io/hugo-theme-cleanwhite>CleanWhite Hugo Theme</a> by <a href=https://zhaohuabing.com>Huabing</a> |
<iframe style=margin-left:2px;margin-bottom:-5px frameborder=0 scrolling=0 width=100px height=20px src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true"></iframe>
</p>
</div>
</div>
</div>
</footer>
<script>function loadAsync(f,b){var c=document,d='script',a=c.createElement(d),e=c.getElementsByTagName(d)[0];a.src=f,b&&a.addEventListener('load',function(a){b(null,a)},!1),e.parentNode.insertBefore(a,e)}</script>
<script>$('#tag_cloud').length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:'#bbbbee',end:'#0085a1'}},$('#tag_cloud a').tagcloud()})</script>
<script>loadAsync("https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.js",function(){var a=document.querySelector("nav");a&&FastClick.attach(a)})</script>
<script type=text/javascript>function generateCatalog(a){_containerSelector='div.post-container';var h=$(_containerSelector),c,d,e,f,g,b;return c=h.find('h1,h2,h3,h4,h5,h6'),$(a).html(''),c.each(function(){d=$(this).prop('tagName').toLowerCase(),g="#"+$(this).prop('id'),e=$(this).text(),b=$('<a href="'+g+'" rel="nofollow">'+e+'</a>'),f=$('<li class="'+d+'_nav"></li>').append(b),$(a).append(f)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(a){a.preventDefault(),$('.side-catalog').toggleClass("fold")}),loadAsync("/js/jquery.nav.js",function(){$('.catalog-body').onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script>
</body>
</html>
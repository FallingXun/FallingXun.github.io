<!doctype html><html lang=zh-cn>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta property="og:site_name" content="Xun's Blog">
<meta property="og:type" content="article">
<meta property="og:image" content="https://fallingxun.github.io//">
<meta property="twitter:image" content="https://fallingxun.github.io//">
<meta name=title content="算法篇 — NavMesh 导航 — （2）生成导航网格">
<meta property="og:title" content="算法篇 — NavMesh 导航 — （2）生成导航网格">
<meta property="twitter:title" content="算法篇 — NavMesh 导航 — （2）生成导航网格">
<meta name=description content>
<meta property="og:description" content>
<meta property="twitter:description" content>
<meta property="twitter:card" content="summary">
<meta name=keyword content>
<link rel="shortcut icon" href=/img/favicon.ico>
<title>算法篇 — NavMesh 导航 — （2）生成导航网格-</title>
<link rel=canonical href=/post/algorithm/algorithm_navmeshnavigation_2/>
<link rel=stylesheet href=/css/iDisqus.min.css>
<link rel=stylesheet href=/css/bootstrap.min.css>
<link rel=stylesheet href=/css/hugo-theme-cleanwhite.min.css>
<link rel=stylesheet href=/css/zanshang.css>
<link href=//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css rel=stylesheet type=text/css>
<script src=/js/jquery.min.js></script>
<script src=/js/bootstrap.min.js></script>
<script src=/js/hux-blog.min.js></script>
</head>
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
<div class=container-fluid>
<div class="navbar-header page-scroll">
<button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=/>Xun's Blog</a>
</div>
<div id=huxblog_navbar>
<div class=navbar-collapse>
<ul class="nav navbar-nav navbar-right">
<li>
<a href=/>Home</a>
</li>
<li>
<a href=/categories/googleplay%E7%B3%BB%E5%88%97>googleplay系列</a>
</li>
<li>
<a href=/categories/lua%E7%B3%BB%E5%88%97>lua系列</a>
</li>
<li>
<a href=/categories/tmp%E7%B3%BB%E5%88%97>tmp系列</a>
</li>
<li>
<a href=/categories/unity%E7%B3%BB%E5%88%97>unity系列</a>
</li>
<li>
<a href=/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%B3%BB%E5%88%97>图形学系列</a>
</li>
<li>
<a href=/categories/%E6%B8%B2%E6%9F%93%E7%B3%BB%E5%88%97>渲染系列</a>
</li>
<li>
<a href=/categories/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97>算法系列</a>
</li>
</ul>
</div>
</div>
</div>
</nav>
<script>var $body=document.body,$toggle=document.querySelector('.navbar-toggle'),$navbar=document.querySelector('#huxblog_navbar'),$collapse=document.querySelector('.navbar-collapse');$toggle.addEventListener('click',handleMagic);function handleMagic(a){$navbar.className.indexOf('in')>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf('in')<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script>
<style type=text/css>header.intro-header{background-image:url('/')}</style>
<header class=intro-header>
<div class=container>
<div class=row>
<div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
<div class=post-heading>
<div class=tags>
<a class=tag href=/tags/algorithm title=Algorithm>
Algorithm
</a>
</div>
<h1>算法篇 — NavMesh 导航 — （2）生成导航网格</h1>
<h2 class=subheading></h2>
<span class=meta>
Posted by
Xun
on
Monday, July 7, 2025
</span>
</div>
</div>
</div>
</div>
</header>
<article>
<div class=container>
<div class=row>
<div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container">
<p>Navmesh 的寻路依赖于导航网格的生成，本文将基于 Recast Navigation 源码进行分析。</p>
<h1 id=简介>简介</h1>
<h1 id=一初始化生成配置>一、初始化生成配置</h1>
<ul>
<li>导航网格的生成配置结构 <code>rcConfig</code> 如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Include/Recast.h

...

struct rcConfig
{
	/// The width of the field along the x-axis. [Limit: &gt;= 0] [Units: vx]
	int width;

	/// The height of the field along the z-axis. [Limit: &gt;= 0] [Units: vx]
	int height;
	
	/// The width/height size of tile's on the xz-plane. [Limit: &gt;= 0] [Units: vx]
	int tileSize;
	
	/// The size of the non-navigable border around the heightfield. [Limit: &gt;=0] [Units: vx]
	int borderSize;

	/// The xz-plane cell size to use for fields. [Limit: &gt; 0] [Units: wu] 
	float cs;

	/// The y-axis cell size to use for fields. [Limit: &gt; 0] [Units: wu]
	float ch;

	/// The minimum bounds of the field's AABB. [(x, y, z)] [Units: wu]
	float bmin[3]; 

	/// The maximum bounds of the field's AABB. [(x, y, z)] [Units: wu]
	float bmax[3];

	/// The maximum slope that is considered walkable. [Limits: 0 &lt;= value &lt; 90] [Units: Degrees] 
	float walkableSlopeAngle;

	/// Minimum floor to 'ceiling' height that will still allow the floor area to 
	/// be considered walkable. [Limit: &gt;= 3] [Units: vx] 
	int walkableHeight;
	
	/// Maximum ledge height that is considered to still be traversable. [Limit: &gt;=0] [Units: vx] 
	int walkableClimb;
	
	/// The distance to erode/shrink the walkable area of the heightfield away from 
	/// obstructions.  [Limit: &gt;=0] [Units: vx] 
	int walkableRadius;
	
	/// The maximum allowed length for contour edges along the border of the mesh. [Limit: &gt;=0] [Units: vx] 
	int maxEdgeLen;
	
	/// The maximum distance a simplified contour's border edges should deviate 
	/// the original raw contour. [Limit: &gt;=0] [Units: vx]
	float maxSimplificationError;
	
	/// The minimum number of cells allowed to form isolated island areas. [Limit: &gt;=0] [Units: vx] 
	int minRegionArea;
	
	/// Any regions with a span count smaller than this value will, if possible, 
	/// be merged with larger regions. [Limit: &gt;=0] [Units: vx] 
	int mergeRegionArea;
	
	/// The maximum number of vertices allowed for polygons generated during the 
	/// contour to polygon conversion process. [Limit: &gt;= 3] 
	int maxVertsPerPoly;
	
	/// Sets the sampling distance to use when generating the detail mesh.
	/// (For height detail only.) [Limits: 0 or &gt;= 0.9] [Units: wu] 
	float detailSampleDist;
	
	/// The maximum distance the detail mesh surface should deviate from heightfield
	/// data. (For height detail only.) [Limit: &gt;=0] [Units: wu] 
	float detailSampleMaxError;
};

...
</code></pre><ul>
<li><code>rcConfig</code> 参数的含义如下：
<ul>
<li><code>width</code>
<ul>
<li>场在 x 轴上的宽度，由网格包围盒的宽度换算成单元格表示。</li>
</ul>
</li>
<li><code>height</code>
<ul>
<li>场在 z 轴上的高度，由网格包围盒的高度换算成单元格表示。</li>
</ul>
</li>
<li><code>tileSize</code>
<ul>
<li>xz 平面上的瓦片大小。</li>
</ul>
</li>
<li><code>borderSize</code>
<ul>
<li>高度场不可导航边界的大小。</li>
</ul>
</li>
<li><code>cs</code>
<ul>
<li>场在 xz 平面上的单元格大小。</li>
</ul>
</li>
<li><code>ch</code>
<ul>
<li>场在 y 轴上的单元格大小。</li>
</ul>
</li>
<li><code>bmin[3]</code>
<ul>
<li>场的 AABB 包围盒的最小边界。</li>
</ul>
</li>
<li><code>bmax[3]</code>
<ul>
<li>场的 AABB 包围盒的最大边界。</li>
</ul>
</li>
<li><code>walkableSlopeAngle</code>
<ul>
<li>可行走的最大斜坡角度（0° ~ 90°）。</li>
</ul>
</li>
<li><code>walkableHeight</code>
<ul>
<li>行走时地面到天花板的最小距离（>= 3）。</li>
</ul>
</li>
<li><code>walkableClimb</code>
<ul>
<li>可跨越的最大高度。</li>
</ul>
</li>
<li><code>walkableRadius</code>
<ul>
<li>在生成可行走区域时，需要从障碍物边缘向内收缩（侵蚀）的距离。</li>
</ul>
</li>
<li><code>maxEdgeLen</code>
<ul>
<li>轮廓边缘在网格边界上的最大长度。</li>
</ul>
</li>
<li><code>maxSimplificationError</code>
<ul>
<li>简化后的轮廓边缘和原轮廓之间需要偏离的最大距离。</li>
</ul>
</li>
<li><code>minRegionArea</code>
<ul>
<li>形成孤岛区域的最小单元格数量。</li>
</ul>
</li>
<li><code>mergeRegionArea</code>
<ul>
<li>区域包含的单元格数量少于该值时，尝试将此区域合并到更大的相邻区域。</li>
</ul>
</li>
<li><code>maxVertsPerPoly</code>
<ul>
<li>单个多边形的最大顶点数（>= 3）。</li>
</ul>
</li>
<li><code>detailSampleDist</code>
<ul>
<li>生成细节网格（高度细节）的采样间距（0 或 >= 0.9）。</li>
</ul>
</li>
<li><code>detailSampleMaxError</code>
<ul>
<li>细节网格（高度细节）表面与原始高度场数据的最大允许偏差。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id=二光栅化输入的多边形汤>二、光栅化输入的多边形汤</h1>
<ul>
<li>输入的原始 3D 模型数据，通常是一组无序的三角形（或其他多边形），没有明确的拓扑结构或层级关系，这些多边形可能重叠、重复或不封闭，统称为多边形汤，光栅化过程需要对这一组三角形做处理。</li>
</ul>
<h2 id=标记可行走三角面>标记可行走三角面</h2>
<ul>
<li>通过 <code>rcMarkWalkableTriangles</code> 方法，将坡度小于 <code>walkableSlopeAngle</code> 的三角面标记为可行走区域，其实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/Recast.cpp

...

void rcMarkWalkableTriangles(rcContext* context, const float walkableSlopeAngle,
                             const float* verts, const int numVerts,
                             const int* tris, const int numTris,
                             unsigned char* triAreaIDs)
{
	rcIgnoreUnused(context);
	rcIgnoreUnused(numVerts);

	const float walkableThr = cosf(walkableSlopeAngle / 180.0f * RC_PI);

	float norm[3];

	for (int i = 0; i &lt; numTris; ++i)
	{
		const int* tri = &amp;tris[i * 3];
		calcTriNormal(&amp;verts[tri[0] * 3], &amp;verts[tri[1] * 3], &amp;verts[tri[2] * 3], norm);
		// Check if the face is walkable.
		if (norm[1] &gt; walkableThr)
		{
			triAreaIDs[i] = RC_WALKABLE_AREA;
		}
	}
}

...
</code></pre><ul>
<li>其中，<code>calcTriNormal</code> 方法用于计算三角面的归一化法线。三角面和法线的示意图如下：
<img src="/img/Algorithm/NavmeshNavigation/Nav2_1.png?raw=true" alt=Nav2_1.png>
</li>
<li>三角面和 xz 平面的夹角即为坡度 θ，而法线和 y 轴的夹角也为 θ。由于法线为归一化，则法线在 y 轴上的投影即为 <code>cosθ</code>。随着坡度 θ 增大，<code>cosθ</code> 逐渐减小，当坡度 θ 小于 <code>walkableSlopeAngle</code> 时，该三角面则为可行走区域，将三角面的 <code>areaID</code> 设置为 <code>RC_WALKABLE_AREA</code>。</li>
<li>光栅化前先对坡度较大的三角面进行过滤，比起光栅化后再对每一个 <code>cell</code> 进行坡度判断，可以减少较多的计算量。</li>
</ul>
<h3 id=光栅化三角面>光栅化三角面</h3>
<ul>
<li>光栅化三角面的过程，主要是对每个三角面，通过 <code>rasterizeTri</code> 方法进行处理，其实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastRasterization.cpp

static bool rasterizeTri(const float* v0, const float* v1, const float* v2,
                         const unsigned char areaID, rcHeightfield&amp; heightfield,
                         const float* heightfieldBBMin, const float* heightfieldBBMax,
                         const float cellSize, const float inverseCellSize, const float inverseCellHeight,
                         const int flagMergeThreshold)
{
	// Calculate the bounding box of the triangle.
	float triBBMin[3];
	rcVcopy(triBBMin, v0);
	rcVmin(triBBMin, v1);
	rcVmin(triBBMin, v2);

	float triBBMax[3];
	rcVcopy(triBBMax, v0);
	rcVmax(triBBMax, v1);
	rcVmax(triBBMax, v2);

	// If the triangle does not touch the bounding box of the heightfield, skip the triangle.
	if (!overlapBounds(triBBMin, triBBMax, heightfieldBBMin, heightfieldBBMax))
	{
		return true;
	}

	const int w = heightfield.width;
	const int h = heightfield.height;
	const float by = heightfieldBBMax[1] - heightfieldBBMin[1];

	// Calculate the footprint of the triangle on the grid's z-axis
	int z0 = (int)((triBBMin[2] - heightfieldBBMin[2]) * inverseCellSize);
	int z1 = (int)((triBBMax[2] - heightfieldBBMin[2]) * inverseCellSize);

	// use -1 rather than 0 to cut the polygon properly at the start of the tile
	z0 = rcClamp(z0, -1, h - 1);
	z1 = rcClamp(z1, 0, h - 1);

	// Clip the triangle into all grid cells it touches.
	float buf[7 * 3 * 4];
	float* in = buf;
	float* inRow = buf + 7 * 3;
	float* p1 = inRow + 7 * 3;
	float* p2 = p1 + 7 * 3;

	rcVcopy(&amp;in[0], v0);
	rcVcopy(&amp;in[1 * 3], v1);
	rcVcopy(&amp;in[2 * 3], v2);
	int nvRow;
	int nvIn = 3;

	for (int z = z0; z &lt;= z1; ++z)
	{
		// Clip polygon to row. Store the remaining polygon as well
		const float cellZ = heightfieldBBMin[2] + (float)z * cellSize;
		dividePoly(in, nvIn, inRow, &amp;nvRow, p1, &amp;nvIn, cellZ + cellSize, RC_AXIS_Z);
		rcSwap(in, p1);
		
		if (nvRow &lt; 3)
		{
			continue;
		}
		if (z &lt; 0)
		{
			continue;
		}
		
		// find X-axis bounds of the row
		float minX = inRow[0];
		float maxX = inRow[0];
		for (int vert = 1; vert &lt; nvRow; ++vert)
		{
			if (minX &gt; inRow[vert * 3])
			{
				minX = inRow[vert * 3];
			}
			if (maxX &lt; inRow[vert * 3])
			{
				maxX = inRow[vert * 3];
			}
		}
		int x0 = (int)((minX - heightfieldBBMin[0]) * inverseCellSize);
		int x1 = (int)((maxX - heightfieldBBMin[0]) * inverseCellSize);
		if (x1 &lt; 0 || x0 &gt;= w)
		{
			continue;
		}
		x0 = rcClamp(x0, -1, w - 1);
		x1 = rcClamp(x1, 0, w - 1);

		int nv;
		int nv2 = nvRow;

		for (int x = x0; x &lt;= x1; ++x)
		{
			// Clip polygon to column. store the remaining polygon as well
			const float cx = heightfieldBBMin[0] + (float)x * cellSize;
			dividePoly(inRow, nv2, p1, &amp;nv, p2, &amp;nv2, cx + cellSize, RC_AXIS_X);
			rcSwap(inRow, p2);
			
			if (nv &lt; 3)
			{
				continue;
			}
			if (x &lt; 0)
			{
				continue;
			}
			
			// Calculate min and max of the span.
			float spanMin = p1[1];
			float spanMax = p1[1];
			for (int vert = 1; vert &lt; nv; ++vert)
			{
				spanMin = rcMin(spanMin, p1[vert * 3 + 1]);
				spanMax = rcMax(spanMax, p1[vert * 3 + 1]);
			}
			spanMin -= heightfieldBBMin[1];
			spanMax -= heightfieldBBMin[1];
			
			// Skip the span if it's completely outside the heightfield bounding box
			if (spanMax &lt; 0.0f)
			{
				continue;
			}
			if (spanMin &gt; by)
			{
				continue;
			}
			
			// Clamp the span to the heightfield bounding box.
			if (spanMin &lt; 0.0f)
			{
				spanMin = 0;
			}
			if (spanMax &gt; by)
			{
				spanMax = by;
			}

			// Snap the span to the heightfield height grid.
			unsigned short spanMinCellIndex = (unsigned short)rcClamp((int)floorf(spanMin * inverseCellHeight), 0, RC_SPAN_MAX_HEIGHT);
			unsigned short spanMaxCellIndex = (unsigned short)rcClamp((int)ceilf(spanMax * inverseCellHeight), (int)spanMinCellIndex + 1, RC_SPAN_MAX_HEIGHT);

			if (!addSpan(heightfield, x, z, spanMinCellIndex, spanMaxCellIndex, areaID, flagMergeThreshold))
			{
				return false;
			}
		}
	}

	return true;
}

...
</code></pre><ul>
<li>光栅化过程就是将三角面沿着 z 轴和 x 轴进行切分，再计算 y 高度，从而得到多个长方体，主要步骤如下：
<ul>
<li>计算三角面包围盒的最大最小值，检查包围盒是否和高度场的包围盒有交集，无交集则不需要处理。</li>
<li>将三角面包围盒的 z 坐标最大最小值，以高度场包围盒 z 坐标最小值为基准，转化为 <code>cell</code> 的 z' 表示。</li>
<li>将 z' 最小值限制为 [-1, heightfield.height - 1] ，最大值限制为 [0, heightfield.height - 1] 。</li>
<li>遍历 z' 坐标最小值到最大值区间，通过 <code>dividePoly</code> 方法，将三角面按 <code>cell</code> 的 z' 切分成多个多边形。</li>
<li>对每个切分后的多边形，计算包围盒的 x 坐标最大最小值，，以高度场包围盒 x 坐标最小值为基准，转化为 <code>cell</code> 的 x' 表示。</li>
<li>将 x' 最小值限制为 [-1, heightfield.width - 1] , 最大值限制为 [0, heightfield.width - 1] 。</li>
<li>遍历 x' 坐标最小值到最大值区间，通过 <code>dividePoly</code> 方法，将多边形按 <code>cell</code> 的 x' 坐标再切分成多个子多边形。</li>
<li>对每个子多边形，计算顶点的 y 坐标最大最小值，以高度场包围盒 y 坐标最小值为基准。</li>
<li>将顶点 y 坐标最大最小值，转换成 <code>cell</code> 索引 y' 表示，最小值为 [0, <code>RC_SPAN_MAX_HEIGHT</code>] ，最大值为 [最小值 + 1, <code>RC_SPAN_MAX_HEIGHT</code>] 。</li>
<li>调用 <code>addSpan</code> 方法，将当前 x' 、z' 对应的 <code>cell</code> 的 y' 索引区间，加入到高度场中。</li>
</ul>
</li>
<li>分割多边形方法 <code>dividePoly</code> 的实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastRasterization.cpp

static void dividePoly(const float* inVerts, int inVertsCount,
                       float* outVerts1, int* outVerts1Count,
                       float* outVerts2, int* outVerts2Count,
                       float axisOffset, rcAxis axis)
{
	rcAssert(inVertsCount &lt;= 12);
	
	// How far positive or negative away from the separating axis is each vertex.
	float inVertAxisDelta[12];
	for (int inVert = 0; inVert &lt; inVertsCount; ++inVert)
	{
		inVertAxisDelta[inVert] = axisOffset - inVerts[inVert * 3 + axis];
	}

	int poly1Vert = 0;
	int poly2Vert = 0;
	for (int inVertA = 0, inVertB = inVertsCount - 1; inVertA &lt; inVertsCount; inVertB = inVertA, ++inVertA)
	{
		// If the two vertices are on the same side of the separating axis
		bool sameSide = (inVertAxisDelta[inVertA] &gt;= 0) == (inVertAxisDelta[inVertB] &gt;= 0);

		if (!sameSide)
		{
			float s = inVertAxisDelta[inVertB] / (inVertAxisDelta[inVertB] - inVertAxisDelta[inVertA]);
			outVerts1[poly1Vert * 3 + 0] = inVerts[inVertB * 3 + 0] + (inVerts[inVertA * 3 + 0] - inVerts[inVertB * 3 + 0]) * s;
			outVerts1[poly1Vert * 3 + 1] = inVerts[inVertB * 3 + 1] + (inVerts[inVertA * 3 + 1] - inVerts[inVertB * 3 + 1]) * s;
			outVerts1[poly1Vert * 3 + 2] = inVerts[inVertB * 3 + 2] + (inVerts[inVertA * 3 + 2] - inVerts[inVertB * 3 + 2]) * s;
			rcVcopy(&amp;outVerts2[poly2Vert * 3], &amp;outVerts1[poly1Vert * 3]);
			poly1Vert++;
			poly2Vert++;
			
			// add the inVertA point to the right polygon. Do NOT add points that are on the dividing line
			// since these were already added above
			if (inVertAxisDelta[inVertA] &gt; 0)
			{
				rcVcopy(&amp;outVerts1[poly1Vert * 3], &amp;inVerts[inVertA * 3]);
				poly1Vert++;
			}
			else if (inVertAxisDelta[inVertA] &lt; 0)
			{
				rcVcopy(&amp;outVerts2[poly2Vert * 3], &amp;inVerts[inVertA * 3]);
				poly2Vert++;
			}
		}
		else
		{
			// add the inVertA point to the right polygon. Addition is done even for points on the dividing line
			if (inVertAxisDelta[inVertA] &gt;= 0)
			{
				rcVcopy(&amp;outVerts1[poly1Vert * 3], &amp;inVerts[inVertA * 3]);
				poly1Vert++;
				if (inVertAxisDelta[inVertA] != 0)
				{
					continue;
				}
			}
			rcVcopy(&amp;outVerts2[poly2Vert * 3], &amp;inVerts[inVertA * 3]);
			poly2Vert++;
		}
	}

	*outVerts1Count = poly1Vert;
	*outVerts2Count = poly2Vert;
}

...
</code></pre><ul>
<li>分割多边形的主要步骤为：
<ul>
<li>沿指定轴 <code>axis</code> 方向，计算分割面和每个顶点的的指定轴坐标差值，用于确定顶点是否在分割面以内。</li>
<li>遍历每一个顶点，根据当前顶点 A 和上一个顶点 B所处位置进行处理。
<ul>
<li>如果 A 、B 处在分割面两侧:
<ul>
<li>计算 B 点到分割面的距离占 AB 到分割面距离和的比例。</li>
<li>根据比例，通过 A 、B 的坐标插值得到 AB 和分割面的交点 C 坐标。</li>
<li>将 C 点加入到分割面内顶点列表 <code>outVerts1</code> 和分割面外顶点列表 <code>outVerts2</code> 中。</li>
<li>根据 A 点和分割面的位置关系，将 A 点加入到对应顶点列表中。</li>
</ul>
</li>
<li>如果 A 、B 处在分割面内侧，将 A 点加入到分割面内顶点列表 <code>outVerts1</code> 。</li>
<li>如果 A 、B 处在分割面外侧，将 A 点加入到分割面外顶点列表 <code>outVerts2</code> 。
<img src="/img/Algorithm/NavmeshNavigation/Nav2_1.gif?raw=true" alt=Nav2_1.png>
</li>
</ul>
</li>
</ul>
</li>
<li>高度场添加 <code>span</code> 信息 <code>addSpan</code> 方法的实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastRasterization.cpp




                   const int x, const int z,
                   const unsigned short min, const unsigned short max,
                   const unsigned char areaID, const int flagMergeThreshold)
{
   // Create the new span.
   rcSpan* newSpan = allocSpan(heightfield);
   if (newSpan == NULL)
   {
   	return false;
   }
   newSpan-&gt;smin = min;
   newSpan-&gt;smax = max;
   newSpan-&gt;area = areaID;
   newSpan-&gt;next = NULL;
   
   const int columnIndex = x + z * heightfield.width;
   rcSpan* previousSpan = NULL;
   rcSpan* currentSpan = heightfield.spans[columnIndex];
   
   // Insert the new span, possibly merging it with existing spans.
   while (currentSpan != NULL)
   {
   	if (currentSpan-&gt;smin &gt; newSpan-&gt;smax)
   	{
   		// Current span is completely after the new span, break.
   		break;
   	}
   	
   	if (currentSpan-&gt;smax &lt; newSpan-&gt;smin)
   	{
   		// Current span is completely before the new span.  Keep going.
   		previousSpan = currentSpan;
   		currentSpan = currentSpan-&gt;next;
   	}
   	else
   	{
   		// The new span overlaps with an existing span.  Merge them.
   		if (currentSpan-&gt;smin &lt; newSpan-&gt;smin)
   		{
   			newSpan-&gt;smin = currentSpan-&gt;smin;
   		}
   		if (currentSpan-&gt;smax &gt; newSpan-&gt;smax)
   		{
   			newSpan-&gt;smax = currentSpan-&gt;smax;
   		}
   		
   		// Merge flags.
   		if (rcAbs((int)newSpan-&gt;smax - (int)currentSpan-&gt;smax) &lt;= flagMergeThreshold)
   		{
   			// Higher area ID numbers indicate higher resolution priority.
   			newSpan-&gt;area = rcMax(newSpan-&gt;area, currentSpan-&gt;area);
   		}
   		
   		// Remove the current span since it's now merged with newSpan.
   		// Keep going because there might be other overlapping spans that also need to be merged.
   		rcSpan* next = currentSpan-&gt;next;
   		freeSpan(heightfield, currentSpan);
   		if (previousSpan)
   		{
   			previousSpan-&gt;next = next;
   		}
   		else
   		{
   			heightfield.spans[columnIndex] = next;
   		}
   		currentSpan = next;
   	}
   }
   
   // Insert new span after prev
   if (previousSpan != NULL)
   {
   	newSpan-&gt;next = previousSpan-&gt;next;
   	previousSpan-&gt;next = newSpan;
   }
   else
   {
   	// This span should go before the others in the list
   	newSpan-&gt;next = heightfield.spans[columnIndex];
   	heightfield.spans[columnIndex] = newSpan;
   }


}


</code></pre><ul>
<li><code>span</code> 信息即多边形的 y' 单元格坐标 <code>span</code>，在高度场中，<code>span</code> 信息通过链表存储，记录了每一个 <code>cell</code> 的所有 <code>span</code> 区间，区间按坐标从小到大顺序存储。插入新区间时，同样需要保持从小到大的顺序，找到插入位置。如果新区间和原有区间有相交，则会将两个区间进行合并。</li>
</ul>
<h1 id=三过滤可行走表面>三、过滤可行走表面</h1>
<ul>
<li>在三角面上行走，需要满足几个主要情况：
<ul>
<li>三角面的坡度较平缓，过于陡峭的坡度无法行走。</li>
<li>相邻三角面高度差较低，支持对象跨越。</li>
<li>相邻三角面的天花板和地面之间的最小距离足够大，支持对象通过。</li>
</ul>
</li>
<li>坡度的过滤在光栅化过程已经完成，此阶段不需要再处理。另外两个条件，通过三个过滤方式来处理。</li>
</ul>
<h2 id=处理低悬挂障碍物>处理低悬挂障碍物</h2>
<ul>
<li>通过 <code>rcFilterLowHangingWalkableObstacles</code> 方法，进行低悬挂障碍物的处理，其实现如下:</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastFilter.cpp

...

void rcFilterLowHangingWalkableObstacles(rcContext* context, const int walkableClimb, rcHeightfield&amp; heightfield)
{
	rcAssert(context);

	rcScopedTimer timer(context, RC_TIMER_FILTER_LOW_OBSTACLES);

	const int xSize = heightfield.width;
	const int zSize = heightfield.height;

	for (int z = 0; z &lt; zSize; ++z)
	{
		for (int x = 0; x &lt; xSize; ++x)
		{
			rcSpan* previousSpan = NULL;
			bool previousWasWalkable = false;
			unsigned char previousAreaID = RC_NULL_AREA;

			// For each span in the column...
			for (rcSpan* span = heightfield.spans[x + z * xSize]; span != NULL; previousSpan = span, span = span-&gt;next)
			{
				const bool walkable = span-&gt;area != RC_NULL_AREA;

				// If current span is not walkable, but there is walkable span just below it and the height difference
				// is small enough for the agent to walk over, mark the current span as walkable too.
				if (!walkable &amp;&amp; previousWasWalkable &amp;&amp; (int)span-&gt;smax - (int)previousSpan-&gt;smax &lt;= walkableClimb)
				{
					span-&gt;area = previousAreaID;
				}

				// Copy the original walkable value regardless of whether we changed it.
				// This prevents multiple consecutive non-walkable spans from being erroneously marked as walkable.
				previousWasWalkable = walkable;
				previousAreaID = span-&gt;area;
			}
		}
	}
}

...
</code></pre><ul>
<li>检查 xz 平面的每个 <code>cell</code> 的 <code>span</code> 列表，<code>span</code> 列表是从小到大排序的，当前 <code>span</code> 不可行走时，如果上一个 <code>span</code> 可行走，且当前 <code>span</code> 的地面 <code>span->max</code> 和上一个 <code>span</code> 的地面 <code>previousSpan->max</code> 的差不超过可跨域距离 <code>walkableClimb</code> ，则将当前 <code>span->area</code> 标记为可行走区域。</li>
<li>加入此检查，可以避免角色因低障碍物（如：门槛、小台阶等）而受到阻挡无法行走，以及对于一些悬挂的障碍（如：桥梁、屋檐）等，可以支持角色跨越通过。</li>
</ul>
<h2 id=处理边缘跨度>处理边缘跨度</h2>
<ul>
<li>处理边缘 <code>span</code> 的方法 <code>rcFilterLedgeSpans</code> 如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastFilter.cpp

...

void rcFilterLedgeSpans(rcContext* context, const int walkableHeight, const int walkableClimb, rcHeightfield&amp; heightfield)
{
	rcAssert(context);
	
	rcScopedTimer timer(context, RC_TIMER_FILTER_BORDER);

	const int xSize = heightfield.width;
	const int zSize = heightfield.height;
	
	// Mark spans that are adjacent to a ledge as unwalkable..
	for (int z = 0; z &lt; zSize; ++z)
	{
		for (int x = 0; x &lt; xSize; ++x)
		{
			for (rcSpan* span = heightfield.spans[x + z * xSize]; span; span = span-&gt;next)
			{
				// Skip non-walkable spans.
				if (span-&gt;area == RC_NULL_AREA)
				{
					continue;
				}

				const int floor = (int)(span-&gt;smax);
				const int ceiling = span-&gt;next ? (int)(span-&gt;next-&gt;smin) : MAX_HEIGHTFIELD_HEIGHT;

				// The difference between this walkable area and the lowest neighbor walkable area.
				// This is the difference between the current span and all neighbor spans that have
				// enough space for an agent to move between, but not accounting at all for surface slope.
				int lowestNeighborFloorDifference = MAX_HEIGHTFIELD_HEIGHT;

				// Min and max height of accessible neighbours.
				int lowestTraversableNeighborFloor = span-&gt;smax;
				int highestTraversableNeighborFloor = span-&gt;smax;

				for (int direction = 0; direction &lt; 4; ++direction)
				{
					const int neighborX = x + rcGetDirOffsetX(direction);
					const int neighborZ = z + rcGetDirOffsetY(direction);

					// Skip neighbours which are out of bounds.
					if (neighborX &lt; 0 || neighborZ &lt; 0 || neighborX &gt;= xSize || neighborZ &gt;= zSize)
					{
						lowestNeighborFloorDifference = -walkableClimb - 1;
						break;
					}

					const rcSpan* neighborSpan = heightfield.spans[neighborX + neighborZ * xSize];

					// The most we can step down to the neighbor is the walkableClimb distance.
					// Start with the area under the neighbor span
					int neighborCeiling = neighborSpan ? (int)neighborSpan-&gt;smin : MAX_HEIGHTFIELD_HEIGHT;

					// Skip neighbour if the gap between the spans is too small.
					if (rcMin(ceiling, neighborCeiling) - floor &gt;= walkableHeight)
					{
						lowestNeighborFloorDifference = (-walkableClimb - 1);
						break;
					}

					// For each span in the neighboring column...
					for (; neighborSpan != NULL; neighborSpan = neighborSpan-&gt;next)
					{
						const int neighborFloor = (int)neighborSpan-&gt;smax;
						neighborCeiling = neighborSpan-&gt;next ? (int)neighborSpan-&gt;next-&gt;smin : MAX_HEIGHTFIELD_HEIGHT;

						// Only consider neighboring areas that have enough overlap to be potentially traversable.
						if (rcMin(ceiling, neighborCeiling) - rcMax(floor, neighborFloor) &lt; walkableHeight)
						{
							// No space to traverse between them.
							continue;
						}

						const int neighborFloorDifference = neighborFloor - floor;
						lowestNeighborFloorDifference = rcMin(lowestNeighborFloorDifference, neighborFloorDifference);

						// Find min/max accessible neighbor height.
						// Only consider neighbors that are at most walkableClimb away.
						if (rcAbs(neighborFloorDifference) &lt;= walkableClimb)
						{
							// There is space to move to the neighbor cell and the slope isn't too much.
							lowestTraversableNeighborFloor = rcMin(lowestTraversableNeighborFloor, neighborFloor);
							highestTraversableNeighborFloor = rcMax(highestTraversableNeighborFloor, neighborFloor);
						}
						else if (neighborFloorDifference &lt; -walkableClimb)
						{
							// We already know this will be considered a ledge span so we can early-out
							break;
						}
					}
				}

				// The current span is close to a ledge if the magnitude of the drop to any neighbour span is greater than the walkableClimb distance.
				// That is, there is a gap that is large enough to let an agent move between them, but the drop (surface slope) is too large to allow it.
				// (If this is the case, then biggestNeighborStepDown will be negative, so compare against the negative walkableClimb as a means of checking
				// the magnitude of the delta)
				if (lowestNeighborFloorDifference &lt; -walkableClimb)
				{
					span-&gt;area = RC_NULL_AREA;
				}
				// If the difference between all neighbor floors is too large, this is a steep slope, so mark the span as an unwalkable ledge.
				else if (highestTraversableNeighborFloor - lowestTraversableNeighborFloor &gt; walkableClimb)
				{
					span-&gt;area = RC_NULL_AREA;
				}
			}
		}
	}
}

...
</code></pre><ul>
<li>和低障碍处理类似，需要对 xz 平面上，每一个 <code>cell</code> 的 <code>span</code> 列表 <code>heightfield.spans</code> 中的每一个 <code>span</code> 进行处理，处理流程大致如下：
<ul>
<li>下一个跨度的天花板 <code>span->next->smin</code> 和任一邻居跨度列表中的首个跨度天花板 <code>neightborSpan->smin</code>，二者中的较小值，和当前跨度的地面 <code>span->smax</code> 的差值，不小于 <code>walkableHeight</code> 时，表示当前跨度和某个邻居存在较大的高度差，尽管可能只有一个方向存在危险，处于安全考虑，将当前跨度标记为不可行走，避免因局部地形问题卡住。</li>
<li>检查当前跨度和邻居跨度列表的每个跨度，当两者交集不小于 <code>walkableHeight</code> 且地面高度差不大于 <code>walkableClimb</code> 时，认为此邻居跨度为可行走跨度，从所有可行走邻居跨度中，找出最大和最小的地面高度。</li>
<li>如果最大最小地面高度差超过 <code>walkableClimb</code> ，则认为当前跨度为一个陡坡，将其 <code>span->area</code> 标记为不可行走。</li>
</ul>
</li>
<li>处理边缘 <code>span</code> 采用保守策略，对于高度差较大的 <code>span</code>，都选择标记为不可行走，减少特殊地形带来的角色移动表现问题的出现。</li>
</ul>
<h2 id=处理低高度跨度>处理低高度跨度</h2>
<ul>
<li>低高度 <code>span</code> 处理，主要是为了确保对象有足够空间可以在表面站立，才能够正常行走，通过 <code>rcFilterWalkableLowHeightSpans</code> 方法实现，代码如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastFilter.cpp

...

void rcFilterWalkableLowHeightSpans(rcContext* context, const int walkableHeight, rcHeightfield&amp; heightfield)
{
	rcAssert(context);
	rcScopedTimer timer(context, RC_TIMER_FILTER_WALKABLE);

	const int xSize = heightfield.width;
	const int zSize = heightfield.height;

	// Remove walkable flag from spans which do not have enough
	// space above them for the agent to stand there.
	for (int z = 0; z &lt; zSize; ++z)
	{
		for (int x = 0; x &lt; xSize; ++x)
		{
			for (rcSpan* span = heightfield.spans[x + z*xSize]; span; span = span-&gt;next)
			{
				const int floor = (int)(span-&gt;smax);
				const int ceiling = span-&gt;next ? (int)(span-&gt;next-&gt;smin) : MAX_HEIGHTFIELD_HEIGHT;
				if (ceiling - floor &lt; walkableHeight)
				{
					span-&gt;area = RC_NULL_AREA;
				}
			}
		}
	}
}
</code></pre><ul>
<li>低高度 <code>span</code> 处理相对比较简单，就是对每一个 <code>span</code> 做检查，如果当前 <code>span</code> 的天花板（即下一个的最小值 <code>span->next->smin</code>）和地面（<code>span->smax</code>）的高度差小于 <code>walkableHeight</code> ，即当前 <code>span</code> 不支持站立，则标记 <code>span->area</code> 为不可行走。</li>
</ul>
<h1 id=四将可行走表面划分为地区>四、将可行走表面划分为地区</h1>
<h2 id=建立紧密高度场>建立紧密高度场</h2>
<ul>
<li>经过上一步处理后，得到了一个高度场，高度场的结构如下：</li>
</ul>
<pre tabindex=0><code>// 高度场
struct rcHeightfield
{
...
	int width;			/// 高度场的宽度（沿 x 轴的单元格数量）
	int height;			/// 高度场的宽度（沿 z 轴的单元格数量）
	float bmin[3];  	/// 高度场在世界空间中的最小边界。 [(x, y, z)]
	float bmax[3];		/// 高度场在世界空间中的最大边界。 [(x, y, z)]
	float cs;			/// 每个单元格的大小（在 xz 平面上）
	float ch;			/// 每个单元格的高度（沿 y 轴的最小增量）
	rcSpan** spans;		/// 高度场的跨度列表，列表包括所有单元格，每个单元格为一个跨度链表

	rcSpanPool* pools;	/// 跨度链表对象池
	rcSpan* freelist;	/// 跨度链表对象池的可用跨度对象列表
...
};


struct rcSpan
{
	unsigned int smin : RC_SPAN_HEIGHT_BITS; /// 跨度的最小值，smin &lt; smax
	unsigned int smax : RC_SPAN_HEIGHT_BITS; /// 跨度的最大值，smax &lt;= RC_SPAN_MAX_HEIGHT
	unsigned int area : 6;                   /// 跨度所属区域 id
	rcSpan* next;                            /// 下一个更高的跨度
};
</code></pre><ul>
<li>其中，<code>spans</code> 数组长度为 <code>width * height</code> ，每个元素指向一个 <code>span</code> 链表，数据存储比较离散，不利于后续处理过程频繁访问，因此需要转换成更加紧凑的形式，即紧密高度场，其结构如下：</li>
</ul>
<pre tabindex=0><code>// 紧密高度场
struct rcCompactHeightfield
{
	...
	int width;					/// 同 rcHeightfield::width
	int height;					/// 同 rcHeightfield::height
	int spanCount;				/// rcHeightfield 中的跨度总数
	int walkableHeight;			/// 同 rcConfig::walkableHeight
	int walkableClimb;			/// 同 rcConfig::walkableClimb
	int borderSize;				/// 同 rcConfig::borderSize
	unsigned short maxDistance;	/// 高度场中两个跨度的最大距离
	unsigned short maxRegions;	/// 高度场中的最大地区id
	float bmin[3];				/// 同 rcHeightfield
	float bmax[3];				/// 同 rcHeightfield
	float cs;					/// 同 rcHeightfield
	float ch;					/// 同 rcHeightfield
	rcCompactCell* cells;		/// 单元格数组，数量为 width * height
	rcCompactSpan* spans;		/// 跨度数组，数量为 spanCount
	unsigned short* dist;		/// 跨度和边界的距离数组，数量为 spanCount
	unsigned char* areas;		/// 区域id数组，数量为 spanCount
	
	...
};


struct rcCompactCell
{
	unsigned int index : 24;	/// 当前单元格的首个跨度在的索引 id
	unsigned int count : 8;		/// 当前单元格的跨度数量
};

struct rcCompactSpan
{
	unsigned short y;			/// 当前跨度的地面高度，即 smax
	unsigned short reg;			/// 当前跨度所属的地区 id
	unsigned int con : 24;		/// 连通的邻居数据
	unsigned int h : 8;			/// 下一跨度的天花板到当前跨度的地面高度差，即 next-&gt;smin - smax
};
</code></pre><ul>
<li>建立紧密高度场的方法 <code>rcBuildCompactHeightfield</code> 如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/Recast.cpp

...

bool rcBuildCompactHeightfield(rcContext* context, const int walkableHeight, const int walkableClimb,
                               const rcHeightfield&amp; heightfield, rcCompactHeightfield&amp; compactHeightfield)
{
	...

	const int MAX_HEIGHT = 0xffff;

	// Fill in cells and spans.
	int currentCellIndex = 0;
	const int numColumns = xSize * zSize;
	for (int columnIndex = 0; columnIndex &lt; numColumns; ++columnIndex)
	{
		const rcSpan* span = heightfield.spans[columnIndex];
			
		// If there are no spans at this cell, just leave the data to index=0, count=0.
		if (span == NULL)
		{
			continue;
		}
			
		rcCompactCell&amp; cell = compactHeightfield.cells[columnIndex];
		cell.index = currentCellIndex;
		cell.count = 0;

		for (; span != NULL; span = span-&gt;next)
		{
			if (span-&gt;area != RC_NULL_AREA)
			{
				const int bot = (int)span-&gt;smax;
				const int top = span-&gt;next ? (int)span-&gt;next-&gt;smin : MAX_HEIGHT;
				compactHeightfield.spans[currentCellIndex].y = (unsigned short)rcClamp(bot, 0, 0xffff);
				compactHeightfield.spans[currentCellIndex].h = (unsigned char)rcClamp(top - bot, 0, 0xff);
				compactHeightfield.areas[currentCellIndex] = span-&gt;area;
				currentCellIndex++;
				cell.count++;
			}
		}
	}
	
	// Find neighbour connections.
	const int MAX_LAYERS = RC_NOT_CONNECTED - 1;
	int maxLayerIndex = 0;
	const int zStride = xSize; // for readability
	for (int z = 0; z &lt; zSize; ++z)
	{
		for (int x = 0; x &lt; xSize; ++x)
		{
			const rcCompactCell&amp; cell = compactHeightfield.cells[x + z * zStride];
			for (int i = (int)cell.index, ni = (int)(cell.index + cell.count); i &lt; ni; ++i)
			{
				rcCompactSpan&amp; span = compactHeightfield.spans[i];

				for (int dir = 0; dir &lt; 4; ++dir)
				{
					rcSetCon(span, dir, RC_NOT_CONNECTED);
					const int neighborX = x + rcGetDirOffsetX(dir);
					const int neighborZ = z + rcGetDirOffsetY(dir);
					// First check that the neighbour cell is in bounds.
					if (neighborX &lt; 0 || neighborZ &lt; 0 || neighborX &gt;= xSize || neighborZ &gt;= zSize)
					{
						continue;
					}

					// Iterate over all neighbour spans and check if any of the is
					// accessible from current cell.
					const rcCompactCell&amp; neighborCell = compactHeightfield.cells[neighborX + neighborZ * zStride];
					for (int k = (int)neighborCell.index, nk = (int)(neighborCell.index + neighborCell.count); k &lt; nk; ++k)
					{
						const rcCompactSpan&amp; neighborSpan = compactHeightfield.spans[k];
						const int bot = rcMax(span.y, neighborSpan.y);
						const int top = rcMin(span.y + span.h, neighborSpan.y + neighborSpan.h);

						// Check that the gap between the spans is walkable,
						// and that the climb height between the gaps is not too high.
						if ((top - bot) &gt;= walkableHeight &amp;&amp; rcAbs((int)neighborSpan.y - (int)span.y) &lt;= walkableClimb)
						{
							// Mark direction as walkable.
							const int layerIndex = k - (int)neighborCell.index;
							if (layerIndex &lt; 0 || layerIndex &gt; MAX_LAYERS)
							{
								maxLayerIndex = rcMax(maxLayerIndex, layerIndex);
								continue;
							}
							rcSetCon(span, dir, layerIndex);
							break;
						}
					}
				}
			}
		}
	}

	if (maxLayerIndex &gt; MAX_LAYERS)
	{
		context-&gt;log(RC_LOG_ERROR, &quot;rcBuildCompactHeightfield: Heightfield has too many layers %d (max: %d)&quot;,
		         maxLayerIndex, MAX_LAYERS);
	}

	return true;
}

...
</code></pre><ul>
<li>建立过程，每个 <code>cell</code> 记录了其中首个 <code>span</code> 的索引及 <code>span</code> 的数量。所有 <code>cell</code> 的 <code>span</code> 都存入到 <code>compactHeightfield.spans</code> 中，其中 <code>y</code> 为当前 <code>span</code> 的地面高度 <code>span->smax</code>，<code>h</code> 为下一 <code>span</code> 的天花板到当前 <code>span</code> 地面的高度差 <code>span->next->smin - span->smax</code>。</li>
<li>除了设置基础信息外，还需要计算每个 <code>span</code> 的连通信息。每个 <code>span</code> 会和邻居 <code>cell</code> 的 <code>spans</code> 列表进行计算，当前 <code>span</code> 和邻居连通，需要满足以下条件：
<ul>
<li>当前 <code>span</code> 和邻居中的任意 <code>spans[index]</code> ，两者的天花板高度 <code>y + h</code> 最小值和地面高度 <code>y</code> 最大值之差，不小于 <code>walkableHeight</code>，即存在一个邻居 <code>span</code> 可以从当前 <code>span</code> 通行。</li>
<li>当前 <code>span</code> 和邻居中的任意 <code>spans[index]</code> ，两者的地面高度 <code>y</code> 之差，不大于 <code>walkableClimb</code>，即存在一个邻居 <code>span</code> 可以从当前 <code>span</code> 跨过。</li>
</ul>
</li>
<li>设置连通的方法 <code>rcSetCon</code> 的实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Include/Recast.h

...

inline void rcSetCon(rcCompactSpan&amp; span, int direction, int neighborIndex)
{
	const unsigned int shift = (unsigned int)direction * 6;
	const unsigned int con = span.con;
	span.con = (con &amp; ~(0x3f &lt;&lt; shift)) | (((unsigned int)neighborIndex &amp; 0x3f) &lt;&lt; shift);
}

...
</code></pre><ul>
<li>方向为左上右下，分别对应 0 ~ 3 ，每个方向使用一个 6 位的值，代表在邻居 <code>cell</code> 中的第几个 <code>span</code> ，每个 <code>cell</code> 最多能有 62 个 <code>span</code> 。某个方向设置了连通后，则不再检查该方向后续的 <code>span</code>，即取首个可连通的 <code>span</code>。</li>
</ul>
<h2 id=收缩可行走区域>收缩可行走区域</h2>
<ul>
<li>为了防止移动过程由于太靠近障碍边缘而出现问题，需要将可行走区域沿着障碍边缘进行收缩。收缩过程由 <code>rcErodeWalkableArea</code> 方法实现，主要分为三个步骤：
<ul>
<li>计算整个区域的边缘 <code>span</code> ，其和边缘的距离 <code>distanceToBoundary[spanIndex]</code> 设置为 0。</li>
<li>计算每个非边缘 <code>span</code> 和边缘的距离。</li>
<li>将距离小于阈值（<code>walkableRadius * 2</code>）的 <code>compactHeightfield.areas[spanIndex]</code> 设置为不可通行。</li>
</ul>
</li>
<li>计算区域边缘的实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastArea.cpp

...
bool rcErodeWalkableArea(rcContext* context, const int erosionRadius, rcCompactHeightfield&amp; compactHeightfield)
{
	rcAssert(context != NULL);

	const int xSize = compactHeightfield.width;
	const int zSize = compactHeightfield.height;
	const int&amp; zStride = xSize; // For readability

	rcScopedTimer timer(context, RC_TIMER_ERODE_AREA);

	unsigned char* distanceToBoundary = (unsigned char*)rcAlloc(sizeof(unsigned char) * compactHeightfield.spanCount,
	                                                            RC_ALLOC_TEMP);
	if (!distanceToBoundary)
	{
		context-&gt;log(RC_LOG_ERROR, &quot;erodeWalkableArea: Out of memory 'dist' (%d).&quot;, compactHeightfield.spanCount);
		return false;
	}
	memset(distanceToBoundary, 0xff, sizeof(unsigned char) * compactHeightfield.spanCount);
	
	// Mark boundary cells.
	for (int z = 0; z &lt; zSize; ++z)
	{
		for (int x = 0; x &lt; xSize; ++x)
		{
			const rcCompactCell&amp; cell = compactHeightfield.cells[x + z * zStride];
			for (int spanIndex = (int)cell.index, maxSpanIndex = (int)(cell.index + cell.count); spanIndex &lt; maxSpanIndex; ++spanIndex)
			{
				if (compactHeightfield.areas[spanIndex] == RC_NULL_AREA)
				{
					distanceToBoundary[spanIndex] = 0;
					continue;
				}
				const rcCompactSpan&amp; span = compactHeightfield.spans[spanIndex];

				// Check that there is a non-null adjacent span in each of the 4 cardinal directions.
				int neighborCount = 0;
				for (int direction = 0; direction &lt; 4; ++direction)
				{
					const int neighborConnection = rcGetCon(span, direction);
					if (neighborConnection == RC_NOT_CONNECTED)
					{
						break;
					}
					
					const int neighborX = x + rcGetDirOffsetX(direction);
					const int neighborZ = z + rcGetDirOffsetY(direction);
					const int neighborSpanIndex = (int)compactHeightfield.cells[neighborX + neighborZ * zStride].index + neighborConnection;
					
					if (compactHeightfield.areas[neighborSpanIndex] == RC_NULL_AREA)
					{
						break;
					}
					neighborCount++;
				}
				
				// At least one missing neighbour, so this is a boundary cell.
				if (neighborCount != 4)
				{
					distanceToBoundary[spanIndex] = 0;
				}
			}
		}
	}
	
	...
}
...
</code></pre><ul>
<li>首先建立了 <code>distanceToBoundary</code> 用于记录每个 <code>span</code> 和边缘的距离。其中不可行走的 <code>span</code>（<code>area</code> 为 <code>RC_NULL_AREA</code>）即为边缘，将其 <code>distanceToBoundary[spanIndex]</code> 设为 0。检查四个邻居方向，如果有一个方向不可行走，则将该 <code>span</code> 也视为边缘，设置其距离为 0。</li>
<li>得到所有边缘数据后，就需要计算每个 <code>span</code> 和边缘的距离，计算过程如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastArea.cpp

...
bool rcErodeWalkableArea(rcContext* context, const int erosionRadius, rcCompactHeightfield&amp; compactHeightfield)
{
	...
	
	unsigned char newDistance;
	
	// Pass 1
	for (int z = 0; z &lt; zSize; ++z)
	{
		for (int x = 0; x &lt; xSize; ++x)
		{
			const rcCompactCell&amp; cell = compactHeightfield.cells[x + z * zStride];
			const int maxSpanIndex = (int)(cell.index + cell.count);
			for (int spanIndex = (int)cell.index; spanIndex &lt; maxSpanIndex; ++spanIndex)
			{
				const rcCompactSpan&amp; span = compactHeightfield.spans[spanIndex];

				if (rcGetCon(span, 0) != RC_NOT_CONNECTED)
				{
					// (-1,0)
					const int aX = x + rcGetDirOffsetX(0);
					const int aY = z + rcGetDirOffsetY(0);
					const int aIndex = (int)compactHeightfield.cells[aX + aY * xSize].index + rcGetCon(span, 0);
					const rcCompactSpan&amp; aSpan = compactHeightfield.spans[aIndex];
					newDistance = (unsigned char)rcMin((int)distanceToBoundary[aIndex] + 2, 255);
					if (newDistance &lt; distanceToBoundary[spanIndex])
					{
						distanceToBoundary[spanIndex] = newDistance;
					}

					// (-1,-1)
					if (rcGetCon(aSpan, 3) != RC_NOT_CONNECTED)
					{
						const int bX = aX + rcGetDirOffsetX(3);
						const int bY = aY + rcGetDirOffsetY(3);
						const int bIndex = (int)compactHeightfield.cells[bX + bY * xSize].index + rcGetCon(aSpan, 3);
						newDistance = (unsigned char)rcMin((int)distanceToBoundary[bIndex] + 3, 255);
						if (newDistance &lt; distanceToBoundary[spanIndex])
						{
							distanceToBoundary[spanIndex] = newDistance;
						}
					}
				}
				if (rcGetCon(span, 3) != RC_NOT_CONNECTED)
				{
					// (0,-1)
					const int aX = x + rcGetDirOffsetX(3);
					const int aY = z + rcGetDirOffsetY(3);
					const int aIndex = (int)compactHeightfield.cells[aX + aY * xSize].index + rcGetCon(span, 3);
					const rcCompactSpan&amp; aSpan = compactHeightfield.spans[aIndex];
					newDistance = (unsigned char)rcMin((int)distanceToBoundary[aIndex] + 2, 255);
					if (newDistance &lt; distanceToBoundary[spanIndex])
					{
						distanceToBoundary[spanIndex] = newDistance;
					}

					// (1,-1)
					if (rcGetCon(aSpan, 2) != RC_NOT_CONNECTED)
					{
						const int bX = aX + rcGetDirOffsetX(2);
						const int bY = aY + rcGetDirOffsetY(2);
						const int bIndex = (int)compactHeightfield.cells[bX + bY * xSize].index + rcGetCon(aSpan, 2);
						newDistance = (unsigned char)rcMin((int)distanceToBoundary[bIndex] + 3, 255);
						if (newDistance &lt; distanceToBoundary[spanIndex])
						{
							distanceToBoundary[spanIndex] = newDistance;
						}
					}
				}
			}
		}
	}

	// Pass 2
	for (int z = zSize - 1; z &gt;= 0; --z)
	{
		for (int x = xSize - 1; x &gt;= 0; --x)
		{
			const rcCompactCell&amp; cell = compactHeightfield.cells[x + z * zStride];
			const int maxSpanIndex = (int)(cell.index + cell.count);
			for (int spanIndex = (int)cell.index; spanIndex &lt; maxSpanIndex; ++spanIndex)
			{
				const rcCompactSpan&amp; span = compactHeightfield.spans[spanIndex];

				if (rcGetCon(span, 2) != RC_NOT_CONNECTED)
				{
					// (1,0)
					const int aX = x + rcGetDirOffsetX(2);
					const int aY = z + rcGetDirOffsetY(2);
					const int aIndex = (int)compactHeightfield.cells[aX + aY * xSize].index + rcGetCon(span, 2);
					const rcCompactSpan&amp; aSpan = compactHeightfield.spans[aIndex];
					newDistance = (unsigned char)rcMin((int)distanceToBoundary[aIndex] + 2, 255);
					if (newDistance &lt; distanceToBoundary[spanIndex])
					{
						distanceToBoundary[spanIndex] = newDistance;
					}

					// (1,1)
					if (rcGetCon(aSpan, 1) != RC_NOT_CONNECTED)
					{
						const int bX = aX + rcGetDirOffsetX(1);
						const int bY = aY + rcGetDirOffsetY(1);
						const int bIndex = (int)compactHeightfield.cells[bX + bY * xSize].index + rcGetCon(aSpan, 1);
						newDistance = (unsigned char)rcMin((int)distanceToBoundary[bIndex] + 3, 255);
						if (newDistance &lt; distanceToBoundary[spanIndex])
						{
							distanceToBoundary[spanIndex] = newDistance;
						}
					}
				}
				if (rcGetCon(span, 1) != RC_NOT_CONNECTED)
				{
					// (0,1)
					const int aX = x + rcGetDirOffsetX(1);
					const int aY = z + rcGetDirOffsetY(1);
					const int aIndex = (int)compactHeightfield.cells[aX + aY * xSize].index + rcGetCon(span, 1);
					const rcCompactSpan&amp; aSpan = compactHeightfield.spans[aIndex];
					newDistance = (unsigned char)rcMin((int)distanceToBoundary[aIndex] + 2, 255);
					if (newDistance &lt; distanceToBoundary[spanIndex])
					{
						distanceToBoundary[spanIndex] = newDistance;
					}

					// (-1,1)
					if (rcGetCon(aSpan, 0) != RC_NOT_CONNECTED)
					{
						const int bX = aX + rcGetDirOffsetX(0);
						const int bY = aY + rcGetDirOffsetY(0);
						const int bIndex = (int)compactHeightfield.cells[bX + bY * xSize].index + rcGetCon(aSpan, 0);
						newDistance = (unsigned char)rcMin((int)distanceToBoundary[bIndex] + 3, 255);
						if (newDistance &lt; distanceToBoundary[spanIndex])
						{
							distanceToBoundary[spanIndex] = newDistance;
						}
					}
				}
			}
		}
	}

	...
}
...
</code></pre><ul>
<li>计算 <code>span</code> 到边缘的最小距离，最简单的做法就是计算其到每个边缘的距离，再从中取出最小值，显然效率非常低。这里使用了 <a href=https://fallingxun.github.io/post/algorithm/algorithm_edt/>8SSEDT 光栅扫描算法</a> 来优化计算，做了两次扫描，这里按坐标原点在左下角计算，具体流程为：
<ul>
<li>从下到上扫描，获取左、左下、下、右下邻居 <code>span</code> 的距离，分别加上其到当前 <code>span</code> 的距离，取其中最小值作为当前 <code>span</code> 的距离。</li>
<li>从上到下扫描，获取右、右上、上、左上邻居 <code>span</code> 的距离，分别加上其到当前 <code>span</code> 的距离，取其中最小值作为当前 <code>span</code> 的距离。</li>
</ul>
</li>
<li>其中，水平竖直方向的邻居和当前 <code>span</code> 的距离设置为 2，对角线邻居和当前 <code>span</code> 的距离设置为 3，对角线邻居和水平竖直邻居的距离比为 1.5，接近 1.414，通过近似的结果来避免过程计算中出现频繁开根号的情况。扫描完成后，即可得到整个区域的距离场。</li>
<li>确定每个 <code>span</code> 的距离后，即可通过比较距离和阈值的大小，来确定是否可通行，实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastArea.cpp

...
bool rcErodeWalkableArea(rcContext* context, const int erosionRadius, rcCompactHeightfield&amp; compactHeightfield)
{
	...

	const unsigned char minBoundaryDistance = (unsigned char)(erosionRadius * 2);
	for (int spanIndex = 0; spanIndex &lt; compactHeightfield.spanCount; ++spanIndex)
	{
		if (distanceToBoundary[spanIndex] &lt; minBoundaryDistance)
		{
			compactHeightfield.areas[spanIndex] = RC_NULL_AREA;
		}
	}

	rcFree(distanceToBoundary);
	
	return true;
}
...
</code></pre><ul>
<li>为了尽可能远离边缘，使用两倍的 <code>walkableRadius</code> 作为阈值划分，小于这个值的，该 <code>span</code> 的 <code>area</code> 都要标记为不可通行。</li>
</ul>
<h2 id=标记凸多边形区域>标记凸多边形区域</h2>
<ul>
<li>地图编辑过程，可能会预先对一些区域进行标记，如：不可通行、特殊区域（水池、草地等），此时则需要通过 <code>rcMarkConvexPolyArea</code> 方法将这些区域更新到 <code>area</code> 中，其实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastArea.cpp

...
void rcMarkConvexPolyArea(rcContext* context, const float* verts, const int numVerts,
						  const float minY, const float maxY, unsigned char areaId,
						  rcCompactHeightfield&amp; compactHeightfield)
{
	rcAssert(context);

	rcScopedTimer timer(context, RC_TIMER_MARK_CONVEXPOLY_AREA);

	const int xSize = compactHeightfield.width;
	const int zSize = compactHeightfield.height;
	const int zStride = xSize; // For readability

	// Compute the bounding box of the polygon
	float bmin[3];
	float bmax[3];
	rcVcopy(bmin, verts);
	rcVcopy(bmax, verts);
	for (int i = 1; i &lt; numVerts; ++i)
	{
		rcVmin(bmin, &amp;verts[i * 3]);
		rcVmax(bmax, &amp;verts[i * 3]);
	}
	bmin[1] = minY;
	bmax[1] = maxY;

	// Compute the grid footprint of the polygon 
	int minx = (int)((bmin[0] - compactHeightfield.bmin[0]) / compactHeightfield.cs);
	int miny = (int)((bmin[1] - compactHeightfield.bmin[1]) / compactHeightfield.ch);
	int minz = (int)((bmin[2] - compactHeightfield.bmin[2]) / compactHeightfield.cs);
	int maxx = (int)((bmax[0] - compactHeightfield.bmin[0]) / compactHeightfield.cs);
	int maxy = (int)((bmax[1] - compactHeightfield.bmin[1]) / compactHeightfield.ch);
	int maxz = (int)((bmax[2] - compactHeightfield.bmin[2]) / compactHeightfield.cs);

	// Early-out if the polygon lies entirely outside the grid.
	if (maxx &lt; 0) { return; }
    if (minx &gt;= xSize) { return; }
    if (maxz &lt; 0) { return; }
    if (minz &gt;= zSize) { return; }

	// Clamp the polygon footprint to the grid
    if (minx &lt; 0) { minx = 0; }
    if (maxx &gt;= xSize) { maxx = xSize - 1; }
    if (minz &lt; 0) { minz = 0; }
    if (maxz &gt;= zSize) { maxz = zSize - 1; }

	// TODO: Optimize.
	for (int z = minz; z &lt;= maxz; ++z)
	{
		for (int x = minx; x &lt;= maxx; ++x)
		{
			const rcCompactCell&amp; cell = compactHeightfield.cells[x + z * zStride];
			const int maxSpanIndex = (int)(cell.index + cell.count);
			for (int spanIndex = (int)cell.index; spanIndex &lt; maxSpanIndex; ++spanIndex)
			{
				rcCompactSpan&amp; span = compactHeightfield.spans[spanIndex];

				// Skip if span is removed.
				if (compactHeightfield.areas[spanIndex] == RC_NULL_AREA)
				{
					continue;
				}

				// Skip if y extents don't overlap.
				if ((int)span.y &lt; miny || (int)span.y &gt; maxy)
				{
					continue;
				}

				const float point[] = {
					compactHeightfield.bmin[0] + ((float)x + 0.5f) * compactHeightfield.cs,
					0,
					compactHeightfield.bmin[2] + ((float)z + 0.5f) * compactHeightfield.cs
				};
				
				if (pointInPoly(numVerts, verts, point))
				{
					compactHeightfield.areas[spanIndex] = areaId;
				}
			}
		}
	}
}

...
</code></pre><ul>
<li>根据多边形的顶点，计算出多边形的包围盒信息，找到紧密高度场中对应的 <code>cell</code> ，遍历其中的 <code>span</code> ，找到可通行且和包围盒相交的 <code>span</code>，计算其中心点在 xz 平面上的点。如果该点在多边形的投影面内，则表示该 <code>span</code> 属于当前的多边形，将其 <code>area</code> 设置为多边形的 <code>areaId</code> 。</li>
</ul>
<h2 id=建立地区>建立地区</h2>
<ul>
<li>建立地区有几种算法：
<ul>
<li>分水岭划分（SAMPLE_PARTITION_WATERSHED）</li>
<li>单调划分（SAMPLE_PARTITION_MONOTONE）</li>
<li>分层划分（SAMPLE_PARTITION_LAYERS）</li>
</ul>
</li>
</ul>
<h3 id=分水岭划分>分水岭划分</h3>
<ul>
<li>分水岭划分算法，需要通过 <code>rcBuildDistanceField</code> 先建立紧密高度场对应的高度场，包括两个步骤：
<ul>
<li><code>calculateDistanceField</code> 计算高度场。</li>
<li><code>boxBlur</code> 进行模糊处理。</li>
</ul>
</li>
<li><code>calculateDistanceField</code> 的实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastRegion.cpp

...
static void calculateDistanceField(rcCompactHeightfield&amp; chf, unsigned short* src, unsigned short&amp; maxDist)
{
	const int w = chf.width;
	const int h = chf.height;
	
	// Init distance and points.
	for (int i = 0; i &lt; chf.spanCount; ++i)
		src[i] = 0xffff;
	
	// Mark boundary cells.
	for (int y = 0; y &lt; h; ++y)
	{
		for (int x = 0; x &lt; w; ++x)
		{
			const rcCompactCell&amp; c = chf.cells[x+y*w];
			for (int i = (int)c.index, ni = (int)(c.index+c.count); i &lt; ni; ++i)
			{
				const rcCompactSpan&amp; s = chf.spans[i];
				const unsigned char area = chf.areas[i];
				
				int nc = 0;
				for (int dir = 0; dir &lt; 4; ++dir)
				{
					if (rcGetCon(s, dir) != RC_NOT_CONNECTED)
					{
						const int ax = x + rcGetDirOffsetX(dir);
						const int ay = y + rcGetDirOffsetY(dir);
						const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, dir);
						if (area == chf.areas[ai])
							nc++;
					}
				}
				if (nc != 4)
					src[i] = 0;
			}
		}
	}
	
			
	// Pass 1
	for (int y = 0; y &lt; h; ++y)
	{
		for (int x = 0; x &lt; w; ++x)
		{
			const rcCompactCell&amp; c = chf.cells[x+y*w];
			for (int i = (int)c.index, ni = (int)(c.index+c.count); i &lt; ni; ++i)
			{
				const rcCompactSpan&amp; s = chf.spans[i];
				
				if (rcGetCon(s, 0) != RC_NOT_CONNECTED)
				{
					// (-1,0)
					const int ax = x + rcGetDirOffsetX(0);
					const int ay = y + rcGetDirOffsetY(0);
					const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, 0);
					const rcCompactSpan&amp; as = chf.spans[ai];
					if (src[ai]+2 &lt; src[i])
						src[i] = src[ai]+2;
					
					// (-1,-1)
					if (rcGetCon(as, 3) != RC_NOT_CONNECTED)
					{
						const int aax = ax + rcGetDirOffsetX(3);
						const int aay = ay + rcGetDirOffsetY(3);
						const int aai = (int)chf.cells[aax+aay*w].index + rcGetCon(as, 3);
						if (src[aai]+3 &lt; src[i])
							src[i] = src[aai]+3;
					}
				}
				if (rcGetCon(s, 3) != RC_NOT_CONNECTED)
				{
					// (0,-1)
					const int ax = x + rcGetDirOffsetX(3);
					const int ay = y + rcGetDirOffsetY(3);
					const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, 3);
					const rcCompactSpan&amp; as = chf.spans[ai];
					if (src[ai]+2 &lt; src[i])
						src[i] = src[ai]+2;
					
					// (1,-1)
					if (rcGetCon(as, 2) != RC_NOT_CONNECTED)
					{
						const int aax = ax + rcGetDirOffsetX(2);
						const int aay = ay + rcGetDirOffsetY(2);
						const int aai = (int)chf.cells[aax+aay*w].index + rcGetCon(as, 2);
						if (src[aai]+3 &lt; src[i])
							src[i] = src[aai]+3;
					}
				}
			}
		}
	}
	
	// Pass 2
	for (int y = h-1; y &gt;= 0; --y)
	{
		for (int x = w-1; x &gt;= 0; --x)
		{
			const rcCompactCell&amp; c = chf.cells[x+y*w];
			for (int i = (int)c.index, ni = (int)(c.index+c.count); i &lt; ni; ++i)
			{
				const rcCompactSpan&amp; s = chf.spans[i];
				
				if (rcGetCon(s, 2) != RC_NOT_CONNECTED)
				{
					// (1,0)
					const int ax = x + rcGetDirOffsetX(2);
					const int ay = y + rcGetDirOffsetY(2);
					const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, 2);
					const rcCompactSpan&amp; as = chf.spans[ai];
					if (src[ai]+2 &lt; src[i])
						src[i] = src[ai]+2;
					
					// (1,1)
					if (rcGetCon(as, 1) != RC_NOT_CONNECTED)
					{
						const int aax = ax + rcGetDirOffsetX(1);
						const int aay = ay + rcGetDirOffsetY(1);
						const int aai = (int)chf.cells[aax+aay*w].index + rcGetCon(as, 1);
						if (src[aai]+3 &lt; src[i])
							src[i] = src[aai]+3;
					}
				}
				if (rcGetCon(s, 1) != RC_NOT_CONNECTED)
				{
					// (0,1)
					const int ax = x + rcGetDirOffsetX(1);
					const int ay = y + rcGetDirOffsetY(1);
					const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, 1);
					const rcCompactSpan&amp; as = chf.spans[ai];
					if (src[ai]+2 &lt; src[i])
						src[i] = src[ai]+2;
					
					// (-1,1)
					if (rcGetCon(as, 0) != RC_NOT_CONNECTED)
					{
						const int aax = ax + rcGetDirOffsetX(0);
						const int aay = ay + rcGetDirOffsetY(0);
						const int aai = (int)chf.cells[aax+aay*w].index + rcGetCon(as, 0);
						if (src[aai]+3 &lt; src[i])
							src[i] = src[aai]+3;
					}
				}
			}
		}
	}	
	
	maxDist = 0;
	for (int i = 0; i &lt; chf.spanCount; ++i)
		maxDist = rcMax(src[i], maxDist);
	
}

...
</code></pre><ul>
<li>建立高度场的过程和 <code>rcErodeWalkableArea</code> 的计算过程基本一致，<code>rcErodeWalkableArea</code> 是将四个邻居中存在不可行走的 <code>span</code> 作为边缘，而 <code>calculateDistanceField</code> 则是再加上条件，如果四个邻居中存在和当前 <code>span</code> 的 <code>area</code> 不相同的，则认为是区域的边缘。得到边缘信息后，同样通过光栅扫描方式来计算距离，最终得到一个距离场。</li>
<li><code>boxBlur</code> 的实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastRegion.cpp

...
static unsigned short* boxBlur(rcCompactHeightfield&amp; chf, int thr,
							   unsigned short* src, unsigned short* dst)
{
	const int w = chf.width;
	const int h = chf.height;
	
	thr *= 2;
	
	for (int y = 0; y &lt; h; ++y)
	{
		for (int x = 0; x &lt; w; ++x)
		{
			const rcCompactCell&amp; c = chf.cells[x+y*w];
			for (int i = (int)c.index, ni = (int)(c.index+c.count); i &lt; ni; ++i)
			{
				const rcCompactSpan&amp; s = chf.spans[i];
				const unsigned short cd = src[i];
				if (cd &lt;= thr)
				{
					dst[i] = cd;
					continue;
				}

				int d = (int)cd;
				for (int dir = 0; dir &lt; 4; ++dir)
				{
					if (rcGetCon(s, dir) != RC_NOT_CONNECTED)
					{
						const int ax = x + rcGetDirOffsetX(dir);
						const int ay = y + rcGetDirOffsetY(dir);
						const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, dir);
						d += (int)src[ai];
						
						const rcCompactSpan&amp; as = chf.spans[ai];
						const int dir2 = (dir+1) &amp; 0x3;
						if (rcGetCon(as, dir2) != RC_NOT_CONNECTED)
						{
							const int ax2 = ax + rcGetDirOffsetX(dir2);
							const int ay2 = ay + rcGetDirOffsetY(dir2);
							const int ai2 = (int)chf.cells[ax2+ay2*w].index + rcGetCon(as, dir2);
							d += (int)src[ai2];
						}
						else
						{
							d += cd;
						}
					}
					else
					{
						d += cd*2;
					}
				}
				dst[i] = (unsigned short)((d+5)/9);
			}
		}
	}
	return dst;
}

...
</code></pre><ul>
<li>如果 <code>span</code> 的距离不超过阈值 <code>thr</code>（这里设置为 2），则不进行模糊计算，保持距离不变。如果超过，则需要以自身为中心，和周围八个邻居的距离进行平均，得到新的距离。其中，对于每个不可行走的邻居，使用中心的距离代替。</li>
<li>建立距离场后，就需要通过 <code>rcBuildRegions</code> 划分地区，其实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastRegion.cpp

...
bool rcBuildRegions(rcContext* ctx, rcCompactHeightfield&amp; chf,
					const int borderSize, const int minRegionArea, const int mergeRegionArea)
{
	rcAssert(ctx);
	
	rcScopedTimer timer(ctx, RC_TIMER_BUILD_REGIONS);
	
	const int w = chf.width;
	const int h = chf.height;
	
	rcScopedDelete&lt;unsigned short&gt; buf((unsigned short*)rcAlloc(sizeof(unsigned short)*chf.spanCount*2, RC_ALLOC_TEMP));
	if (!buf)
	{
		ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildRegions: Out of memory 'tmp' (%d).&quot;, chf.spanCount*4);
		return false;
	}
	
	ctx-&gt;startTimer(RC_TIMER_BUILD_REGIONS_WATERSHED);

	const int LOG_NB_STACKS = 3;
	const int NB_STACKS = 1 &lt;&lt; LOG_NB_STACKS;
	rcTempVector&lt;LevelStackEntry&gt; lvlStacks[NB_STACKS];
	for (int i=0; i&lt;NB_STACKS; ++i)
		lvlStacks[i].reserve(256);

	rcTempVector&lt;LevelStackEntry&gt; stack;
	stack.reserve(256);
	
	unsigned short* srcReg = buf;
	unsigned short* srcDist = buf+chf.spanCount;
	
	memset(srcReg, 0, sizeof(unsigned short)*chf.spanCount);
	memset(srcDist, 0, sizeof(unsigned short)*chf.spanCount);
	
	unsigned short regionId = 1;
	unsigned short level = (chf.maxDistance+1) &amp; ~1;

	// TODO: Figure better formula, expandIters defines how much the 
	// watershed &quot;overflows&quot; and simplifies the regions. Tying it to
	// agent radius was usually good indication how greedy it could be.
//	const int expandIters = 4 + walkableRadius * 2;
	const int expandIters = 8;

	if (borderSize &gt; 0)
	{
		// Make sure border will not overflow.
		const int bw = rcMin(w, borderSize);
		const int bh = rcMin(h, borderSize);
		
		// Paint regions
		paintRectRegion(0, bw, 0, h, regionId|RC_BORDER_REG, chf, srcReg); regionId++;
		paintRectRegion(w-bw, w, 0, h, regionId|RC_BORDER_REG, chf, srcReg); regionId++;
		paintRectRegion(0, w, 0, bh, regionId|RC_BORDER_REG, chf, srcReg); regionId++;
		paintRectRegion(0, w, h-bh, h, regionId|RC_BORDER_REG, chf, srcReg); regionId++;
	}

	chf.borderSize = borderSize;
	
	int sId = -1;
	while (level &gt; 0)
	{
		level = level &gt;= 2 ? level-2 : 0;
		sId = (sId+1) &amp; (NB_STACKS-1);

//		ctx-&gt;startTimer(RC_TIMER_DIVIDE_TO_LEVELS);

		if (sId == 0)
			sortCellsByLevel(level, chf, srcReg, NB_STACKS, lvlStacks, 1);
		else 
			appendStacks(lvlStacks[sId-1], lvlStacks[sId], srcReg); // copy left overs from last level

//		ctx-&gt;stopTimer(RC_TIMER_DIVIDE_TO_LEVELS);

		{
			rcScopedTimer timerExpand(ctx, RC_TIMER_BUILD_REGIONS_EXPAND);

			// Expand current regions until no empty connected cells found.
			expandRegions(expandIters, level, chf, srcReg, srcDist, lvlStacks[sId], false);
		}
		
		{
			rcScopedTimer timerFloor(ctx, RC_TIMER_BUILD_REGIONS_FLOOD);

			// Mark new regions with IDs.
			for (int j = 0; j&lt;lvlStacks[sId].size(); j++)
			{
				LevelStackEntry current = lvlStacks[sId][j];
				int x = current.x;
				int y = current.y;
				int i = current.index;
				if (i &gt;= 0 &amp;&amp; srcReg[i] == 0)
				{
					if (floodRegion(x, y, i, level, regionId, chf, srcReg, srcDist, stack))
					{
						if (regionId == 0xFFFF)
						{
							ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildRegions: Region ID overflow&quot;);
							return false;
						}
						
						regionId++;
					}
				}
			}
		}
	}
	
	// Expand current regions until no empty connected cells found.
	expandRegions(expandIters*8, 0, chf, srcReg, srcDist, stack, true);
	
	ctx-&gt;stopTimer(RC_TIMER_BUILD_REGIONS_WATERSHED);
	
	{
		rcScopedTimer timerFilter(ctx, RC_TIMER_BUILD_REGIONS_FILTER);

		// Merge regions and filter out small regions.
		rcTempVector&lt;int&gt; overlaps;
		chf.maxRegions = regionId;
		if (!mergeAndFilterRegions(ctx, minRegionArea, mergeRegionArea, chf.maxRegions, chf, srcReg, overlaps))
			return false;

		// If overlapping regions were found during merging, split those regions.
		if (overlaps.size() &gt; 0)
		{
			ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildRegions: %d overlapping regions.&quot;, overlaps.size());
		}
	}
		
	// Write the result out.
	for (int i = 0; i &lt; chf.spanCount; ++i)
		chf.spans[i].reg = srcReg[i];
	
	return true;
}

...
</code></pre><ul>
<li><code>rcBuildRegions</code> 的步骤如下：
<ul>
<li>首先，根据边界尺寸 <code>borderSize</code>，通过 <code>paintRectRegion</code> 方法，将边界范围的 <code>region</code> 进行设置，并设置紧密高度场 <code>chf.borderSize</code> 为 <code>borderSize</code> 。</li>
<li>接着，设置 <code>level</code> 为距离最大值向上取偶数，根据 <code>level</code> 的大小，从大到小，每次处理两级，处理流程如下：
<ul>
<li>收集本次处理的所有 <code>span</code> 到 <code>lvlStacks</code> 数组中。
<ul>
<li>首次执行时，通过 <code>sortCellsByLevel</code> 方法，检查所有 <code>span</code> ，将可行走且未设置 <code>region</code> 的，根据距离进行分段，放入 <code>lvlStacks[sId]</code>，<code>sId</code> 越小，距离越远。第 0 段距离最小为 <code>level - 2</code> 向下取偶数，第 1 段为第 0 段的一半，以此类推，如：<code>level</code> 为 7 ，则
<ul>
<li><code>sId</code> 为 0，<code>span</code> 距离不小于 <code>(7 - 2) / 2 * 2 / 2 ^ 0 = 4</code>。</li>
<li><code>sId</code> 为 1，<code>span</code> 距离不小于 <code>(7 - 2) / 2 * 2 / 2 ^ 1 = 2</code>。</li>
<li><code>sId</code> 为 2，<code>span</code> 距离不小于 <code>(7 - 2) / 2 * 2 / 2 ^ 2 = 1</code>。</li>
</ul>
</li>
<li>非首次执行，则通过 <code>appendStacks</code> 方法，将上一次 <code>lvlStacks[sId-1]</code> 没有分配到 <code>region</code> 的，加入到 <code>lvlStacks[sId]</code> 中。</li>
</ul>
</li>
<li>通过 <code>expandRegions</code> 方法，沿边界将当前 <code>region</code> 进行扩展。</li>
<li>遍历当前 <code>lvlStacks[sId]</code> ，通过 <code>floodRegion</code> 方法，填充 <code>span</code> 及其扩展的 <code>span</code> 的 <code>region</code> ，成功填充则 <code>regionId + 1</code>。</li>
</ul>
</li>
<li>调用 <code>expandRegions</code> 方法，扩展所有未分配 <code>region</code> 的 <code>span</code> 。</li>
<li>调用 <code>mergeAndFilterRegions</code> 方法，合并 <code>region</code>，过滤掉 <code>region</code> 数量太小的 <code>span</code>。</li>
<li>最后，将 <code>srcReg</code> 记录的最终 <code>region</code> 信息，应用到紧密高度场中的每一个 <code>span</code>，完成划分。</li>
</ul>
</li>
<li><code>expandRegions</code> 的实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastRegion.cpp

...
static void expandRegions(int maxIter, unsigned short level,
					      rcCompactHeightfield&amp; chf,
					      unsigned short* srcReg, unsigned short* srcDist,
					      rcTempVector&lt;LevelStackEntry&gt;&amp; stack,
					      bool fillStack)
{
	const int w = chf.width;
	const int h = chf.height;

	if (fillStack)
	{
		// Find cells revealed by the raised level.
		stack.clear();
		for (int y = 0; y &lt; h; ++y)
		{
			for (int x = 0; x &lt; w; ++x)
			{
				const rcCompactCell&amp; c = chf.cells[x+y*w];
				for (int i = (int)c.index, ni = (int)(c.index+c.count); i &lt; ni; ++i)
				{
					if (chf.dist[i] &gt;= level &amp;&amp; srcReg[i] == 0 &amp;&amp; chf.areas[i] != RC_NULL_AREA)
					{
						stack.push_back(LevelStackEntry(x, y, i));
					}
				}
			}
		}
	}
	else // use cells in the input stack
	{
		// mark all cells which already have a region
		for (int j=0; j&lt;stack.size(); j++)
		{
			int i = stack[j].index;
			if (srcReg[i] != 0)
				stack[j].index = -1;
		}
	}

	rcTempVector&lt;DirtyEntry&gt; dirtyEntries;
	int iter = 0;
	while (stack.size() &gt; 0)
	{
		int failed = 0;
		dirtyEntries.clear();
		
		for (int j = 0; j &lt; stack.size(); j++)
		{
			int x = stack[j].x;
			int y = stack[j].y;
			int i = stack[j].index;
			if (i &lt; 0)
			{
				failed++;
				continue;
			}
			
			unsigned short r = srcReg[i];
			unsigned short d2 = 0xffff;
			const unsigned char area = chf.areas[i];
			const rcCompactSpan&amp; s = chf.spans[i];
			for (int dir = 0; dir &lt; 4; ++dir)
			{
				if (rcGetCon(s, dir) == RC_NOT_CONNECTED) continue;
				const int ax = x + rcGetDirOffsetX(dir);
				const int ay = y + rcGetDirOffsetY(dir);
				const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, dir);
				if (chf.areas[ai] != area) continue;
				if (srcReg[ai] &gt; 0 &amp;&amp; (srcReg[ai] &amp; RC_BORDER_REG) == 0)
				{
					if ((int)srcDist[ai]+2 &lt; (int)d2)
					{
						r = srcReg[ai];
						d2 = srcDist[ai]+2;
					}
				}
			}
			if (r)
			{
				stack[j].index = -1; // mark as used
				dirtyEntries.push_back(DirtyEntry(i, r, d2));
			}
			else
			{
				failed++;
			}
		}
		
		// Copy entries that differ between src and dst to keep them in sync.
		for (int i = 0; i &lt; dirtyEntries.size(); i++) {
			int idx = dirtyEntries[i].index;
			srcReg[idx] = dirtyEntries[i].region;
			srcDist[idx] = dirtyEntries[i].distance2;
		}
		
		if (failed == stack.size())
			break;
		
		if (level &gt; 0)
		{
			++iter;
			if (iter &gt;= maxIter)
				break;
		}
	}
}

...
</code></pre><ul>
<li><code>expandRegions</code> 有两种处理模式：
<ul>
<li>当 <code>fillStack</code> 为 <code>true</code> 时，会清空 <code>stack</code>，将所有不小于 <code>level</code> 、未分配 <code>region</code> 且可行走的 <code>span</code> 加入到 <code>stack</code> 中。</li>
<li>当 <code>fillStack</code> 为 <code>false</code> 时，则使用已经收集好的 <code>stack</code>，将其中已分配 <code>region</code> 的 <code>index</code> 设置为 <code>-1</code> 作为标记。</li>
</ul>
</li>
<li>根据传入的 <code>maxIter</code>，决定进行循环迭代的次数，每次循环的处理流程为：
<ul>
<li>遍历 <code>stack</code> 中的 <code>span</code>。
<ul>
<li>如果 <code>index</code> 为 <code>-1</code> ，则不再处理。</li>
<li>检查四个邻居中，可行走，已分配 <code>region</code> 且不为边界（即不在 <code>borderSize</code> 范围）的 <code>span</code> ，找到其中距离最小的，将 <code>index</code> 、<code>region</code> 、距离加入到 <code>dirtyEntries</code> 中，设置为 <code>stack[j].index = -1</code> ，即标记已处理。</li>
</ul>
</li>
<li>遍历 <code>dirtyEntries</code> ，将其中的 <code>index</code> 对应的 <code>region</code> 和距离设置到 <code>srcReg</code> 和 <code>srcDist</code> 中。</li>
<li>进入下一次循环，直到 <code>stack</code> 中没有未处理的 <code>span</code> 或者迭代次数达到上限。</li>
</ul>
</li>
<li><code>floodRegion</code> 的实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastRegion.cpp

...
static bool floodRegion(int x, int y, int i,
						unsigned short level, unsigned short r,
						rcCompactHeightfield&amp; chf,
						unsigned short* srcReg, unsigned short* srcDist,
						rcTempVector&lt;LevelStackEntry&gt;&amp; stack)
{
	const int w = chf.width;
	
	const unsigned char area = chf.areas[i];
	
	// Flood fill mark region.
	stack.clear();
	stack.push_back(LevelStackEntry(x, y, i));
	srcReg[i] = r;
	srcDist[i] = 0;
	
	unsigned short lev = level &gt;= 2 ? level-2 : 0;
	int count = 0;
	
	while (stack.size() &gt; 0)
	{
		LevelStackEntry&amp; back = stack.back();
		int cx = back.x;
		int cy = back.y;
		int ci = back.index;
		stack.pop_back();
		
		const rcCompactSpan&amp; cs = chf.spans[ci];
		
		// Check if any of the neighbours already have a valid region set.
		unsigned short ar = 0;
		for (int dir = 0; dir &lt; 4; ++dir)
		{
			// 8 connected
			if (rcGetCon(cs, dir) != RC_NOT_CONNECTED)
			{
				const int ax = cx + rcGetDirOffsetX(dir);
				const int ay = cy + rcGetDirOffsetY(dir);
				const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(cs, dir);
				if (chf.areas[ai] != area)
					continue;
				unsigned short nr = srcReg[ai];
				if (nr &amp; RC_BORDER_REG) // Do not take borders into account.
					continue;
				if (nr != 0 &amp;&amp; nr != r)
				{
					ar = nr;
					break;
				}
				
				const rcCompactSpan&amp; as = chf.spans[ai];
				
				const int dir2 = (dir+1) &amp; 0x3;
				if (rcGetCon(as, dir2) != RC_NOT_CONNECTED)
				{
					const int ax2 = ax + rcGetDirOffsetX(dir2);
					const int ay2 = ay + rcGetDirOffsetY(dir2);
					const int ai2 = (int)chf.cells[ax2+ay2*w].index + rcGetCon(as, dir2);
					if (chf.areas[ai2] != area)
						continue;
					unsigned short nr2 = srcReg[ai2];
					if (nr2 != 0 &amp;&amp; nr2 != r)
					{
						ar = nr2;
						break;
					}
				}				
			}
		}
		if (ar != 0)
		{
			srcReg[ci] = 0;
			continue;
		}
		
		count++;
		
		// Expand neighbours.
		for (int dir = 0; dir &lt; 4; ++dir)
		{
			if (rcGetCon(cs, dir) != RC_NOT_CONNECTED)
			{
				const int ax = cx + rcGetDirOffsetX(dir);
				const int ay = cy + rcGetDirOffsetY(dir);
				const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(cs, dir);
				if (chf.areas[ai] != area)
					continue;
				if (chf.dist[ai] &gt;= lev &amp;&amp; srcReg[ai] == 0)
				{
					srcReg[ai] = r;
					srcDist[ai] = 0;
					stack.push_back(LevelStackEntry(ax, ay, ai));
				}
			}
		}
	}
	
	return count &gt; 0;
}

...
</code></pre><ul>
<li><code>floodRegion</code> 每次从 <code>lvlStacks[sId]</code> 取一个 <code>index</code>，处理其对应的 <code>span</code>，放入 <code>stack</code> 中进行循环处理，流程如下：
<ul>
<li>从 <code>stack</code> 中取出一个 <code>span</code> 。</li>
<li>检查 <code>span</code> 的八个邻居，如果没有分配过 <code>region</code> 或者 <code>region</code> 和传入的 <code>regionId</code> 相同，则将当前 <code>span</code> 的 <code>region</code> 设置为传入的 <code>regionId</code>，距离设置为 0 。</li>
<li>如果当前 <code>span</code> 设置了 <code>region</code>，则将四个邻居中，可行走且大于 <code>level - 2</code>，同时还未分配 <code>region</code> 的 <code>span</code>，设置其 <code>region</code> 为 <code>regionId</code>，距离设置为 0。</li>
<li>将处理的邻居 <code>span</code> 放入 <code>stack</code> 中，循环处理 <code>stack</code>，实现传播，直到 <code>stack</code> 处理完毕。</li>
</ul>
</li>
<li><code>mergeAndFilterRegions</code> 使用了新的结构 <code>rcRegion</code> 来进行处理，其实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastRegion.cpp

...

struct rcRegion
{
	...
	
	int spanCount;					// 当前地区的所有跨度的数量
	unsigned short id;				// 当前地区的 id
	unsigned char areaType;			// 当前地区的区域类型
	bool remap;						// 是否需要重新映射地区 id
	bool visited;					// 是否访问处理过
	bool overlap;					// 是否重叠，即在同一个单元格上存在多个相同地区的跨度
	bool connectsToBorder;			// 是否连接到 borderSize 范围内的边缘
	unsigned short ymin, ymax;
	rcTempVector&lt;int&gt; connections;	// 地区的轮廓的地区 id 连接
	rcTempVector&lt;int&gt; floors;		// 和当前地区存在重叠（即处在同一个单元格）的所有其他地区 id
};

...

static bool mergeAndFilterRegions(rcContext* ctx, int minRegionArea, int mergeRegionSize,
								  unsigned short&amp; maxRegionId,
								  rcCompactHeightfield&amp; chf,
								  unsigned short* srcReg, rcTempVector&lt;int&gt;&amp; overlaps)
{
	const int w = chf.width;
	const int h = chf.height;
	
	const int nreg = maxRegionId+1;
	rcTempVector&lt;rcRegion&gt; regions;
	if (!regions.reserve(nreg)) {
		ctx-&gt;log(RC_LOG_ERROR, &quot;mergeAndFilterRegions: Out of memory 'regions' (%d).&quot;, nreg);
		return false;
	}

	// Construct regions
	for (int i = 0; i &lt; nreg; ++i)
		regions.push_back(rcRegion((unsigned short) i));
	
	// Find edge of a region and find connections around the contour.
	for (int y = 0; y &lt; h; ++y)
	{
		for (int x = 0; x &lt; w; ++x)
		{
			const rcCompactCell&amp; c = chf.cells[x+y*w];
			for (int i = (int)c.index, ni = (int)(c.index+c.count); i &lt; ni; ++i)
			{
				unsigned short r = srcReg[i];
				if (r == 0 || r &gt;= nreg)
					continue;
				
				rcRegion&amp; reg = regions[r];
				reg.spanCount++;
				
				// Update floors.
				for (int j = (int)c.index; j &lt; ni; ++j)
				{
					if (i == j) continue;
					unsigned short floorId = srcReg[j];
					if (floorId == 0 || floorId &gt;= nreg)
						continue;
					if (floorId == r)
						reg.overlap = true;
					addUniqueFloorRegion(reg, floorId);
				}
				
				// Have found contour
				if (reg.connections.size() &gt; 0)
					continue;
				
				reg.areaType = chf.areas[i];
				
				// Check if this cell is next to a border.
				int ndir = -1;
				for (int dir = 0; dir &lt; 4; ++dir)
				{
					if (isSolidEdge(chf, srcReg, x, y, i, dir))
					{
						ndir = dir;
						break;
					}
				}
				
				if (ndir != -1)
				{
					// The cell is at border.
					// Walk around the contour to find all the neighbours.
					walkContour(x, y, i, ndir, chf, srcReg, reg.connections);
				}
			}
		}
	}

	// Remove too small regions.
	rcTempVector&lt;int&gt; stack(32);
	rcTempVector&lt;int&gt; trace(32);
	for (int i = 0; i &lt; nreg; ++i)
	{
		rcRegion&amp; reg = regions[i];
		if (reg.id == 0 || (reg.id &amp; RC_BORDER_REG))
			continue;                       
		if (reg.spanCount == 0)
			continue;
		if (reg.visited)
			continue;
		
		// Count the total size of all the connected regions.
		// Also keep track of the regions connects to a tile border.
		bool connectsToBorder = false;
		int spanCount = 0;
		stack.clear();
		trace.clear();

		reg.visited = true;
		stack.push_back(i);
		
		while (stack.size())
		{
			// Pop
			int ri = stack.back(); stack.pop_back();
			
			rcRegion&amp; creg = regions[ri];

			spanCount += creg.spanCount;
			trace.push_back(ri);

			for (int j = 0; j &lt; creg.connections.size(); ++j)
			{
				if (creg.connections[j] &amp; RC_BORDER_REG)
				{
					connectsToBorder = true;
					continue;
				}
				rcRegion&amp; neireg = regions[creg.connections[j]];
				if (neireg.visited)
					continue;
				if (neireg.id == 0 || (neireg.id &amp; RC_BORDER_REG))
					continue;
				// Visit
				stack.push_back(neireg.id);
				neireg.visited = true;
			}
		}
		
		// If the accumulated regions size is too small, remove it.
		// Do not remove areas which connect to tile borders
		// as their size cannot be estimated correctly and removing them
		// can potentially remove necessary areas.
		if (spanCount &lt; minRegionArea &amp;&amp; !connectsToBorder)
		{
			// Kill all visited regions.
			for (int j = 0; j &lt; trace.size(); ++j)
			{
				regions[trace[j]].spanCount = 0;
				regions[trace[j]].id = 0;
			}
		}
	}
	
	// Merge too small regions to neighbour regions.
	int mergeCount = 0 ;
	do
	{
		mergeCount = 0;
		for (int i = 0; i &lt; nreg; ++i)
		{
			rcRegion&amp; reg = regions[i];
			if (reg.id == 0 || (reg.id &amp; RC_BORDER_REG))
				continue;
			if (reg.overlap)
				continue;
			if (reg.spanCount == 0)
				continue;
			
			// Check to see if the region should be merged.
			if (reg.spanCount &gt; mergeRegionSize &amp;&amp; isRegionConnectedToBorder(reg))
				continue;
			
			// Small region with more than 1 connection.
			// Or region which is not connected to a border at all.
			// Find smallest neighbour region that connects to this one.
			int smallest = 0xfffffff;
			unsigned short mergeId = reg.id;
			for (int j = 0; j &lt; reg.connections.size(); ++j)
			{
				if (reg.connections[j] &amp; RC_BORDER_REG) continue;
				rcRegion&amp; mreg = regions[reg.connections[j]];
				if (mreg.id == 0 || (mreg.id &amp; RC_BORDER_REG) || mreg.overlap) continue;
				if (mreg.spanCount &lt; smallest &amp;&amp;
					canMergeWithRegion(reg, mreg) &amp;&amp;
					canMergeWithRegion(mreg, reg))
				{
					smallest = mreg.spanCount;
					mergeId = mreg.id;
				}
			}
			// Found new id.
			if (mergeId != reg.id)
			{
				unsigned short oldId = reg.id;
				rcRegion&amp; target = regions[mergeId];
				
				// Merge neighbours.
				if (mergeRegions(target, reg))
				{
					// Fixup regions pointing to current region.
					for (int j = 0; j &lt; nreg; ++j)
					{
						if (regions[j].id == 0 || (regions[j].id &amp; RC_BORDER_REG)) continue;
						// If another region was already merged into current region
						// change the nid of the previous region too.
						if (regions[j].id == oldId)
							regions[j].id = mergeId;
						// Replace the current region with the new one if the
						// current regions is neighbour.
						replaceNeighbour(regions[j], oldId, mergeId);
					}
					mergeCount++;
				}
			}
		}
	}
	while (mergeCount &gt; 0);
	
	// Compress region Ids.
	for (int i = 0; i &lt; nreg; ++i)
	{
		regions[i].remap = false;
		if (regions[i].id == 0) continue;       // Skip nil regions.
		if (regions[i].id &amp; RC_BORDER_REG) continue;    // Skip external regions.
		regions[i].remap = true;
	}
	
	unsigned short regIdGen = 0;
	for (int i = 0; i &lt; nreg; ++i)
	{
		if (!regions[i].remap)
			continue;
		unsigned short oldId = regions[i].id;
		unsigned short newId = ++regIdGen;
		for (int j = i; j &lt; nreg; ++j)
		{
			if (regions[j].id == oldId)
			{
				regions[j].id = newId;
				regions[j].remap = false;
			}
		}
	}
	maxRegionId = regIdGen;
	
	// Remap regions.
	for (int i = 0; i &lt; chf.spanCount; ++i)
	{
		if ((srcReg[i] &amp; RC_BORDER_REG) == 0)
			srcReg[i] = regions[srcReg[i]].id;
	}

	// Return regions that we found to be overlapping.
	for (int i = 0; i &lt; nreg; ++i)
		if (regions[i].overlap)
			overlaps.push_back(regions[i].id);

	return true;
}

...
</code></pre><ul>
<li><code>mergeAndFilterRegions</code> 主要分为几个步骤：
<ul>
<li>寻找 <code>region</code> 的轮廓及其连接信息。
<ul>
<li>为每一个 <code>regionId</code> 创建一个 <code>rcRegion</code>，遍历所有 <code>cell</code> 上的所有 <code>span</code> 进行处理，包括：
<ul>
<li>将同一 <code>regionId</code> 的 <code>span</code> 数量统计到 <code>reg.spanCount</code> 中。</li>
<li>检查当前 <code>cell</code> 上是否有其他 <code>span</code> 的 <code>regionId</code> 和当前 <code>regionId</code> 相同，如果有则设置 <code>reg.overlap</code> 为 <code>true</code>，即有重叠。</li>
<li>将当前 <code>cell</code> 上所有 <code>span</code> 的 <code>regionId</code>，加入到 <code>reg.floors</code> 中。</li>
<li>设置当前 <code>reg.areaType</code>。</li>
<li>通过 <code>isSolidEdge</code> 方法，检查四个邻居，如果有一个邻居的 <code>regionId</code> 是否为其他 <code>region</code> 或者不可行走，则当前 <code>span</code> 是当前 <code>region</code> 的边界。</li>
<li>如果当前 <code>span</code> 是边界，则通过 <code>walkContour</code> 方法找到当前 <code>region</code> 的轮廓，并计算轮廓的 <code>region</code> 连接信息。</li>
</ul>
</li>
</ul>
</li>
<li>移除过小的 <code>region</code>。
<ul>
<li>遍历所有的 <code>region</code>，对每个 <code>region</code> 进行检查，主要流程：
<ul>
<li>设置 <code>spanCount</code> 总数量为 0。</li>
<li>将当前 <code>regionId</code> 加入到 <code>stack</code> 中，迭代处理。
<ul>
<li>从 <code>stack</code> 中取出 <code>creg</code>，将当前 <code>creg.spanCount</code> 数量加到 <code>spanCount</code>。</li>
<li>遍历 <code>creg.connections</code>，对其中每一个 <code>neireg</code> 进行检查。
<ul>
<li>如果 <code>neireg</code> 为 <code>borderSize</code> 的范围，则设置 <code>connectsToBorder</code> 为 <code>true</code>，代表连接到边界。</li>
<li>如果 <code>neireg</code> 已经访问过，则不再处理。</li>
<li>将 <code>neireg</code> 标记为已经访问过，并将 <code>neireg</code> 的 <code>regionId</code> 加入到 <code>stack</code> 中。</li>
</ul>
</li>
<li>继续进行 <code>stack</code> 的迭代处理，直到 <code>stack</code> 处理完成。</li>
</ul>
</li>
</ul>
</li>
<li>如果 <code>spanCount</code> 小于 <code>minRegionArea</code>，并且 <code>connectsToBorder</code> 为 <code>false</code>，则代表当前 <code>regionId</code> 及其所有 <code>connections</code> 的 <code>regionId</code> 组成的整体区域太小，并且没有连接到边界，则将其移除，即当前 <code>regionId</code> 以及 <code>connections</code> 的 <code>spanCount</code> 和 <code>regionId</code> 都设置为 0。但如果连接到边界，因为无法准确估计其大小，可能导致移除必要的区域，所以会保留。</li>
<li>如果移除了 <code>region</code> ，后续的 <code>region</code> 在计算时会直接跳过。计算总数量时，已经移除的 <code>region</code> 原本的数量也不会计入。</li>
</ul>
</li>
<li>合并小的 <code>region</code> 到邻居 <code>region</code> 中。
<ul>
<li>遍历所有的 <code>region</code>，对每个 <code>region</code> 进行检查，主要流程：
<ul>
<li>如果 <code>region</code> 被移除（<code>reg.spanCount</code> 为 0）或者 <code>region</code> 有重叠（<code>reg.overlap</code> 为 <code>true</code>），则不处理。</li>
<li>从 <code>connections</code> 中，通过依次将两个 <code>region</code> 设置为源 <code>region</code>，调用两次 <code>canMergeWithRegion</code> 方法，找到两者相互都能合并的 <code>region</code>。</li>
<li>从所有能合并的 <code>region</code> 中取 <code>spanCount</code> 最小的作为目标 <code>region</code>，通过 <code>mergeRegions</code> 方法进行合并。</li>
<li>合并成功后，将当前 <code>region</code>、<code>connections</code>、<code>floors</code> 中的 <code>regionId</code> 都更换目标的 <code>regionId</code>。</li>
</ul>
</li>
<li>所有 <code>region</code> 处理完成后，如果有成功合并过，则再重复执行一次处理，直到不再有可以合并的 <code>region</code>。</li>
</ul>
</li>
<li>重新映射 <code>regionId</code>。
<ul>
<li>遍历所有的 <code>region</code>，从 1 开始设置剩余的 <code>region</code>，将 <code>regionId</code> 映射为新的区间。</li>
</ul>
</li>
<li>应用新的 <code>regionId</code>。
<ul>
<li>遍历 <code>srcReg</code>，使用新的 <code>regionId</code> 进行替换。</li>
</ul>
</li>
<li>记录所有重叠的 <code>regionId</code>。
<ul>
<li>使用新的 <code>regionId</code>，记录所有有重叠的 <code>region</code>。</li>
</ul>
</li>
</ul>
</li>
<li><code>walkContour</code> 方法的实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastRegion.cpp

...
static void walkContour(int x, int y, int i, int dir,
						rcCompactHeightfield&amp; chf,
						const unsigned short* srcReg,
						rcTempVector&lt;int&gt;&amp; cont)
{
	int startDir = dir;
	int starti = i;

	const rcCompactSpan&amp; ss = chf.spans[i];
	unsigned short curReg = 0;
	if (rcGetCon(ss, dir) != RC_NOT_CONNECTED)
	{
		const int ax = x + rcGetDirOffsetX(dir);
		const int ay = y + rcGetDirOffsetY(dir);
		const int ai = (int)chf.cells[ax+ay*chf.width].index + rcGetCon(ss, dir);
		curReg = srcReg[ai];
	}
	cont.push_back(curReg);
			
	int iter = 0;
	while (++iter &lt; 40000)
	{
		const rcCompactSpan&amp; s = chf.spans[i];
		
		if (isSolidEdge(chf, srcReg, x, y, i, dir))
		{
			// Choose the edge corner
			unsigned short r = 0;
			if (rcGetCon(s, dir) != RC_NOT_CONNECTED)
			{
				const int ax = x + rcGetDirOffsetX(dir);
				const int ay = y + rcGetDirOffsetY(dir);
				const int ai = (int)chf.cells[ax+ay*chf.width].index + rcGetCon(s, dir);
				r = srcReg[ai];
			}
			if (r != curReg)
			{
				curReg = r;
				cont.push_back(curReg);
			}
			
			dir = (dir+1) &amp; 0x3;  // Rotate CW
		}
		else
		{
			int ni = -1;
			const int nx = x + rcGetDirOffsetX(dir);
			const int ny = y + rcGetDirOffsetY(dir);
			if (rcGetCon(s, dir) != RC_NOT_CONNECTED)
			{
				const rcCompactCell&amp; nc = chf.cells[nx+ny*chf.width];
				ni = (int)nc.index + rcGetCon(s, dir);
			}
			if (ni == -1)
			{
				// Should not happen.
				return;
			}
			x = nx;
			y = ny;
			i = ni;
			dir = (dir+3) &amp; 0x3;	// Rotate CCW
		}
		
		if (starti == i &amp;&amp; startDir == dir)
		{
			break;
		}
	}

	// Remove adjacent duplicates.
	if (cont.size() &gt; 1)
	{
		for (int j = 0; j &lt; cont.size(); )
		{
			int nj = (j+1) % cont.size();
			if (cont[j] == cont[nj])
			{
				for (int k = j; k &lt; cont.size()-1; ++k)
					cont[k] = cont[k+1];
				cont.pop_back();
			}
			else
				++j;
		}
	}
}

...
</code></pre><ul>
<li><code>walkContour</code> 从边界 <code>span</code> 出发寻找轮廓和连接 <code>region</code> ，其主要步骤为：
<ul>
<li>计算边界 <code>span</code> 目标方向邻居的 <code>regionId</code>，加入 <code>cont</code> 中。</li>
<li>按照左上右下的方向顺序，从当前 <code>span</code> 和方向开始，检查对应的邻居是否为当前 <code>region</code> 的边界。
<ul>
<li>如果是边界，则方向变更为下一个方向，再进行检查。此时如果邻居的 <code>regionId</code> 和上一次记录的不同，则将邻居 <code>regionId</code> 加入 <code>cont</code> 中。</li>
<li>如果不是边界，则将当前 <code>span</code> 改为邻居 <code>span</code>，方向改为上一个方向，再进行检查。</li>
<li>如果当前 <code>span</code> 和方向，和起始的相同，则说明回到了起点，轮廓寻找完成，此时所有经过的 <code>span</code> 组成了整个边界。</li>
</ul>
</li>
<li>遍历 <code>cont</code>，移除相邻重复的 <code>regionId</code>，包括首尾，最终得到一个 <code>region</code> 的连接 <code>regionId</code> 列表，即为 <code>reg.connections</code>。
<img src="/img/Algorithm/NavmeshNavigation/WalkContour.gif?raw=true" alt=WalkContour.gif>
</li>
</ul>
</li>
<li><code>canMergeWithRegion</code> 的实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastRegion.cpp

...
static bool canMergeWithRegion(const rcRegion&amp; rega, const rcRegion&amp; regb)
{
	if (rega.areaType != regb.areaType)
		return false;
	int n = 0;
	for (int i = 0; i &lt; rega.connections.size(); ++i)
	{
		if (rega.connections[i] == regb.id)
			n++;
	}
	if (n &gt; 1)
		return false;
	for (int i = 0; i &lt; rega.floors.size(); ++i)
	{
		if (rega.floors[i] == regb.id)
			return false;
	}
	return true;
}

...
</code></pre><ul>
<li><code>canMergeWithRegion</code> 主要过滤不能合并的情况，包括：
<ul>
<li>源 <code>region</code> 和目标 <code>region</code> 的 <code>area</code> 不同。</li>
<li>源 <code>region</code> 的 <code>connections</code> 出现超过一次目标 <code>region</code> 的 <code>regionId</code>，即目标 <code>region</code> 和源 <code>region</code> 交界处可能还有其他 <code>region</code>。</li>
<li>源 <code>region</code> 的 <code>floors</code> 中存在目标 <code>region</code> 的 <code>regionId</code>，即目标 <code>region</code> 和源 <code>region</code> 具有出现在同一 <code>cell</code> 的情况。</li>
</ul>
</li>
<li><code>mergeRegions</code> 的实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastRegion.cpp

...
static bool mergeRegions(rcRegion&amp; rega, rcRegion&amp; regb)
{
	unsigned short aid = rega.id;
	unsigned short bid = regb.id;
	
	// Duplicate current neighbourhood.
	rcTempVector&lt;int&gt; acon;
	acon.resize(rega.connections.size());
	for (int i = 0; i &lt; rega.connections.size(); ++i)
		acon[i] = rega.connections[i];
	rcTempVector&lt;int&gt;&amp; bcon = regb.connections;
	
	// Find insertion point on A.
	int insa = -1;
	for (int i = 0; i &lt; acon.size(); ++i)
	{
		if (acon[i] == bid)
		{
			insa = i;
			break;
		}
	}
	if (insa == -1)
		return false;
	
	// Find insertion point on B.
	int insb = -1;
	for (int i = 0; i &lt; bcon.size(); ++i)
	{
		if (bcon[i] == aid)
		{
			insb = i;
			break;
		}
	}
	if (insb == -1)
		return false;
	
	// Merge neighbours.
	rega.connections.clear();
	for (int i = 0, ni = static_cast&lt;int&gt;(acon.size()); i &lt; ni-1; ++i)
	{
		rega.connections.push_back(acon[(insa+1+i) % ni]);
	}
		
	for (int i = 0, ni = static_cast&lt;int&gt;(bcon.size()); i &lt; ni-1; ++i)
	{
		rega.connections.push_back(bcon[(insb+1+i) % ni]);
	}
	
	removeAdjacentNeighbours(rega);
	
	for (int j = 0; j &lt; regb.floors.size(); ++j)
		addUniqueFloorRegion(rega, regb.floors[j]);
	rega.spanCount += regb.spanCount;
	regb.spanCount = 0;
	regb.connections.resize(0);

	return true;
}

...
</code></pre><ul>
<li><code>mergeRegions</code> 合并的主要过程为：
<ul>
<li>找出目标 <code>regionId</code> 在源 <code>region</code> 的 <code>connections</code> 中的索引 <code>insa</code> 。</li>
<li>找出源 <code>regionId</code> 在目标 <code>region</code> 的 <code>connections</code> 中的索引 <code>insb</code> 。</li>
<li>清空源 <code>region</code> 的 <code>connections</code>，从 <code>insa + 1</code> 的位置将源 <code>connections</code> 重新加入，<code>insa</code> 位置不加入，因为和目标 <code>region</code> 将要合并，所以原来边界中的目标 <code>regionId</code>，需要插入目标 <code>region</code> 的边界连接。</li>
<li>从 <code>insb + 1</code> 的位置将目标 <code>connections</code> 加入源 <code>connections</code>，同理 <code>insb</code> 位置不加入。</li>
<li>调用 <code>removeAdjacentNeighbours</code> 方法，移除源 <code>connections</code> 中相邻重复的 <code>regionId</code> 。</li>
<li>调用 <code>addUniqueFloorRegion</code> 方法，将目标 <code>floors</code> 加入到源 <code>floors</code> 中。</li>
<li>将目标 <code>spanCount</code> 加到源 <code>spanCount</code> 上，并清空目标 <code>region</code> 的 <code>spanCount</code> 和 <code>connections</code>，完成合并过程。</li>
</ul>
</li>
<li>以 2D 为例，分水岭划分的全过程如下图：
<img src="/img/Algorithm/NavmeshNavigation/Watershed.gif?raw=true" alt=Watershed.gif>
</li>
</ul>
<h3 id=单调划分>单调划分</h3>
<ul>
<li>单调划分通过 <code>rcBuildRegionsMonotone</code> 方法进行，其实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastRegion.cpp

...

static const unsigned short RC_NULL_NEI = 0xffff;

struct rcSweepSpan
{
	unsigned short rid;	// 行索引 id
	unsigned short id;	// 地区 id
	unsigned short ns;	// 该地区 id 采样的跨度个数
	unsigned short nei;	// 邻居的地区 id，通常指下方的 id
};

...
bool rcBuildRegionsMonotone(rcContext* ctx, rcCompactHeightfield&amp; chf,
							const int borderSize, const int minRegionArea, const int mergeRegionArea)
{
	rcAssert(ctx);
	
	rcScopedTimer timer(ctx, RC_TIMER_BUILD_REGIONS);
	
	const int w = chf.width;
	const int h = chf.height;
	unsigned short id = 1;
	
	rcScopedDelete&lt;unsigned short&gt; srcReg((unsigned short*)rcAlloc(sizeof(unsigned short)*chf.spanCount, RC_ALLOC_TEMP));
	if (!srcReg)
	{
		ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildRegionsMonotone: Out of memory 'src' (%d).&quot;, chf.spanCount);
		return false;
	}
	memset(srcReg,0,sizeof(unsigned short)*chf.spanCount);

	const int nsweeps = rcMax(chf.width,chf.height);
	rcScopedDelete&lt;rcSweepSpan&gt; sweeps((rcSweepSpan*)rcAlloc(sizeof(rcSweepSpan)*nsweeps, RC_ALLOC_TEMP));
	if (!sweeps)
	{
		ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildRegionsMonotone: Out of memory 'sweeps' (%d).&quot;, nsweeps);
		return false;
	}
	
	
	// Mark border regions.
	if (borderSize &gt; 0)
	{
		// Make sure border will not overflow.
		const int bw = rcMin(w, borderSize);
		const int bh = rcMin(h, borderSize);
		// Paint regions
		paintRectRegion(0, bw, 0, h, id|RC_BORDER_REG, chf, srcReg); id++;
		paintRectRegion(w-bw, w, 0, h, id|RC_BORDER_REG, chf, srcReg); id++;
		paintRectRegion(0, w, 0, bh, id|RC_BORDER_REG, chf, srcReg); id++;
		paintRectRegion(0, w, h-bh, h, id|RC_BORDER_REG, chf, srcReg); id++;
	}

	chf.borderSize = borderSize;
	
	rcTempVector&lt;int&gt; prev(256);

	// Sweep one line at a time.
	for (int y = borderSize; y &lt; h-borderSize; ++y)
	{
		// Collect spans from this row.
		prev.resize(id+1);
		memset(&amp;prev[0],0,sizeof(int)*id);
		unsigned short rid = 1;
		
		for (int x = borderSize; x &lt; w-borderSize; ++x)
		{
			const rcCompactCell&amp; c = chf.cells[x+y*w];
			
			for (int i = (int)c.index, ni = (int)(c.index+c.count); i &lt; ni; ++i)
			{
				const rcCompactSpan&amp; s = chf.spans[i];
				if (chf.areas[i] == RC_NULL_AREA) continue;
				
				// -x
				unsigned short previd = 0;
				if (rcGetCon(s, 0) != RC_NOT_CONNECTED)
				{
					const int ax = x + rcGetDirOffsetX(0);
					const int ay = y + rcGetDirOffsetY(0);
					const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, 0);
					if ((srcReg[ai] &amp; RC_BORDER_REG) == 0 &amp;&amp; chf.areas[i] == chf.areas[ai])
						previd = srcReg[ai];
				}
				
				if (!previd)
				{
					previd = rid++;
					sweeps[previd].rid = previd;
					sweeps[previd].ns = 0;
					sweeps[previd].nei = 0;
				}

				// -y
				if (rcGetCon(s,3) != RC_NOT_CONNECTED)
				{
					const int ax = x + rcGetDirOffsetX(3);
					const int ay = y + rcGetDirOffsetY(3);
					const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, 3);
					if (srcReg[ai] &amp;&amp; (srcReg[ai] &amp; RC_BORDER_REG) == 0 &amp;&amp; chf.areas[i] == chf.areas[ai])
					{
						unsigned short nr = srcReg[ai];
						if (!sweeps[previd].nei || sweeps[previd].nei == nr)
						{
							sweeps[previd].nei = nr;
							sweeps[previd].ns++;
							prev[nr]++;
						}
						else
						{
							sweeps[previd].nei = RC_NULL_NEI;
						}
					}
				}

				srcReg[i] = previd;
			}
		}
		
		// Create unique ID.
		for (int i = 1; i &lt; rid; ++i)
		{
			if (sweeps[i].nei != RC_NULL_NEI &amp;&amp; sweeps[i].nei != 0 &amp;&amp;
				prev[sweeps[i].nei] == (int)sweeps[i].ns)
			{
				sweeps[i].id = sweeps[i].nei;
			}
			else
			{
				sweeps[i].id = id++;
			}
		}
		
		// Remap IDs
		for (int x = borderSize; x &lt; w-borderSize; ++x)
		{
			const rcCompactCell&amp; c = chf.cells[x+y*w];
			
			for (int i = (int)c.index, ni = (int)(c.index+c.count); i &lt; ni; ++i)
			{
				if (srcReg[i] &gt; 0 &amp;&amp; srcReg[i] &lt; rid)
					srcReg[i] = sweeps[srcReg[i]].id;
			}
		}
	}


	{
		rcScopedTimer timerFilter(ctx, RC_TIMER_BUILD_REGIONS_FILTER);

		// Merge regions and filter out small regions.
		rcTempVector&lt;int&gt; overlaps;
		chf.maxRegions = id;
		if (!mergeAndFilterRegions(ctx, minRegionArea, mergeRegionArea, chf.maxRegions, chf, srcReg, overlaps))
			return false;

		// Monotone partitioning does not generate overlapping regions.
	}
	
	// Store the result out.
	for (int i = 0; i &lt; chf.spanCount; ++i)
		chf.spans[i].reg = srcReg[i];

	return true;
}

...
</code></pre><ul>
<li><code>rcBuildRegionsMonotone</code> 使用了 <code>rcSweepSpan</code> 结构来记录处理过程的关系，主要流程为：
<ul>
<li>通过 <code>paintRectRegion</code> 方法，将 <code>borderSize</code> 范围内的 <code>span</code> 的 <code>region</code> 进行标识（<code>id|RC_BORDER_REG</code>），并设置紧密高度场 <code>chf.borderSize</code> 为 <code>borderSize</code> 。</li>
<li>遍历非 <code>borderSize</code> 范围的 <code>cell</code>，对其中的每个可行走的 <code>span</code> 进行处理。
<ul>
<li>遍历每一行时，将记录当前行 <code>span</code> 被连接的次数 <code>prev</code> 重置为 0，将 <code>rid</code> 重置为 1，</li>
<li>如果当前 <code>span</code> 及其左邻居都可行走，且不在 <code>borderSize</code> 范围，则设置 <code>previd</code> 为左邻居的 <code>regionId</code>。</li>
<li>如果 <code>previd</code> 为 0，则将其设置为当前未分配给 <code>region</code> 的 <code>rid</code>，并将 <code>rid + 1</code>，同时把 <code>previd</code> 记录到 <code>sweeps[pervid]</code> 中。</li>
<li>如果当前 <code>span</code> 及其下邻居都可行走，且不在 <code>borderSize</code> 范围，且下邻居已分配 <code>regionId</code>，则需要设置 <code>sweeps[previd].nei</code>。
<ul>
<li>如果 <code>sweeps[previd].nei</code> 未设置，或者和下邻居的 <code>regionId</code> 相同，则将 <code>sweeps[previd].nei</code> 设置为下邻居的 <code>regionId</code>。
<ul>
<li><code>sweeps[previd].ns</code> 自增，即记录 <code>previd</code> 连接到 <code>nr</code> 的次数。</li>
<li><code>prev[nr]</code> 自增，即记录 <code>nr</code> 被连接的次数。</li>
</ul>
</li>
<li>如果 <code>sweeps[previd].nei</code> 已设置，并且和下邻居的 <code>regionId</code> 不同，则将 <code>sweeps[previd].nei</code> 设置为 <code>RC_NULL_NEI</code>，表示有多个邻居。</li>
</ul>
</li>
<li>将 <code>previd</code> 设置为 <code>srcReg[i]</code> ，即作为当前 <code>span</code> 的 <code>regionId</code>。</li>
<li>设置完每一行 <code>span</code> 的 <code>regionId</code> 后，遍历所有 <code>regionId</code>。
<ul>
<li>如果 <code>sweeps[regionId].nei</code> 不为 0 且不为 <code>RC_NULL_NEI</code>，并且 <code>nei</code> 的连接和被连接数量相同，则将 <code>sweeps[regionId].id</code> 设置为下一行的 <code>regionId</code>，认为是相同的 <code>region</code>。</li>
<li>如果 <code>sweeps[regionId].nei</code> 为 0 或 <code>RC_NULL_NEI</code>，或 <code>nei</code> 的连接和被连接数量不相同，则将 <code>sweeps[regionId].id</code> 设置为 <code>id</code> ，即当前未使用的 <code>regionId</code>，认为是不同的 <code>region</code>，并将 <code>id</code> 自增。</li>
</ul>
</li>
<li>将每一行 <code>sweeps</code> 记录的 <code>regionId</code>，更新到 <code>srcReg</code> 中。</li>
</ul>
</li>
<li>通过 <code>mergeAndFilterRegions</code>，进行 <code>region</code> 的合并和过滤。</li>
<li>将 <code>srcReg</code> 记录的最终 <code>region</code> 信息，应用到紧密高度场中的每一个 <code>span</code>，完成划分。</li>
</ul>
</li>
<li>以 2D 为例，单调划分的全过程如下图：
<img src="/img/Algorithm/NavmeshNavigation/Monotone.gif?raw=true" alt=Monotone.gif>
</li>
</ul>
<h3 id=分层划分>分层划分</h3>
<ul>
<li>分层划分通过 <code>rcBuildRegionsLayer</code> 方法进行，其实现和单调划分基本一致，唯一不同的，就是单调划分使用 <code>mergeAndFilterRegions</code> 方法进行合并和过滤，而分层划分使用 <code>mergeAndFilterLayerRegions</code> 方法，其实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastRegion.cpp

...

static bool mergeAndFilterLayerRegions(rcContext* ctx, int minRegionArea,
									   unsigned short&amp; maxRegionId,
									   rcCompactHeightfield&amp; chf,
									   unsigned short* srcReg)
{
	const int w = chf.width;
	const int h = chf.height;
	
	const int nreg = maxRegionId+1;
	rcTempVector&lt;rcRegion&gt; regions;
	
	// Construct regions
	if (!regions.reserve(nreg)) {
		ctx-&gt;log(RC_LOG_ERROR, &quot;mergeAndFilterLayerRegions: Out of memory 'regions' (%d).&quot;, nreg);
		return false;
	}
	for (int i = 0; i &lt; nreg; ++i)
		regions.push_back(rcRegion((unsigned short) i));
	
	// Find region neighbours and overlapping regions.
	rcTempVector&lt;int&gt; lregs(32);
	for (int y = 0; y &lt; h; ++y)
	{
		for (int x = 0; x &lt; w; ++x)
		{
			const rcCompactCell&amp; c = chf.cells[x+y*w];

			lregs.clear();
			
			for (int i = (int)c.index, ni = (int)(c.index+c.count); i &lt; ni; ++i)
			{
				const rcCompactSpan&amp; s = chf.spans[i];
				const unsigned char area = chf.areas[i];
				const unsigned short ri = srcReg[i];
				if (ri == 0 || ri &gt;= nreg) continue;
				rcRegion&amp; reg = regions[ri];
				
				reg.spanCount++;
				reg.areaType = area;

				reg.ymin = rcMin(reg.ymin, s.y);
				reg.ymax = rcMax(reg.ymax, s.y);
				
				// Collect all region layers.
				lregs.push_back(ri);
				
				// Update neighbours
				for (int dir = 0; dir &lt; 4; ++dir)
				{
					if (rcGetCon(s, dir) != RC_NOT_CONNECTED)
					{
						const int ax = x + rcGetDirOffsetX(dir);
						const int ay = y + rcGetDirOffsetY(dir);
						const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, dir);
						const unsigned short rai = srcReg[ai];
						if (rai &gt; 0 &amp;&amp; rai &lt; nreg &amp;&amp; rai != ri)
							addUniqueConnection(reg, rai);
						if (rai &amp; RC_BORDER_REG)
							reg.connectsToBorder = true;
					}
				}
				
			}
			
			// Update overlapping regions.
			for (int i = 0; i &lt; lregs.size()-1; ++i)
			{
				for (int j = i+1; j &lt; lregs.size(); ++j)
				{
					if (lregs[i] != lregs[j])
					{
						rcRegion&amp; ri = regions[lregs[i]];
						rcRegion&amp; rj = regions[lregs[j]];
						addUniqueFloorRegion(ri, lregs[j]);
						addUniqueFloorRegion(rj, lregs[i]);
					}
				}
			}
			
		}
	}

	// Create 2D layers from regions.
	unsigned short layerId = 1;

	for (int i = 0; i &lt; nreg; ++i)
		regions[i].id = 0;

	// Merge montone regions to create non-overlapping areas.
	rcTempVector&lt;int&gt; stack(32);
	for (int i = 1; i &lt; nreg; ++i)
	{
		rcRegion&amp; root = regions[i];
		// Skip already visited.
		if (root.id != 0)
			continue;
		
		// Start search.
		root.id = layerId;

		stack.clear();
		stack.push_back(i);
		
		while (stack.size() &gt; 0)
		{
			// Pop front
			rcRegion&amp; reg = regions[stack[0]];
			for (int j = 0; j &lt; stack.size()-1; ++j)
				stack[j] = stack[j+1];
			stack.resize(stack.size()-1);
			
			const int ncons = (int)reg.connections.size();
			for (int j = 0; j &lt; ncons; ++j)
			{
				const int nei = reg.connections[j];
				rcRegion&amp; regn = regions[nei];
				// Skip already visited.
				if (regn.id != 0)
					continue;
				// Skip if different area type, do not connect regions with different area type.
				if (reg.areaType != regn.areaType)
					continue;
				// Skip if the neighbour is overlapping root region.
				bool overlap = false;
				for (int k = 0; k &lt; root.floors.size(); k++)
				{
					if (root.floors[k] == nei)
					{
						overlap = true;
						break;
					}
				}
				if (overlap)
					continue;
					
				// Deepen
				stack.push_back(nei);
					
				// Mark layer id
				regn.id = layerId;
				// Merge current layers to root.
				for (int k = 0; k &lt; regn.floors.size(); ++k)
					addUniqueFloorRegion(root, regn.floors[k]);
				root.ymin = rcMin(root.ymin, regn.ymin);
				root.ymax = rcMax(root.ymax, regn.ymax);
				root.spanCount += regn.spanCount;
				regn.spanCount = 0;
				root.connectsToBorder = root.connectsToBorder || regn.connectsToBorder;
			}
		}
		
		layerId++;
	}
	
	// Remove small regions
	for (int i = 0; i &lt; nreg; ++i)
	{
		if (regions[i].spanCount &gt; 0 &amp;&amp; regions[i].spanCount &lt; minRegionArea &amp;&amp; !regions[i].connectsToBorder)
		{
			unsigned short reg = regions[i].id;
			for (int j = 0; j &lt; nreg; ++j)
				if (regions[j].id == reg)
					regions[j].id = 0;
		}
	}
	
	// Compress region Ids.
	for (int i = 0; i &lt; nreg; ++i)
	{
		regions[i].remap = false;
		if (regions[i].id == 0) continue;				// Skip nil regions.
		if (regions[i].id &amp; RC_BORDER_REG) continue;    // Skip external regions.
		regions[i].remap = true;
	}
	
	unsigned short regIdGen = 0;
	for (int i = 0; i &lt; nreg; ++i)
	{
		if (!regions[i].remap)
			continue;
		unsigned short oldId = regions[i].id;
		unsigned short newId = ++regIdGen;
		for (int j = i; j &lt; nreg; ++j)
		{
			if (regions[j].id == oldId)
			{
				regions[j].id = newId;
				regions[j].remap = false;
			}
		}
	}
	maxRegionId = regIdGen;
	
	// Remap regions.
	for (int i = 0; i &lt; chf.spanCount; ++i)
	{
		if ((srcReg[i] &amp; RC_BORDER_REG) == 0)
			srcReg[i] = regions[srcReg[i]].id;
	}
	
	return true;
}

...
</code></pre><ul>
<li><code>mergeAndFilterLayerRegions</code> 的主要流程为：
<ul>
<li>设置 <code>region</code> 的基本信息。
<ul>
<li>为每一个 <code>regionId</code> 创建一个 <code>rcRegion</code>，遍历所有 <code>cell</code> 上的所有 <code>span</code> 进行处理，包括：
<ul>
<li>将同一 <code>regionId</code> 的 <code>span</code> 数量统计到 <code>reg.spanCount</code> 中。</li>
<li>设置当前 <code>reg.areaType</code>。</li>
<li>设置当前 <code>reg.ymin</code> 和 <code>reg.ymax</code> 为 <code>cell</code> 上所有 <code>span</code> 中的最小最大 <code>span.y</code>。</li>
<li>检查四个方向的邻居，通过 <code>addUniqueConnection</code> 方法将邻居的 <code>regionId</code> 加入到 <code>reg.connections</code> 中。如果邻居为 <code>borderSize</code> 范围的边界，则设置 <code>reg.connectsToBorder</code> 为 <code>true</code>。</li>
<li>检查当前 <code>cell</code> 上所有连续且 <code>regionId</code> 不同的 <code>span</code>，通过 <code>addUniqueFloorRegion</code> 方法，分别将 <code>regionId</code> 加入到彼此的 <code>floors</code> 列表中。</li>
</ul>
</li>
</ul>
</li>
<li>合并没有重叠的 <code>region</code>。
<ul>
<li>初始化 <code>layerId</code> 为 1 。</li>
<li>将所有 <code>region</code> 的 <code>id</code> 初始化为 0 。</li>
<li>遍历每一个 <code>region</code> 进行处理。
<ul>
<li>如果当前 <code>regionId</code> 不为 0 ，则表示该 <code>regionId</code> 已经处理过，则不再处理。</li>
<li>设置当前 <code>region</code> 的 <code>regionId</code> 为 <code>layerId</code>。</li>
<li>清空 <code>stack</code>，将当前 <code>region</code> 加入到 <code>stack</code> 中，进行迭代处理。
<ul>
<li>从 <code>stack</code> 中取出一个 <code>reg</code>，从 <code>connections</code> 中找到所有未处理过的可行走的邻居 <code>regionId</code>，如果当前 <code>region</code> 的 <code>floors</code> 中不包含邻居 <code>regionId</code>，则代表该 <code>regionId</code> 没有和当前 <code>region</code> 重叠，则将邻居 <code>region</code> 合并到当前 <code>region</code>。
<ul>
<li>将邻居 <code>regionId</code> 加入到 <code>stack</code> 中。</li>
<li>将邻居 <code>region</code> 的 <code>id</code> 设置为 <code>layerId</code>，即标记为已处理。</li>
<li>将邻居的 <code>floors</code> 添加到当前 <code>region</code> 中。</li>
<li>将邻居和当前 <code>region</code> 中最小的 <code>ymin</code> 和最大的 <code>ymax</code> 设置到当前 <code>region</code> 中。</li>
<li>将邻居的 <code>spanCount</code> 加入到当前 <code>region</code>，清空邻居的 <code>spanCount</code>。</li>
<li>如果邻居或当前 <code>region</code> 连接到 <code>borderSize</code> 范围的边界，则设置当前 <code>region</code> 的 <code>connectsToBorder</code> 为 <code>true</code>。</li>
</ul>
</li>
<li>如果出现重叠，则继续 <code>stack</code> 的迭代处理。</li>
</ul>
</li>
<li>处理完一个 <code>regionId</code> ，则 <code>layerId</code> 自增，继续下一个 <code>regionId</code> 。</li>
</ul>
</li>
</ul>
</li>
<li>移除过小的 <code>region</code>。
<ul>
<li>从 1 开始遍历所有的 <code>region</code>，如果 <code>spanCount</code> 大于 0 且小于 <code>minRegionArea</code>，且没有连接到 <code>borderSize</code> 范围的边界，则此 <code>regionId</code> 需要被移除。由于上一步中合并后，同一个 <code>regionId</code> 会处于多个 <code>region</code> 中，但其中只有一个 <code>spanCount</code> 大于 0 ，所以需要将所有 <code>id</code> 为此 <code>regionId</code> 的 <code>region</code>，设置其 <code>id</code> 为 0。</li>
</ul>
</li>
<li>重新映射 <code>regionId</code>。
<ul>
<li>遍历所有的 <code>region</code>，从 1 开始设置剩余的 <code>region</code>，将 <code>regionId</code> 映射为新的区间。</li>
</ul>
</li>
<li>应用新的 <code>regionId</code>。
<ul>
<li>遍历 <code>srcReg</code>，使用新的 <code>regionId</code> 进行替换。</li>
</ul>
</li>
</ul>
</li>
<li>以 2D 为例，分层划分的全过程如下图：
<img src="/img/Algorithm/NavmeshNavigation/Layers.gif?raw=true" alt=Layers.gif>
</li>
</ul>
<h3 id=算法对比>算法对比</h3>
<table>
<thead>
<tr>
<th style=text-align:center></th>
<th style=text-align:center>分水岭划分</th>
<th style=text-align:center>单调划分</th>
<th style=text-align:center>分层划分</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center>主要内容</td>
<td style=text-align:center>计算距离场，洪水填充，按块合并</td>
<td style=text-align:center>扫描填充，按块合并</td>
<td style=text-align:center>扫描填充，分层合并</td>
</tr>
<tr>
<td style=text-align:center>性能开销</td>
<td style=text-align:center>高<br>（需要计算整个距离场，洪水填充过程也需要多次迭代处理）</td>
<td style=text-align:center>低<br>（扫描填充计算量少，按块合并跳过在同一个 <code>cell</code> 上出现多次的 <code>region</code> ，即仅处理单层 <code>region</code>）</td>
<td style=text-align:center>中<br>（分层合并需要检查每个 <code>region</code> 的 <code>connections</code> 是否出现在当前 <code>cell</code> ，即需要层级关系，合并后还需要递归检查）</td>
</tr>
<tr>
<td style=text-align:center>适用场景</td>
<td style=text-align:center>开放空间和复杂地形</td>
<td style=text-align:center>简单的平面</td>
<td style=text-align:center>多层或垂直空间</td>
</tr>
</tbody>
</table>
<h1 id=五查找并简化地区轮廓>五、查找并简化地区轮廓</h1>
<ul>
<li>处理地区轮廓过程，引入了几个新的结构：
<ul>
<li><code>rcContourSet</code> ：整个高度场的轮廓信息。</li>
<li><code>rcContour</code>：单个轮廓的信息。</li>
<li><code>rcContourRegion</code> ：单个 <code>region</code> 下的轮廓信息。</li>
<li><code>rcContourHole</code> ： 单个孔洞的轮廓信息。</li>
<li><code>rcPotentialDiagonal</code> ： 对角线信息。</li>
</ul>
</li>
</ul>
<pre tabindex=0><code>// Recast/Include/Recast.h

...

struct  rcContour
{
	int* verts;			/// 简化后的轮廓顶点
	int nverts;			/// 简化后的轮廓顶点数量 
	int* rverts;		/// 原始轮廓顶点
	int nrverts;		/// 原始轮廓顶点数量
	unsigned short reg;	/// 轮廓的地区id
	unsigned char area;	/// 轮廓的区域id
};


struct rcContourSet
{
	...

	rcContour* conts;	/// 轮廓列表
	int nconts;			/// 轮廓数量
	float bmin[3];  	/// rcHeightfield.bmin + borderSize
	float bmax[3];		/// rcHeightfield.bmax - borderSize
	float cs;			/// 同 rcHeightfield
	float ch;			/// 同 rcHeightfield
	int width;			/// rcHeightfield.width - borderSize * 2
	int height;			/// rcHeightfield.height - borderSize * 2
	int borderSize;		/// 同 rcConfig::borderSize
	float maxError;		/// 轮廓简化后的最大边缘误差
	
	...
};

...
</code></pre><pre tabindex=0><code>// Recast/Source/RecastContour.cpp
...

struct rcContourHole
{
	rcContour* contour;			/// 孔洞的轮廓
	int minx, minz, leftmost;	/// 孔洞的轮廓点中最小 x、z 坐标和对应的索引
};

struct rcContourRegion
{
	rcContour* outline;			/// 当前地区的外轮廓（一个地区只能有一个外轮廓）
 	rcContourHole* holes;		/// 当前地区的孔洞列表
	int nholes;					/// 当前地区的孔洞数量
};

struct rcPotentialDiagonal
{
	int vert;					/// 外轮廓的顶点索引
	int dist;					/// 外轮廓顶点到目标点的距离平方
};

...
</code></pre><ul>
<li>处理过程主要通过 <code>rcBuildContours</code> 方法实现，其代码如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastContour.cpp

...

bool rcBuildContours(rcContext* ctx, const rcCompactHeightfield&amp; chf,
					 const float maxError, const int maxEdgeLen,
					 rcContourSet&amp; cset, const int buildFlags)
{
	rcAssert(ctx);
	
	const int w = chf.width;
	const int h = chf.height;
	const int borderSize = chf.borderSize;
	
	rcScopedTimer timer(ctx, RC_TIMER_BUILD_CONTOURS);
	
	rcVcopy(cset.bmin, chf.bmin);
	rcVcopy(cset.bmax, chf.bmax);
	if (borderSize &gt; 0)
	{
		// If the heightfield was build with bordersize, remove the offset.
		const float pad = borderSize*chf.cs;
		cset.bmin[0] += pad;
		cset.bmin[2] += pad;
		cset.bmax[0] -= pad;
		cset.bmax[2] -= pad;
	}
	cset.cs = chf.cs;
	cset.ch = chf.ch;
	cset.width = chf.width - chf.borderSize*2;
	cset.height = chf.height - chf.borderSize*2;
	cset.borderSize = chf.borderSize;
	cset.maxError = maxError;
	
	int maxContours = rcMax((int)chf.maxRegions, 8);
	cset.conts = (rcContour*)rcAlloc(sizeof(rcContour)*maxContours, RC_ALLOC_PERM);
	if (!cset.conts)
		return false;
	cset.nconts = 0;
	
	rcScopedDelete&lt;unsigned char&gt; flags((unsigned char*)rcAlloc(sizeof(unsigned char)*chf.spanCount, RC_ALLOC_TEMP));
	if (!flags)
	{
		ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildContours: Out of memory 'flags' (%d).&quot;, chf.spanCount);
		return false;
	}
	
	ctx-&gt;startTimer(RC_TIMER_BUILD_CONTOURS_TRACE);
	
	// Mark boundaries.
	for (int y = 0; y &lt; h; ++y)
	{
		for (int x = 0; x &lt; w; ++x)
		{
			const rcCompactCell&amp; c = chf.cells[x+y*w];
			for (int i = (int)c.index, ni = (int)(c.index+c.count); i &lt; ni; ++i)
			{
				unsigned char res = 0;
				const rcCompactSpan&amp; s = chf.spans[i];
				if (!chf.spans[i].reg || (chf.spans[i].reg &amp; RC_BORDER_REG))
				{
					flags[i] = 0;
					continue;
				}
				for (int dir = 0; dir &lt; 4; ++dir)
				{
					unsigned short r = 0;
					if (rcGetCon(s, dir) != RC_NOT_CONNECTED)
					{
						const int ax = x + rcGetDirOffsetX(dir);
						const int ay = y + rcGetDirOffsetY(dir);
						const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, dir);
						r = chf.spans[ai].reg;
					}
					if (r == chf.spans[i].reg)
						res |= (1 &lt;&lt; dir);
				}
				flags[i] = res ^ 0xf; // Inverse, mark non connected edges.
			}
		}
	}
	
	ctx-&gt;stopTimer(RC_TIMER_BUILD_CONTOURS_TRACE);
	
	rcTempVector&lt;int&gt; verts(256);
	rcTempVector&lt;int&gt; simplified(64);
	
	for (int y = 0; y &lt; h; ++y)
	{
		for (int x = 0; x &lt; w; ++x)
		{
			const rcCompactCell&amp; c = chf.cells[x+y*w];
			for (int i = (int)c.index, ni = (int)(c.index+c.count); i &lt; ni; ++i)
			{
				if (flags[i] == 0 || flags[i] == 0xf)
				{
					flags[i] = 0;
					continue;
				}
				const unsigned short reg = chf.spans[i].reg;
				if (!reg || (reg &amp; RC_BORDER_REG))
					continue;
				const unsigned char area = chf.areas[i];
				
				verts.clear();
				simplified.clear();
				
				ctx-&gt;startTimer(RC_TIMER_BUILD_CONTOURS_TRACE);
				walkContour(x, y, i, chf, flags, verts);
				ctx-&gt;stopTimer(RC_TIMER_BUILD_CONTOURS_TRACE);
				
				ctx-&gt;startTimer(RC_TIMER_BUILD_CONTOURS_SIMPLIFY);
				simplifyContour(verts, simplified, maxError, maxEdgeLen, buildFlags);
				removeDegenerateSegments(simplified);
				ctx-&gt;stopTimer(RC_TIMER_BUILD_CONTOURS_SIMPLIFY);
				
				
				// Store region-&gt;contour remap info.
				// Create contour.
				if (simplified.size()/4 &gt;= 3)
				{
					if (cset.nconts &gt;= maxContours)
					{
						// Allocate more contours.
						// This happens when a region has holes.
						const int oldMax = maxContours;
						maxContours *= 2;
						rcContour* newConts = (rcContour*)rcAlloc(sizeof(rcContour)*maxContours, RC_ALLOC_PERM);
						for (int j = 0; j &lt; cset.nconts; ++j)
						{
							newConts[j] = cset.conts[j];
							// Reset source pointers to prevent data deletion.
							cset.conts[j].verts = 0;
							cset.conts[j].rverts = 0;
						}
						rcFree(cset.conts);
						cset.conts = newConts;
						
						ctx-&gt;log(RC_LOG_WARNING, &quot;rcBuildContours: Expanding max contours from %d to %d.&quot;, oldMax, maxContours);
					}
					
					rcContour* cont = &amp;cset.conts[cset.nconts++];
					
					cont-&gt;nverts = static_cast&lt;int&gt;(simplified.size()) / 4;
					cont-&gt;verts = (int*)rcAlloc(sizeof(int)*cont-&gt;nverts*4, RC_ALLOC_PERM);
					if (!cont-&gt;verts)
					{
						ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildContours: Out of memory 'verts' (%d).&quot;, cont-&gt;nverts);
						return false;
					}
					memcpy(cont-&gt;verts, &amp;simplified[0], sizeof(int)*cont-&gt;nverts*4);
					if (borderSize &gt; 0)
					{
						// If the heightfield was build with bordersize, remove the offset.
						for (int j = 0; j &lt; cont-&gt;nverts; ++j)
						{
							int* v = &amp;cont-&gt;verts[j*4];
							v[0] -= borderSize;
							v[2] -= borderSize;
						}
					}
					
					cont-&gt;nrverts = static_cast&lt;int&gt;(verts.size()) / 4;
					cont-&gt;rverts = static_cast&lt;int*&gt;(rcAlloc(sizeof(int) * cont-&gt;nrverts * 4, RC_ALLOC_PERM));
					if (!cont-&gt;rverts)
					{
						ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildContours: Out of memory 'rverts' (%d).&quot;, cont-&gt;nrverts);
						return false;
					}
					memcpy(cont-&gt;rverts, &amp;verts[0], sizeof(int)*cont-&gt;nrverts*4);
					if (borderSize &gt; 0)
					{
						// If the heightfield was build with bordersize, remove the offset.
						for (int j = 0; j &lt; cont-&gt;nrverts; ++j)
						{
							int* v = &amp;cont-&gt;rverts[j*4];
							v[0] -= borderSize;
							v[2] -= borderSize;
						}
					}
					
					cont-&gt;reg = reg;
					cont-&gt;area = area;
				}
			}
		}
	}
	
	// Merge holes if needed.
	if (cset.nconts &gt; 0)
	{
		// Calculate winding of all polygons.
		rcScopedDelete&lt;signed char&gt; winding((signed char*)rcAlloc(sizeof(signed char)*cset.nconts, RC_ALLOC_TEMP));
		if (!winding)
		{
			ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildContours: Out of memory 'hole' (%d).&quot;, cset.nconts);
			return false;
		}
		int nholes = 0;
		for (int i = 0; i &lt; cset.nconts; ++i)
		{
			rcContour&amp; cont = cset.conts[i];
			// If the contour is wound backwards, it is a hole.
			winding[i] = calcAreaOfPolygon2D(cont.verts, cont.nverts) &lt; 0 ? -1 : 1;
			if (winding[i] &lt; 0)
				nholes++;
		}
		
		if (nholes &gt; 0)
		{
			// Collect outline contour and holes contours per region.
			// We assume that there is one outline and multiple holes.
			const int nregions = chf.maxRegions+1;
			rcScopedDelete&lt;rcContourRegion&gt; regions((rcContourRegion*)rcAlloc(sizeof(rcContourRegion)*nregions, RC_ALLOC_TEMP));
			if (!regions)
			{
				ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildContours: Out of memory 'regions' (%d).&quot;, nregions);
				return false;
			}
			memset(regions, 0, sizeof(rcContourRegion)*nregions);
			
			rcScopedDelete&lt;rcContourHole&gt; holes((rcContourHole*)rcAlloc(sizeof(rcContourHole)*cset.nconts, RC_ALLOC_TEMP));
			if (!holes)
			{
				ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildContours: Out of memory 'holes' (%d).&quot;, cset.nconts);
				return false;
			}
			memset(holes, 0, sizeof(rcContourHole)*cset.nconts);
			
			for (int i = 0; i &lt; cset.nconts; ++i)
			{
				rcContour&amp; cont = cset.conts[i];
				// Positively would contours are outlines, negative holes.
				if (winding[i] &gt; 0)
				{
					if (regions[cont.reg].outline)
						ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildContours: Multiple outlines for region %d.&quot;, cont.reg);
					regions[cont.reg].outline = &amp;cont;
				}
				else
				{
					regions[cont.reg].nholes++;
				}
			}
			int index = 0;
			for (int i = 0; i &lt; nregions; i++)
			{
				if (regions[i].nholes &gt; 0)
				{
					regions[i].holes = &amp;holes[index];
					index += regions[i].nholes;
					regions[i].nholes = 0;
				}
			}
			for (int i = 0; i &lt; cset.nconts; ++i)
			{
				rcContour&amp; cont = cset.conts[i];
				rcContourRegion&amp; reg = regions[cont.reg];
				if (winding[i] &lt; 0)
					reg.holes[reg.nholes++].contour = &amp;cont;
			}
			
			// Finally merge each regions holes into the outline.
			for (int i = 0; i &lt; nregions; i++)
			{
				rcContourRegion&amp; reg = regions[i];
				if (!reg.nholes) continue;
				
				if (reg.outline)
				{
					mergeRegionHoles(ctx, reg);
				}
				else
				{
					// The region does not have an outline.
					// This can happen if the contour becaomes selfoverlapping because of
					// too aggressive simplification settings.
					ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildContours: Bad outline for region %d, contour simplification is likely too aggressive.&quot;, i);
				}
			}
		}
		
	}
	
	return true;
}
</code></pre><ul>
<li>处理轮廓的主要步骤如下：
<ul>
<li>初始化 <code>rcContourSet</code> 结构 <code>cset</code>，根据 <code>borderSize</code> 设置 <code>cset</code> 的 <code>bmin</code> 和 <code>bmax</code> ，即 <code>cset.bmin</code> = <code>chf.bmin</code> + <code>borderSize</code> 和 <code>cset.bmax</code> = <code>chf.bmax</code> - <code>borderSize</code>。</li>
<li>创建 <code>rcContour</code> 数组 <code>cset.conts</code> ，用于存储轮廓数据。</li>
<li>遍历每个 <code>cell</code> 上的 <code>span</code> 进行处理。
<ul>
<li>如果 <code>span</code> 不可通行或者为 <code>borderSize</code> 范围的边界，则标记当前 <code>span</code> 的无边界。</li>
<li>检查 <code>span</code> 的四个邻居，将不可通行或 <code>region</code> 与自身不同的方向标记为边界。</li>
</ul>
</li>
<li>再次遍历每个 <code>cell</code> 上的 <code>span</code>进行处理。
<ul>
<li>如果 <code>span</code> 无边界或四个方向都为边界，则标记为无边界，不处理。</li>
<li>如果 <code>span</code> 不可通行或者为 <code>borderSize</code> 范围的边界，则不处理。</li>
<li>通过 <code>walkContour</code> 方法找到 <code>span</code> 的轮廓顶点。</li>
<li>通过 <code>simplifyContour</code> 方法简化轮廓顶点。</li>
<li>通过 <code>removeDegenerateSegments</code> 方法，将相邻轮廓顶点中 x、z 坐标相同的顶点移除。</li>
<li>由于 <code>cset</code> 的基准点发生了变化，所以将简化前后的轮廓顶点减去 <code>borderSize</code> 后记录到 <code>cset</code> 中，设置所属的 <code>region</code> 和 <code>area</code>。</li>
</ul>
</li>
<li>合并孔洞。
<ul>
<li>遍历 <code>cset.conts</code> 中的每个轮廓，通过 <code>calcAreaOfPolygon2D</code> 方法计算轮廓组成的多边形面积，如果小于 0，表示该轮廓为孔洞。</li>
<li>如果没有孔洞，则直接跳过。如果存在孔洞，则需要进行处理。
<ul>
<li>遍历所有轮廓，将轮廓按所属的 <code>region</code> 分组，将轮廓分为 <code>outline</code> 和 <code>holes</code>。每个 <code>region</code> 有且只能有一个 <code>outline</code>，可以有多个 <code>hole</code>。</li>
<li>遍历所有 <code>region</code> 对应的分组，对有 <code>outline</code> 和 <code>holes</code> 的轮廓，调用 <code>mergeRegionHoles</code> 方法进行合并处理。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>处理完成后，通常情况下，<code>cset.conts</code> 中只剩下多个不同 <code>region</code> 的 <code>outline</code> ，而 <code>holes</code> 则都会被合并到 <code>outline</code> 中。</li>
</ul>
<h2 id=寻找轮廓顶点>寻找轮廓顶点</h2>
<ul>
<li>寻找轮廓顶点通过 <code>walkContour(RecastContour.cpp)</code> 方法实现，而前面分水岭算法中使用的是 <code>walkContour(RecastRegion.cpp)</code>，两者思路类似，具体实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastContour.cpp

...

static void walkContour(int x, int y, int i,
						const rcCompactHeightfield&amp; chf,
						unsigned char* flags, rcTempVector&lt;int&gt;&amp; points)
{
	// Choose the first non-connected edge
	unsigned char dir = 0;
	while ((flags[i] &amp; (1 &lt;&lt; dir)) == 0)
		dir++;
	
	unsigned char startDir = dir;
	int starti = i;
	
	const unsigned char area = chf.areas[i];
	
	int iter = 0;
	while (++iter &lt; 40000)
	{
		if (flags[i] &amp; (1 &lt;&lt; dir))
		{
			// Choose the edge corner
			bool isBorderVertex = false;
			bool isAreaBorder = false;
			int px = x;
			int py = getCornerHeight(x, y, i, dir, chf, isBorderVertex);
			int pz = y;
			switch(dir)
			{
				case 0: pz++; break;
				case 1: px++; pz++; break;
				case 2: px++; break;
			}
			int r = 0;
			const rcCompactSpan&amp; s = chf.spans[i];
			if (rcGetCon(s, dir) != RC_NOT_CONNECTED)
			{
				const int ax = x + rcGetDirOffsetX(dir);
				const int ay = y + rcGetDirOffsetY(dir);
				const int ai = (int)chf.cells[ax+ay*chf.width].index + rcGetCon(s, dir);
				r = (int)chf.spans[ai].reg;
				if (area != chf.areas[ai])
					isAreaBorder = true;
			}
			if (isBorderVertex)
				r |= RC_BORDER_VERTEX;
			if (isAreaBorder)
				r |= RC_AREA_BORDER;
			points.push_back(px);
			points.push_back(py);
			points.push_back(pz);
			points.push_back(r);
			
			flags[i] &amp;= ~(1 &lt;&lt; dir); // Remove visited edges
			dir = (dir+1) &amp; 0x3;  // Rotate CW
		}
		else
		{
			int ni = -1;
			const int nx = x + rcGetDirOffsetX(dir);
			const int ny = y + rcGetDirOffsetY(dir);
			const rcCompactSpan&amp; s = chf.spans[i];
			if (rcGetCon(s, dir) != RC_NOT_CONNECTED)
			{
				const rcCompactCell&amp; nc = chf.cells[nx+ny*chf.width];
				ni = (int)nc.index + rcGetCon(s, dir);
			}
			if (ni == -1)
			{
				// Should not happen.
				return;
			}
			x = nx;
			y = ny;
			i = ni;
			dir = (dir+3) &amp; 0x3;	// Rotate CCW
		}
		
		if (starti == i &amp;&amp; startDir == dir)
		{
			break;
		}
	}
}

...
</code></pre><ul>
<li>寻找轮廓顶点过程，使用了 <code>points</code> 数组来记录原始轮廓点，每个原始轮廓点使用 4 个整数来表示，依次为 x 、y 、z 和 <code>region</code> 信息。其中 <code>region</code> 信息经过二次处理，加上了 <code>area</code> 边界标记（和邻居的 <code>area</code> 不同时）和 <code>borderSize</code> 边界标记（和 <code>borderSize</code> 相邻或处于其中）。</li>
<li><code>walkContour</code> 的主要步骤如下：
<ul>
<li>找到第一个边界方向，作为起始方向，当前 <code>span</code> 作为起始 <code>span</code>。</li>
<li>迭代检查当前 <code>span</code> 的当前方向是否为边界方向。
<ul>
<li>如果当前方向为边界，则
<ul>
<li>通过 <code>getCornerHeight</code> 方法获取当前点的 y 坐标即是否为 <code>borderSize</code> 边界点，如果方向为 0 或 1，则 z 坐标加 1，如果方向为 1 或 2 ，则 x 坐标加 1。
<ul>
<li>x 、z 坐标通过边界所在的方向进行偏移，从而保证最终得到的每个轮廓都为右上包含边界，左下不包含边界，避免出现重复。</li>
</ul>
</li>
<li>获取当前方向的邻居 <code>span</code> 的 <code>region</code> 信息，将边界信息记录到其中。</li>
<li>将当前点的坐标 x 、y 、z 和 <code>region</code> 记录到 <code>points</code> 中，作为一个轮廓顶点。</li>
<li>清除当前 <code>span</code> 的当前方向标记，后续不再处理该方向。</li>
<li>将方向设置为下一个方向。</li>
</ul>
</li>
<li>如果当前方向不为边界或已经处理过，则
<ul>
<li>将当前方向的邻居 <code>span</code> 作为当前 <code>span</code>，并设置方向为上一个方向，迭代进行检查处理。</li>
</ul>
</li>
</ul>
</li>
<li>直到当前 <code>span</code> 和起始 <code>span</code> 相同，且方向相同，则结束迭代，完成轮廓的查找。
<img src="/img/Algorithm/NavmeshNavigation/WalkContour.gif?raw=true" alt=WalkContour.gif>
</li>
</ul>
</li>
<li><code>getCornerHeight</code> 方法的实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastContour.cpp

...

static int getCornerHeight(int x, int y, int i, int dir,
						   const rcCompactHeightfield&amp; chf,
						   bool&amp; isBorderVertex)
{
	const rcCompactSpan&amp; s = chf.spans[i];
	int ch = (int)s.y;
	int dirp = (dir+1) &amp; 0x3;
	
	unsigned int regs[4] = {0,0,0,0};
	
	// Combine region and area codes in order to prevent
	// border vertices which are in between two areas to be removed.
	regs[0] = chf.spans[i].reg | (chf.areas[i] &lt;&lt; 16);
	
	if (rcGetCon(s, dir) != RC_NOT_CONNECTED)
	{
		const int ax = x + rcGetDirOffsetX(dir);
		const int ay = y + rcGetDirOffsetY(dir);
		const int ai = (int)chf.cells[ax+ay*chf.width].index + rcGetCon(s, dir);
		const rcCompactSpan&amp; as = chf.spans[ai];
		ch = rcMax(ch, (int)as.y);
		regs[1] = chf.spans[ai].reg | (chf.areas[ai] &lt;&lt; 16);
		if (rcGetCon(as, dirp) != RC_NOT_CONNECTED)
		{
			const int ax2 = ax + rcGetDirOffsetX(dirp);
			const int ay2 = ay + rcGetDirOffsetY(dirp);
			const int ai2 = (int)chf.cells[ax2+ay2*chf.width].index + rcGetCon(as, dirp);
			const rcCompactSpan&amp; as2 = chf.spans[ai2];
			ch = rcMax(ch, (int)as2.y);
			regs[2] = chf.spans[ai2].reg | (chf.areas[ai2] &lt;&lt; 16);
		}
	}
	if (rcGetCon(s, dirp) != RC_NOT_CONNECTED)
	{
		const int ax = x + rcGetDirOffsetX(dirp);
		const int ay = y + rcGetDirOffsetY(dirp);
		const int ai = (int)chf.cells[ax+ay*chf.width].index + rcGetCon(s, dirp);
		const rcCompactSpan&amp; as = chf.spans[ai];
		ch = rcMax(ch, (int)as.y);
		regs[3] = chf.spans[ai].reg | (chf.areas[ai] &lt;&lt; 16);
		if (rcGetCon(as, dir) != RC_NOT_CONNECTED)
		{
			const int ax2 = ax + rcGetDirOffsetX(dir);
			const int ay2 = ay + rcGetDirOffsetY(dir);
			const int ai2 = (int)chf.cells[ax2+ay2*chf.width].index + rcGetCon(as, dir);
			const rcCompactSpan&amp; as2 = chf.spans[ai2];
			ch = rcMax(ch, (int)as2.y);
			regs[2] = chf.spans[ai2].reg | (chf.areas[ai2] &lt;&lt; 16);
		}
	}

	// Check if the vertex is special edge vertex, these vertices will be removed later.
	for (int j = 0; j &lt; 4; ++j)
	{
		const int a = j;
		const int b = (j+1) &amp; 0x3;
		const int c = (j+2) &amp; 0x3;
		const int d = (j+3) &amp; 0x3;
		
		// The vertex is a border vertex there are two same exterior cells in a row,
		// followed by two interior cells and none of the regions are out of bounds.
		const bool twoSameExts = (regs[a] &amp; regs[b] &amp; RC_BORDER_REG) != 0 &amp;&amp; regs[a] == regs[b];
		const bool twoInts = ((regs[c] | regs[d]) &amp; RC_BORDER_REG) == 0;
		const bool intsSameArea = (regs[c]&gt;&gt;16) == (regs[d]&gt;&gt;16);
		const bool noZeros = regs[a] != 0 &amp;&amp; regs[b] != 0 &amp;&amp; regs[c] != 0 &amp;&amp; regs[d] != 0;
		if (twoSameExts &amp;&amp; twoInts &amp;&amp; intsSameArea &amp;&amp; noZeros)
		{
			isBorderVertex = true;
			break;
		}
	}
	
	return ch;
}

...
</code></pre><ul>
<li><code>getCornerHeight</code> 的主要步骤为：
<ul>
<li>初始化 y 坐标为当前 <code>span</code> 的 y 坐标。</li>
<li>如果当前方向邻居 <code>span</code> 可通行，则取邻居 <code>span</code> 的 y 坐标和当前 y 坐标中的最大值作为当前 y 坐标。</li>
<li>如果当前方向邻居 <code>span</code> 可通行，且邻居 <code>span</code> 的下一个方向邻居 <code>span</code> 可通行，则同样取其 y 坐标和当前 y 坐标中的最大值作为当前 y 坐标。</li>
<li>如果下一个方向邻居 <code>span</code> 可通行，则取其 y 坐标和当前 y 坐标中的最大值作为当前 y 坐标。</li>
<li>如果下一个方向邻居 <code>span</code> 可通行，且当前方向邻居 <code>span</code> 可通行，则同样取其 y 坐标和当前 y 坐标中的最大值作为当前 y 坐标。</li>
<li>检查完成后，当前 y 坐标即为轮廓点的 y 坐标。</li>
<li>当前 <code>span</code> 、当前方向邻居 <code>span</code> 、当前方向邻居 <code>span</code> 的下一个方向邻居 <code>span</code> 、下一个方向邻居 <code>span</code> ，保持先后顺序，每次以其中一个为起始进行迭代检查。
<ul>
<li>以当前的起始算起，如果前两个的 <code>region</code> 相同且为 <code>borderSize</code> 边界，后两个的 <code>area</code> 相同且不为 <code>borderSize</code> 边界，且四个 <code>span</code> 都可通行，则当前点为 <code>borderSize</code> 边界点。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id=简化轮廓顶点>简化轮廓顶点</h2>
<ul>
<li>简化轮廓顶点的方法 <code>simplifyContour</code> 实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastContour.cpp

...

static void simplifyContour(rcTempVector&lt;int&gt;&amp; points, rcTempVector&lt;int&gt;&amp; simplified,
							const float maxError, const int maxEdgeLen, const int buildFlags)
{
	// Add initial points.
	bool hasConnections = false;
	for (int i = 0; i &lt; points.size(); i += 4)
	{
		if ((points[i+3] &amp; RC_CONTOUR_REG_MASK) != 0)
		{
			hasConnections = true;
			break;
		}
	}
	
	if (hasConnections)
	{
		// The contour has some portals to other regions.
		// Add a new point to every location where the region changes.
		for (int i = 0, ni = static_cast&lt;int&gt;(points.size()) / 4; i &lt; ni; ++i)
		{
			int ii = (i+1) % ni;
			const bool differentRegs = (points[i*4+3] &amp; RC_CONTOUR_REG_MASK) != (points[ii*4+3] &amp; RC_CONTOUR_REG_MASK);
			const bool areaBorders = (points[i*4+3] &amp; RC_AREA_BORDER) != (points[ii*4+3] &amp; RC_AREA_BORDER);
			if (differentRegs || areaBorders)
			{
				simplified.push_back(points[i*4+0]);
				simplified.push_back(points[i*4+1]);
				simplified.push_back(points[i*4+2]);
				simplified.push_back(i);
			}
		}
	}
	
	if (simplified.size() == 0)
	{
		// If there is no connections at all,
		// create some initial points for the simplification process.
		// Find lower-left and upper-right vertices of the contour.
		int llx = points[0];
		int lly = points[1];
		int llz = points[2];
		int lli = 0;
		int urx = points[0];
		int ury = points[1];
		int urz = points[2];
		int uri = 0;
		for (int i = 0; i &lt; points.size(); i += 4)
		{
			int x = points[i+0];
			int y = points[i+1];
			int z = points[i+2];
			if (x &lt; llx || (x == llx &amp;&amp; z &lt; llz))
			{
				llx = x;
				lly = y;
				llz = z;
				lli = i/4;
			}
			if (x &gt; urx || (x == urx &amp;&amp; z &gt; urz))
			{
				urx = x;
				ury = y;
				urz = z;
				uri = i/4;
			}
		}
		simplified.push_back(llx);
		simplified.push_back(lly);
		simplified.push_back(llz);
		simplified.push_back(lli);
		
		simplified.push_back(urx);
		simplified.push_back(ury);
		simplified.push_back(urz);
		simplified.push_back(uri);
	}
	
	// Add points until all raw points are within
	// error tolerance to the simplified shape.
	const int pn = static_cast&lt;int&gt;(points.size()) / 4;
	for (int i = 0; i &lt; simplified.size()/4; )
	{
		int ii = (i+1) % (simplified.size()/4);
		
		int ax = simplified[i*4+0];
		int az = simplified[i*4+2];
		int ai = simplified[i*4+3];

		int bx = simplified[ii*4+0];
		int bz = simplified[ii*4+2];
		int bi = simplified[ii*4+3];

		// Find maximum deviation from the segment.
		float maxd = 0;
		int maxi = -1;
		int ci, cinc, endi;

		// Traverse the segment in lexilogical order so that the
		// max deviation is calculated similarly when traversing
		// opposite segments.
		if (bx &gt; ax || (bx == ax &amp;&amp; bz &gt; az))
		{
			cinc = 1;
			ci = (ai+cinc) % pn;
			endi = bi;
		}
		else
		{
			cinc = pn-1;
			ci = (bi+cinc) % pn;
			endi = ai;
			rcSwap(ax, bx);
			rcSwap(az, bz);
		}
		
		// Tessellate only outer edges or edges between areas.
		if ((points[ci*4+3] &amp; RC_CONTOUR_REG_MASK) == 0 ||
			(points[ci*4+3] &amp; RC_AREA_BORDER))
		{
			while (ci != endi)
			{
				float d = distancePtSeg(points[ci*4+0], points[ci*4+2], ax, az, bx, bz);
				if (d &gt; maxd)
				{
					maxd = d;
					maxi = ci;
				}
				ci = (ci+cinc) % pn;
			}
		}
		
		
		// If the max deviation is larger than accepted error,
		// add new point, else continue to next segment.
		if (maxi != -1 &amp;&amp; maxd &gt; (maxError*maxError))
		{
			// Add space for the new point.
			simplified.resize(simplified.size()+4);
			const int n = static_cast&lt;int&gt;(simplified.size()) / 4;
			for (int j = n-1; j &gt; i; --j)
			{
				simplified[j*4+0] = simplified[(j-1)*4+0];
				simplified[j*4+1] = simplified[(j-1)*4+1];
				simplified[j*4+2] = simplified[(j-1)*4+2];
				simplified[j*4+3] = simplified[(j-1)*4+3];
			}
			// Add the point.
			simplified[(i+1)*4+0] = points[maxi*4+0];
			simplified[(i+1)*4+1] = points[maxi*4+1];
			simplified[(i+1)*4+2] = points[maxi*4+2];
			simplified[(i+1)*4+3] = maxi;
		}
		else
		{
			++i;
		}
	}
	
	// Split too long edges.
	if (maxEdgeLen &gt; 0 &amp;&amp; (buildFlags &amp; (RC_CONTOUR_TESS_WALL_EDGES|RC_CONTOUR_TESS_AREA_EDGES)) != 0)
	{
		for (int i = 0; i &lt; simplified.size()/4; )
		{
			const int ii = (i+1) % (simplified.size()/4);
			
			const int ax = simplified[i*4+0];
			const int az = simplified[i*4+2];
			const int ai = simplified[i*4+3];
			
			const int bx = simplified[ii*4+0];
			const int bz = simplified[ii*4+2];
			const int bi = simplified[ii*4+3];
			
			// Find maximum deviation from the segment.
			int maxi = -1;
			int ci = (ai+1) % pn;
			
			// Tessellate only outer edges or edges between areas.
			bool tess = false;
			// Wall edges.
			if ((buildFlags &amp; RC_CONTOUR_TESS_WALL_EDGES) &amp;&amp; (points[ci*4+3] &amp; RC_CONTOUR_REG_MASK) == 0)
				tess = true;
			// Edges between areas.
			if ((buildFlags &amp; RC_CONTOUR_TESS_AREA_EDGES) &amp;&amp; (points[ci*4+3] &amp; RC_AREA_BORDER))
				tess = true;
			
			if (tess)
			{
				int dx = bx - ax;
				int dz = bz - az;
				if (dx*dx + dz*dz &gt; maxEdgeLen*maxEdgeLen)
				{
					// Round based on the segments in lexilogical order so that the
					// max tesselation is consistent regardless in which direction
					// segments are traversed.
					const int n = bi &lt; ai ? (bi+pn - ai) : (bi - ai);
					if (n &gt; 1)
					{
						if (bx &gt; ax || (bx == ax &amp;&amp; bz &gt; az))
							maxi = (ai + n/2) % pn;
						else
							maxi = (ai + (n+1)/2) % pn;
					}
				}
			}
			
			// If the max deviation is larger than accepted error,
			// add new point, else continue to next segment.
			if (maxi != -1)
			{
				// Add space for the new point.
				simplified.resize(simplified.size()+4);
				const int n = static_cast&lt;int&gt;(simplified.size()) / 4;
				for (int j = n-1; j &gt; i; --j)
				{
					simplified[j*4+0] = simplified[(j-1)*4+0];
					simplified[j*4+1] = simplified[(j-1)*4+1];
					simplified[j*4+2] = simplified[(j-1)*4+2];
					simplified[j*4+3] = simplified[(j-1)*4+3];
				}
				// Add the point.
				simplified[(i+1)*4+0] = points[maxi*4+0];
				simplified[(i+1)*4+1] = points[maxi*4+1];
				simplified[(i+1)*4+2] = points[maxi*4+2];
				simplified[(i+1)*4+3] = maxi;
			}
			else
			{
				++i;
			}
		}
	}
	
	for (int i = 0; i &lt; simplified.size()/4; ++i)
	{
		// The edge vertex flag is take from the current raw point,
		// and the neighbour region is take from the next raw point.
		const int ai = (simplified[i*4+3]+1) % pn;
		const int bi = simplified[i*4+3];
		simplified[i*4+3] = (points[ai*4+3] &amp; (RC_CONTOUR_REG_MASK|RC_AREA_BORDER)) | (points[bi*4+3] &amp; RC_BORDER_VERTEX);
	}
	
}

...
</code></pre><ul>
<li>简化轮廓的过程使用了 <code>simplified</code> 数组记录简化后的轮廓点信息，每个简化点使用 4 个整数表示，依次为 x 、y 、z 和在原始轮廓 <code>points</code> 中的索引信息，简化完成后再将索引信息替换为 <code>region</code> 信息。</li>
<li><code>simplifyContour</code> 的过程如下：
<ul>
<li>如果轮廓中存在可行走的点，则依次遍历每个原轮廓点，如果当前点和下个点的 <code>region</code> 或 <code>area</code> 不同，则将当前点加入到简化轮廓列表 <code>simplified</code> 中。</li>
<li>如果 <code>simplified</code> 为空，即没有找到 <code>region</code> 或 <code>area</code> 不同的点，则将轮廓的左下点和右上点加入到 <code>simplified</code> 中。</li>
<li>遍历 <code>simplified</code> 组成的每一条边，找到所有 <code>region</code> 不为 0 或者是 <code>area</code> 边界的原轮廓点，通过 <code>distancePtSeg</code> 方法计算这些原轮廓点到这条边的距离，从中找到距离最大的原轮廓点，如果该距离大于 <code>maxError</code>，则将该原轮廓点插入到 <code>simplified</code> 中此边的中间，否则跳过此边。</li>
<li>如果设置了 <code>maxEdgeLen</code> 且设置了需要进行细化，则依次遍历 <code>simplified</code> 组成的每一条边.
<ul>
<li>如果边的起点的下一个原始轮廓点的 <code>region</code> 不为 0 且设置了细化墙边（RC_CONTOUR_TESS_WALL_EDGES），或者下一个原始轮廓点为 <code>area</code> 边界且设置了细化区域边（RC_CONTOUR_TESS_AREA_EDGES），则此边需要进行细化处理。</li>
<li>对于需要细化处理的边，如果边的长度大于 <code>maxEdgeLen</code>，且边上除端点外的原始轮廓点数量大于 1，则取中间的原始轮廓点，插入到 <code>simplified</code> 中此边的中间。</li>
</ul>
</li>
<li>遍历 <code>simplified</code> 的每个点，将索引信息替换为 <code>region</code> 信息。</li>
</ul>
</li>
</ul>
<h2 id=查找孔洞>查找孔洞</h2>
<ul>
<li>通过 <code>calcAreaOfPolygon2D</code> 方法，在所有轮廓中识别出孔洞，其实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastContour.cpp
...

static int calcAreaOfPolygon2D(const int* verts, const int nverts)
{
	int area = 0;
	for (int i = 0, j = nverts-1; i &lt; nverts; j=i++)
	{
		const int* vi = &amp;verts[i*4];
		const int* vj = &amp;verts[j*4];
		area += vi[0] * vj[2] - vj[0] * vi[2];
	}
	return (area+1) / 2;
}

...
</code></pre><ul>
<li>查找轮廓的时候是按顺时针方向进行得到的结果，而多边形的顶点是按逆时针方向排序的，所以计算面积时需要使用轮廓的当前顶点和上一个顶点来计算。</li>
<li>遍历每个顶点，根据原点和当前顶点的向量，以及原点到上一个顶点的向量，两者的叉积得到三个点组成的三角形的面积，而所有三角形面积之和即为多边形的面积。其中，叉积为正，表示从向量 1 到向量 2 为逆时针旋转。叉积为负，表示从向量 1 到向量 2 为顺时针旋转。</li>
<li>如果最终多边形的面积为负，则表示该轮廓为逆时针方向，即为孔洞。相反，如果面积为正，则表示该轮廓为外轮廓。</li>
</ul>
<h2 id=合并孔洞>合并孔洞</h2>
<ul>
<li>通过 <code>mergeRegionHoles</code> 方法，将孔洞合并到外轮廓中，其实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastContour.cpp

...

static void mergeRegionHoles(rcContext* ctx, rcContourRegion&amp; region)
{
	// Sort holes from left to right.
	for (int i = 0; i &lt; region.nholes; i++)
		findLeftMostVertex(region.holes[i].contour, &amp;region.holes[i].minx, &amp;region.holes[i].minz, &amp;region.holes[i].leftmost);
	
	qsort(region.holes, region.nholes, sizeof(rcContourHole), compareHoles);
	
	int maxVerts = region.outline-&gt;nverts;
	for (int i = 0; i &lt; region.nholes; i++)
		maxVerts += region.holes[i].contour-&gt;nverts;
	
	rcScopedDelete&lt;rcPotentialDiagonal&gt; diags((rcPotentialDiagonal*)rcAlloc(sizeof(rcPotentialDiagonal)*maxVerts, RC_ALLOC_TEMP));
	if (!diags)
	{
		ctx-&gt;log(RC_LOG_WARNING, &quot;mergeRegionHoles: Failed to allocated diags %d.&quot;, maxVerts);
		return;
	}
	
	rcContour* outline = region.outline;
	
	// Merge holes into the outline one by one.
	for (int i = 0; i &lt; region.nholes; i++)
	{
		rcContour* hole = region.holes[i].contour;
		
		int index = -1;
		int bestVertex = region.holes[i].leftmost;
		for (int iter = 0; iter &lt; hole-&gt;nverts; iter++)
		{
			// Find potential diagonals.
			// The 'best' vertex must be in the cone described by 3 consecutive vertices of the outline.
			// ..o j-1
			//   |
			//   |   * best
			//   |
			// j o-----o j+1
			//         :
			int ndiags = 0;
			const int* corner = &amp;hole-&gt;verts[bestVertex*4];
			for (int j = 0; j &lt; outline-&gt;nverts; j++)
			{
				if (inCone(j, outline-&gt;nverts, outline-&gt;verts, corner))
				{
					int dx = outline-&gt;verts[j*4+0] - corner[0];
					int dz = outline-&gt;verts[j*4+2] - corner[2];
					diags[ndiags].vert = j;
					diags[ndiags].dist = dx*dx + dz*dz;
					ndiags++;
				}
			}
			// Sort potential diagonals by distance, we want to make the connection as short as possible.
			qsort(diags, ndiags, sizeof(rcPotentialDiagonal), compareDiagDist);
			
			// Find a diagonal that is not intersecting the outline not the remaining holes.
			index = -1;
			for (int j = 0; j &lt; ndiags; j++)
			{
				const int* pt = &amp;outline-&gt;verts[diags[j].vert*4];
				bool intersect = intersectSegContour(pt, corner, diags[i].vert, outline-&gt;nverts, outline-&gt;verts);	//这里的 diags[i] 应该是错误的，实际应该是 diags[j]
				for (int k = i; k &lt; region.nholes &amp;&amp; !intersect; k++)
					intersect |= intersectSegContour(pt, corner, -1, region.holes[k].contour-&gt;nverts, region.holes[k].contour-&gt;verts);
				if (!intersect)
				{
					index = diags[j].vert;
					break;
				}
			}
			// If found non-intersecting diagonal, stop looking.
			if (index != -1)
				break;
			// All the potential diagonals for the current vertex were intersecting, try next vertex.
			bestVertex = (bestVertex + 1) % hole-&gt;nverts;
		}
		
		if (index == -1)
		{
			ctx-&gt;log(RC_LOG_WARNING, &quot;mergeHoles: Failed to find merge points for %p and %p.&quot;, region.outline, hole);
			continue;
		}
		if (!mergeContours(*region.outline, *hole, index, bestVertex))
		{
			ctx-&gt;log(RC_LOG_WARNING, &quot;mergeHoles: Failed to merge contours %p and %p.&quot;, region.outline, hole);
			continue;
		}
	}
}

...
</code></pre><ul>
<li><code>mergeRegionHoles</code> 合并的主要步骤如下：
<ul>
<li>遍历当前 <code>region</code> 的每个 <code>hole</code>，设置每个 <code>hole</code> 的左下点坐标及索引，并将 <code>hole</code> 按照左下点坐标进行排序，越靠近左下的排在前面。</li>
<li>遍历当前 <code>region</code> 的每个 <code>hole</code>，对每个 <code>hole</code> 进行处理。
<ul>
<li>从当前 <code>hole</code> 最左下点开始，依次将每个点为拐角点，迭代进行检查。
<ul>
<li>遍历当前 <code>region</code> 外轮廓的每个点，通过 <code>inCone</code> 方法判断拐角点是否在当前外轮廓点及其前后两个点组成的角度区域内，如果在，则计算该点和拐角点的距离，并将该点加入到 <code>diags</code> 数组中。</li>
<li>对 <code>diags</code> 数组按照距离从小到大进行排序。</li>
<li>遍历 <code>diags</code> 数组，通过 <code>intersectSegContour</code> 方法依次检查 <code>diags[j]</code> 和拐角点的线段的包围盒是否和 <code>outline</code> 中不包含 <code>diags[j]</code> 的边的包围盒不相交，并且和剩余的 <code>hole</code> 的任意边的包围盒也不相交，如果都不相交，则 <code>diags[j]</code> 为合并点，结束迭代。</li>
<li>如果没有找到合并点，则将下一个点设置为拐角点，继续迭代。</li>
</ul>
</li>
<li>如果找到了合并点，则通过 <code>mergeContours</code> 方法将 <code>hole</code> 合并到 <code>outline</code> 中，检查相交情况时，则不需要再检查此 <code>hole</code>，因为已经加入到 <code>outline</code> 中，检查和 <code>outline</code> 的相交情况已经同时处理了。（如果没有找到合并点，后续也没有重新检查未被合并的 <code>hole</code> 的相交情况，可能存在问题？）</li>
</ul>
</li>
</ul>
</li>
<li><code>inCone</code> 方法的实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastContour.cpp

...

static bool	inCone(int i, int n, const int* verts, const int* pj)
{
	const int* pi = &amp;verts[i * 4];
	const int* pi1 = &amp;verts[next(i, n) * 4];
	const int* pin1 = &amp;verts[prev(i, n) * 4];
	
	// If P[i] is a convex vertex [ i+1 left or on (i-1,i) ].
	if (leftOn(pin1, pi, pi1))
		return left(pi, pj, pin1) &amp;&amp; left(pj, pi, pi1);
	// Assume (i-1,i,i+1) not collinear.
	// else P[i] is reflex.
	return !(leftOn(pi, pj, pi1) &amp;&amp; leftOn(pj, pi, pin1));
}

...

inline int area2(const int* a, const int* b, const int* c)
{
	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);
}

// Returns true iff c is strictly to the left of the directed
// line through a to b.
inline bool left(const int* a, const int* b, const int* c)
{
	return area2(a, b, c) &lt; 0;
}

inline bool leftOn(const int* a, const int* b, const int* c)
{
	return area2(a, b, c) &lt;= 0;
}
...
</code></pre><ul>
<li><code>inCone</code> 方法通过当前顶点、上一个顶点、下一个顶点组成的角，判断目标点是否在角组成的范围内。<code>left</code> 方法通过向量 AB 和向量 AC 的叉积，来判断点所在的位置。通常情况下，如果向量叉积为正，则点 C 在向量 AB 的逆时针方向，即左侧，如果为负，则点 C 在向量 AB 的顺时针方向，即右侧。而这里的 <code>left</code> 方法判断相反，但前面提到，轮廓顶点是按顺时针方向得到的，多边形顶点则是按逆时针方向排序的，而这里使用的是轮廓的顶点顺序，因此 <code>left</code> 代表的是多边形排序的左侧，所以结果上也是正确的。</li>
<li><code>intersectSegContour</code> 方法的实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastContour.cpp

...

inline bool collinear(const int* a, const int* b, const int* c)
{
	return area2(a, b, c) == 0;
}

static bool intersectProp(const int* a, const int* b, const int* c, const int* d)
{
	// Eliminate improper cases.
	if (collinear(a,b,c) || collinear(a,b,d) ||
		collinear(c,d,a) || collinear(c,d,b))
		return false;
	
	return (left(a,b,c) ^ left(a,b,d)) &amp;&amp; (left(c,d,a) ^ left(c,d,b));
}

// Returns T iff (a,b,c) are collinear and point c lies
// on the closed segment ab.
static bool between(const int* a, const int* b, const int* c)
{
	if (!collinear(a, b, c))
		return false;
	// If ab not vertical, check betweenness on x; else on y.
	if (a[0] != b[0])
		return	((a[0] &lt;= c[0]) &amp;&amp; (c[0] &lt;= b[0])) || ((a[0] &gt;= c[0]) &amp;&amp; (c[0] &gt;= b[0]));
	else
		return	((a[2] &lt;= c[2]) &amp;&amp; (c[2] &lt;= b[2])) || ((a[2] &gt;= c[2]) &amp;&amp; (c[2] &gt;= b[2]));
}

// Returns true iff segments ab and cd intersect, properly or improperly.
static bool intersect(const int* a, const int* b, const int* c, const int* d)
{
	if (intersectProp(a, b, c, d))
		return true;
	else if (between(a, b, c) || between(a, b, d) ||
			 between(c, d, a) || between(c, d, b))
		return true;
	else
		return false;
}

static bool vequal(const int* a, const int* b)
{
	return a[0] == b[0] &amp;&amp; a[2] == b[2];
}

static bool intersectSegContour(const int* d0, const int* d1, int i, int n, const int* verts)
{
	// For each edge (k,k+1) of P
	for (int k = 0; k &lt; n; k++)
	{
		int k1 = next(k, n);
		// Skip edges incident to i.
		if (i == k || i == k1)
			continue;
		const int* p0 = &amp;verts[k * 4];
		const int* p1 = &amp;verts[k1 * 4];
		if (vequal(d0, p0) || vequal(d1, p0) || vequal(d0, p1) || vequal(d1, p1))
			continue;
		
		if (intersect(d0, d1, p0, p1))
			return true;
	}
	return false;
}
</code></pre><ul>
<li><code>intersectSegContour</code> 方法通过传入的两个点组成的线段，遍历顶点数组中的每条边，跳过和输入点及指定索引相同的顶点所在的边，通过 <code>intersect</code> 方法判断在 xz 平面上线段的包围盒和边的包围盒是否相交。同样，也是通过向量叉积的方式进行计算，当两条线段中各自的顶点，都处在另一线段的两侧，说明两条线段直接相交。当两条线段中的任一顶点，处在另一条线段的包围盒中，则两条线段的包围盒相交。</li>
<li><code>mergeContours</code> 方法的实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastContour.cpp

static bool mergeContours(rcContour&amp; ca, rcContour&amp; cb, int ia, int ib)
{
	const int maxVerts = ca.nverts + cb.nverts + 2;
	int* verts = (int*)rcAlloc(sizeof(int)*maxVerts*4, RC_ALLOC_PERM);
	if (!verts)
		return false;
	
	int nv = 0;
	
	// Copy contour A.
	for (int i = 0; i &lt;= ca.nverts; ++i)
	{
		int* dst = &amp;verts[nv*4];
		const int* src = &amp;ca.verts[((ia+i)%ca.nverts)*4];
		dst[0] = src[0];
		dst[1] = src[1];
		dst[2] = src[2];
		dst[3] = src[3];
		nv++;
	}

	// Copy contour B
	for (int i = 0; i &lt;= cb.nverts; ++i)
	{
		int* dst = &amp;verts[nv*4];
		const int* src = &amp;cb.verts[((ib+i)%cb.nverts)*4];
		dst[0] = src[0];
		dst[1] = src[1];
		dst[2] = src[2];
		dst[3] = src[3];
		nv++;
	}
	
	rcFree(ca.verts);
	ca.verts = verts;
	ca.nverts = nv;
	
	rcFree(cb.verts);
	cb.verts = 0;
	cb.nverts = 0;
	
	return true;
}

...
</code></pre><ul>
<li><code>mergeContours</code> 方法，从 <code>outline</code> 找到的合并点起，将 <code>outline</code> 的所有点加入的到新的轮廓中，再把合并点加入，接着从 <code>hole</code> 的拐角点起，将 <code>hole</code> 的所有点加入，再把拐角点加入，得到合并后的轮廓。每个轮廓都将起始点重复加入，确保闭合。
<img src="/img/Algorithm/NavmeshNavigation/Nav2_4.gif?raw=true" alt=Nav2_4.png>
</li>
</ul>
<h1 id=六建立多边形网格>六、建立多边形网格</h1>
<ul>
<li>建立多边形网格过程，使用 <code>rcPolyMesh</code> 结构保存多边形网格数据，其定义如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Include/Recast.h

...

struct rcPolyMesh
{
	...

	unsigned short* verts;	/// 顶点坐标，每个顶点占 3 位
	unsigned short* polys;	/// 多边形顶点索引，以及其每条边的邻居多边形索引，尺寸为 npolys * nvp * 2，[0 , npolys * nvp - 1] 为顶点索引，[npolys * nvp , npolys * nvp * 2 - 1] 为邻居多边形索引
	unsigned short* regs;	/// 每个多边形的地区
	unsigned short* flags;	/// 每个多边形的标记
	unsigned char* areas;	/// 每个多边形的区域
	int nverts;				/// 顶点数量
	int npolys;				/// 多边形数量
	int maxpolys;			/// 已申请的最大多边形数量
	int nvp;				/// 每个多边形的最大顶点数量
	float bmin[3];			/// 同 rcContourSet
	float bmax[3];			/// 同 rcContourSet
	float cs;				/// 同 rcContourSet
	float ch;				/// 同 rcContourSet
	int borderSize;			/// 同 rcConfig::borderSize
	float maxEdgeError;		/// 同 rcContourSet::maxError
	
	...
};

</code></pre><ul>
<li>建立过程通过 <code>rcBuildPolyMesh</code> 方法实现，其代码如下：</li>
</ul>
<pre tabindex=0><code>
bool rcBuildPolyMesh(rcContext* ctx, const rcContourSet&amp; cset, const int nvp, rcPolyMesh&amp; mesh)
{
	rcAssert(ctx);
	
	rcScopedTimer timer(ctx, RC_TIMER_BUILD_POLYMESH);

	rcVcopy(mesh.bmin, cset.bmin);
	rcVcopy(mesh.bmax, cset.bmax);
	mesh.cs = cset.cs;
	mesh.ch = cset.ch;
	mesh.borderSize = cset.borderSize;
	mesh.maxEdgeError = cset.maxError;
	
	int maxVertices = 0;
	int maxTris = 0;
	int maxVertsPerCont = 0;
	for (int i = 0; i &lt; cset.nconts; ++i)
	{
		// Skip null contours.
		if (cset.conts[i].nverts &lt; 3) continue;
		maxVertices += cset.conts[i].nverts;
		maxTris += cset.conts[i].nverts - 2;
		maxVertsPerCont = rcMax(maxVertsPerCont, cset.conts[i].nverts);
	}
	
	if (maxVertices &gt;= 0xfffe)
	{
		ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildPolyMesh: Too many vertices %d.&quot;, maxVertices);
		return false;
	}
		
	rcScopedDelete&lt;unsigned char&gt; vflags((unsigned char*)rcAlloc(sizeof(unsigned char)*maxVertices, RC_ALLOC_TEMP));
	if (!vflags)
	{
		ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildPolyMesh: Out of memory 'vflags' (%d).&quot;, maxVertices);
		return false;
	}
	memset(vflags, 0, maxVertices);
	
	mesh.verts = (unsigned short*)rcAlloc(sizeof(unsigned short)*maxVertices*3, RC_ALLOC_PERM);
	if (!mesh.verts)
	{
		ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildPolyMesh: Out of memory 'mesh.verts' (%d).&quot;, maxVertices);
		return false;
	}
	mesh.polys = (unsigned short*)rcAlloc(sizeof(unsigned short)*maxTris*nvp*2, RC_ALLOC_PERM);
	if (!mesh.polys)
	{
		ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildPolyMesh: Out of memory 'mesh.polys' (%d).&quot;, maxTris*nvp*2);
		return false;
	}
	mesh.regs = (unsigned short*)rcAlloc(sizeof(unsigned short)*maxTris, RC_ALLOC_PERM);
	if (!mesh.regs)
	{
		ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildPolyMesh: Out of memory 'mesh.regs' (%d).&quot;, maxTris);
		return false;
	}
	mesh.areas = (unsigned char*)rcAlloc(sizeof(unsigned char)*maxTris, RC_ALLOC_PERM);
	if (!mesh.areas)
	{
		ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildPolyMesh: Out of memory 'mesh.areas' (%d).&quot;, maxTris);
		return false;
	}
	
	mesh.nverts = 0;
	mesh.npolys = 0;
	mesh.nvp = nvp;
	mesh.maxpolys = maxTris;
	
	memset(mesh.verts, 0, sizeof(unsigned short)*maxVertices*3);
	memset(mesh.polys, 0xff, sizeof(unsigned short)*maxTris*nvp*2);
	memset(mesh.regs, 0, sizeof(unsigned short)*maxTris);
	memset(mesh.areas, 0, sizeof(unsigned char)*maxTris);
	
	rcScopedDelete&lt;int&gt; nextVert((int*)rcAlloc(sizeof(int)*maxVertices, RC_ALLOC_TEMP));
	if (!nextVert)
	{
		ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildPolyMesh: Out of memory 'nextVert' (%d).&quot;, maxVertices);
		return false;
	}
	memset(nextVert, 0, sizeof(int)*maxVertices);
	
	rcScopedDelete&lt;int&gt; firstVert((int*)rcAlloc(sizeof(int)*VERTEX_BUCKET_COUNT, RC_ALLOC_TEMP));
	if (!firstVert)
	{
		ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildPolyMesh: Out of memory 'firstVert' (%d).&quot;, VERTEX_BUCKET_COUNT);
		return false;
	}
	for (int i = 0; i &lt; VERTEX_BUCKET_COUNT; ++i)
		firstVert[i] = -1;
	
	rcScopedDelete&lt;int&gt; indices((int*)rcAlloc(sizeof(int)*maxVertsPerCont, RC_ALLOC_TEMP));
	if (!indices)
	{
		ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildPolyMesh: Out of memory 'indices' (%d).&quot;, maxVertsPerCont);
		return false;
	}
	rcScopedDelete&lt;int&gt; tris((int*)rcAlloc(sizeof(int)*maxVertsPerCont*3, RC_ALLOC_TEMP));
	if (!tris)
	{
		ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildPolyMesh: Out of memory 'tris' (%d).&quot;, maxVertsPerCont*3);
		return false;
	}
	rcScopedDelete&lt;unsigned short&gt; polys((unsigned short*)rcAlloc(sizeof(unsigned short)*(maxVertsPerCont+1)*nvp, RC_ALLOC_TEMP));
	if (!polys)
	{
		ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildPolyMesh: Out of memory 'polys' (%d).&quot;, maxVertsPerCont*nvp);
		return false;
	}
	unsigned short* tmpPoly = &amp;polys[maxVertsPerCont*nvp];

	for (int i = 0; i &lt; cset.nconts; ++i)
	{
		rcContour&amp; cont = cset.conts[i];
		
		// Skip null contours.
		if (cont.nverts &lt; 3)
			continue;
		
		// Triangulate contour
		for (int j = 0; j &lt; cont.nverts; ++j)
			indices[j] = j;
			
		int ntris = triangulate(cont.nverts, cont.verts, &amp;indices[0], &amp;tris[0]);
		if (ntris &lt;= 0)
		{
			// Bad triangulation, should not happen.
/*			printf(&quot;\tconst float bmin[3] = {%ff,%ff,%ff};\n&quot;, cset.bmin[0], cset.bmin[1], cset.bmin[2]);
			printf(&quot;\tconst float cs = %ff;\n&quot;, cset.cs);
			printf(&quot;\tconst float ch = %ff;\n&quot;, cset.ch);
			printf(&quot;\tconst int verts[] = {\n&quot;);
			for (int k = 0; k &lt; cont.nverts; ++k)
			{
				const int* v = &amp;cont.verts[k*4];
				printf(&quot;\t\t%d,%d,%d,%d,\n&quot;, v[0], v[1], v[2], v[3]);
			}
			printf(&quot;\t};\n\tconst int nverts = sizeof(verts)/(sizeof(int)*4);\n&quot;);*/
			ctx-&gt;log(RC_LOG_WARNING, &quot;rcBuildPolyMesh: Bad triangulation Contour %d.&quot;, i);
			ntris = -ntris;
		}
				
		// Add and merge vertices.
		for (int j = 0; j &lt; cont.nverts; ++j)
		{
			const int* v = &amp;cont.verts[j*4];
			indices[j] = addVertex((unsigned short)v[0], (unsigned short)v[1], (unsigned short)v[2],
								   mesh.verts, firstVert, nextVert, mesh.nverts);
			if (v[3] &amp; RC_BORDER_VERTEX)
			{
				// This vertex should be removed.
				vflags[indices[j]] = 1;
			}
		}

		// Build initial polygons.
		int npolys = 0;
		memset(polys, 0xff, maxVertsPerCont*nvp*sizeof(unsigned short));
		for (int j = 0; j &lt; ntris; ++j)
		{
			int* t = &amp;tris[j*3];
			if (t[0] != t[1] &amp;&amp; t[0] != t[2] &amp;&amp; t[1] != t[2])
			{
				polys[npolys*nvp+0] = (unsigned short)indices[t[0]];
				polys[npolys*nvp+1] = (unsigned short)indices[t[1]];
				polys[npolys*nvp+2] = (unsigned short)indices[t[2]];
				npolys++;
			}
		}
		if (!npolys)
			continue;
		
		// Merge polygons.
		if (nvp &gt; 3)
		{
			for(;;)
			{
				// Find best polygons to merge.
				int bestMergeVal = 0;
				int bestPa = 0, bestPb = 0, bestEa = 0, bestEb = 0;
				
				for (int j = 0; j &lt; npolys-1; ++j)
				{
					unsigned short* pj = &amp;polys[j*nvp];
					for (int k = j+1; k &lt; npolys; ++k)
					{
						unsigned short* pk = &amp;polys[k*nvp];
						int ea, eb;
						int v = getPolyMergeValue(pj, pk, mesh.verts, ea, eb, nvp);
						if (v &gt; bestMergeVal)
						{
							bestMergeVal = v;
							bestPa = j;
							bestPb = k;
							bestEa = ea;
							bestEb = eb;
						}
					}
				}
				
				if (bestMergeVal &gt; 0)
				{
					// Found best, merge.
					unsigned short* pa = &amp;polys[bestPa*nvp];
					unsigned short* pb = &amp;polys[bestPb*nvp];
					mergePolyVerts(pa, pb, bestEa, bestEb, tmpPoly, nvp);
					unsigned short* lastPoly = &amp;polys[(npolys-1)*nvp];
					if (pb != lastPoly)
						memcpy(pb, lastPoly, sizeof(unsigned short)*nvp);
					npolys--;
				}
				else
				{
					// Could not merge any polygons, stop.
					break;
				}
			}
		}
		
		// Store polygons.
		for (int j = 0; j &lt; npolys; ++j)
		{
			unsigned short* p = &amp;mesh.polys[mesh.npolys*nvp*2];
			unsigned short* q = &amp;polys[j*nvp];
			for (int k = 0; k &lt; nvp; ++k)
				p[k] = q[k];
			mesh.regs[mesh.npolys] = cont.reg;
			mesh.areas[mesh.npolys] = cont.area;
			mesh.npolys++;
			if (mesh.npolys &gt; maxTris)
			{
				ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildPolyMesh: Too many polygons %d (max:%d).&quot;, mesh.npolys, maxTris);
				return false;
			}
		}
	}
	
	
	// Remove edge vertices.
	for (int i = 0; i &lt; mesh.nverts; ++i)
	{
		if (vflags[i])
		{
			if (!canRemoveVertex(ctx, mesh, (unsigned short)i))
				continue;
			if (!removeVertex(ctx, mesh, (unsigned short)i, maxTris))
			{
				// Failed to remove vertex
				ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildPolyMesh: Failed to remove edge vertex %d.&quot;, i);
				return false;
			}
			// Remove vertex
			// Note: mesh.nverts is already decremented inside removeVertex()!
			// Fixup vertex flags
			for (int j = i; j &lt; mesh.nverts; ++j)
				vflags[j] = vflags[j+1];
			--i;
		}
	}
	
	// Calculate adjacency.
	if (!buildMeshAdjacency(mesh.polys, mesh.npolys, mesh.nverts, nvp))
	{
		ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildPolyMesh: Adjacency failed.&quot;);
		return false;
	}
	
	// Find portal edges
	if (mesh.borderSize &gt; 0)
	{
		const int w = cset.width;
		const int h = cset.height;
		for (int i = 0; i &lt; mesh.npolys; ++i)
		{
			unsigned short* p = &amp;mesh.polys[i*2*nvp];
			for (int j = 0; j &lt; nvp; ++j)
			{
				if (p[j] == RC_MESH_NULL_IDX) break;
				// Skip connected edges.
				if (p[nvp+j] != RC_MESH_NULL_IDX)
					continue;
				int nj = j+1;
				if (nj &gt;= nvp || p[nj] == RC_MESH_NULL_IDX) nj = 0;
				const unsigned short* va = &amp;mesh.verts[p[j]*3];
				const unsigned short* vb = &amp;mesh.verts[p[nj]*3];

				if ((int)va[0] == 0 &amp;&amp; (int)vb[0] == 0)
					p[nvp+j] = 0x8000 | 0;
				else if ((int)va[2] == h &amp;&amp; (int)vb[2] == h)
					p[nvp+j] = 0x8000 | 1;
				else if ((int)va[0] == w &amp;&amp; (int)vb[0] == w)
					p[nvp+j] = 0x8000 | 2;
				else if ((int)va[2] == 0 &amp;&amp; (int)vb[2] == 0)
					p[nvp+j] = 0x8000 | 3;
			}
		}
	}

	// Just allocate the mesh flags array. The user is resposible to fill it.
	mesh.flags = (unsigned short*)rcAlloc(sizeof(unsigned short)*mesh.npolys, RC_ALLOC_PERM);
	if (!mesh.flags)
	{
		ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildPolyMesh: Out of memory 'mesh.flags' (%d).&quot;, mesh.npolys);
		return false;
	}
	memset(mesh.flags, 0, sizeof(unsigned short) * mesh.npolys);
	
	if (mesh.nverts &gt; 0xffff)
	{
		ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildPolyMesh: The resulting mesh has too many vertices %d (max %d). Data can be corrupted.&quot;, mesh.nverts, 0xffff);
	}
	if (mesh.npolys &gt; 0xffff)
	{
		ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildPolyMesh: The resulting mesh has too many polygons %d (max %d). Data can be corrupted.&quot;, mesh.npolys, 0xffff);
	}
	
	return true;
}

...
</code></pre><ul>
<li><code>rcBuildPolyMesh</code> 的主要步骤如下：
<ul>
<li>初始化 <code>rcPolyMesh</code> 结构 <code>mesh</code> 对象，用于存储网格信息。</li>
<li>遍历 <code>cset</code> 中的轮廓处理。
<ul>
<li>初始化顶点索引 <code>indices</code>，通过 <code>triangulate</code> 方法将轮廓划分成三角形，存储到 <code>tris</code> 中。</li>
<li>遍历轮廓的每个顶点，通过 <code>addVertex</code> 方法去除重复顶点（x、z 坐标相同，y 坐标差值在 2 以内），重新生成顶点索引，更新到 <code>indices</code> 中，并将顶点坐标记录到 <code>mesh.verts</code> 中。同时，对处在 <code>borderSize</code> 范围内的顶点标记到 <code>vflags</code> 中。</li>
<li>将 <code>indices</code> 每个三角形的顶点索引存储到临时数组 <code>polys</code> 中。</li>
<li>如果每个多边形的最大顶点数 <code>nvp</code> 大于 3，则进行多边形合并。
<ul>
<li>遍历 <code>polys</code> 中每两个多边形，通过 <code>getPolyMergeValue</code> 方法找到所有具有公共边的多边形组合，取其中公共边最长的多边形组合，通过 <code>mergePolyVerts</code>方法，按照顶点顺序，从各自的公共边终点起，依次加入到新的多边形顶点数组中。</li>
<li>直到没有多边形能进行合并时，结束合并。</li>
</ul>
</li>
<li>将多边形数据 <code>polys</code> 存储到 <code>mesh.polys</code> 中，且记录每个多边形所属的 <code>region</code> 和 <code>area</code>。</li>
</ul>
</li>
<li>遍历 <code>mesh.verts</code> 中的每个顶点，如果该顶点标记在 <code>vflags</code> 中，则通过 <code>canRemoveVertex</code> 方法检查该顶点能否移除，如果能移除则通过 <code>removeVertex</code> 方法移除。</li>
<li>通过 <code>buildMeshAdjacency</code> 方法，计算并记录多边形的邻居信息。</li>
<li>如果 <code>borderSize</code> 大于 0，则检查所有多边形的非共享边，根据边的 x 、z 坐标，将边界信息记录到 <code>mesh.polys[nvp + j]</code> 中（j 为边的起始点索引）。
<ul>
<li>如果边的 x 坐标都为 0 ，即为左边界，则 <code>mesh.polys[nvp + j] = 0x8001</code>。</li>
<li>如果边的 z 坐标都为 <code>cset.height</code> ，即为上边界，则 <code>mesh.polys[nvp + j] = 0x8002</code>。</li>
<li>如果边的 x 坐标都为 <code>cset.width</code> ，即为右边界，则 <code>mesh.polys[nvp + j] = 0x8003</code>。</li>
<li>如果边的 z 坐标都为 0 ，即为下边界，则 <code>mesh.polys[nvp + j] = 0x8004</code>。</li>
</ul>
</li>
<li>初始化 <code>mesh.flags</code> 数组，大小为 <code>mesh.npolys</code>，用于后续标记使用。</li>
</ul>
</li>
</ul>
<h2 id=将轮廓点划分成三角形>将轮廓点划分成三角形</h2>
<ul>
<li><code>triangulate</code> 方法的实现如下：</li>
</ul>
<pre tabindex=0><code>// Recase/Source/RecastMesh.cpp

...

static int triangulate(int n, const int* verts, int* indices, int* tris)
{
	int ntris = 0;
	int* dst = tris;
	
	// The last bit of the index is used to indicate if the vertex can be removed.
	for (int i = 0; i &lt; n; i++)
	{
		int i1 = next(i, n);
		int i2 = next(i1, n);
		if (diagonal(i, i2, n, verts, indices))
			indices[i1] |= 0x80000000;
	}
	
	while (n &gt; 3)
	{
		int minLen = -1;
		int mini = -1;
		for (int i = 0; i &lt; n; i++)
		{
			int i1 = next(i, n);
			if (indices[i1] &amp; 0x80000000)
			{
				const int* p0 = &amp;verts[(indices[i] &amp; 0x0fffffff) * 4];
				const int* p2 = &amp;verts[(indices[next(i1, n)] &amp; 0x0fffffff) * 4];
				
				int dx = p2[0] - p0[0];
				int dy = p2[2] - p0[2];
				int len = dx*dx + dy*dy;
				
				if (minLen &lt; 0 || len &lt; minLen)
				{
					minLen = len;
					mini = i;
				}
			}
		}
		
		if (mini == -1)
		{
			// We might get here because the contour has overlapping segments, like this:
			//
			//  A o-o=====o---o B
			//   /  |C   D|    \.
			//  o   o     o     o
			//  :   :     :     :
			// We'll try to recover by loosing up the inCone test a bit so that a diagonal
			// like A-B or C-D can be found and we can continue.
			minLen = -1;
			mini = -1;
			for (int i = 0; i &lt; n; i++)
			{
				int i1 = next(i, n);
				int i2 = next(i1, n);
				if (diagonalLoose(i, i2, n, verts, indices))
				{
					const int* p0 = &amp;verts[(indices[i] &amp; 0x0fffffff) * 4];
					const int* p2 = &amp;verts[(indices[next(i2, n)] &amp; 0x0fffffff) * 4];
					int dx = p2[0] - p0[0];
					int dy = p2[2] - p0[2];
					int len = dx*dx + dy*dy;
					
					if (minLen &lt; 0 || len &lt; minLen)
					{
						minLen = len;
						mini = i;
					}
				}
			}
			if (mini == -1)
			{
				// The contour is messed up. This sometimes happens
				// if the contour simplification is too aggressive.
				return -ntris;
			}
		}
		
		int i = mini;
		int i1 = next(i, n);
		int i2 = next(i1, n);
		
		*dst++ = indices[i] &amp; 0x0fffffff;
		*dst++ = indices[i1] &amp; 0x0fffffff;
		*dst++ = indices[i2] &amp; 0x0fffffff;
		ntris++;
		
		// Removes P[i1] by copying P[i+1]...P[n-1] left one index.
		n--;
		for (int k = i1; k &lt; n; k++)
			indices[k] = indices[k+1];
		
		if (i1 &gt;= n) i1 = 0;
		i = prev(i1,n);
		// Update diagonal flags.
		if (diagonal(prev(i, n), i1, n, verts, indices))
			indices[i] |= 0x80000000;
		else
			indices[i] &amp;= 0x0fffffff;
		
		if (diagonal(i, next(i1, n), n, verts, indices))
			indices[i1] |= 0x80000000;
		else
			indices[i1] &amp;= 0x0fffffff;
	}
	
	// Append the remaining triangle.
	*dst++ = indices[0] &amp; 0x0fffffff;
	*dst++ = indices[1] &amp; 0x0fffffff;
	*dst++ = indices[2] &amp; 0x0fffffff;
	ntris++;
	
	return ntris;
}

...
</code></pre><ul>
<li>将轮廓点划分成三角形的步骤如下：
<ul>
<li>遍历每个顶点 <code>i</code>，通过 <code>diagonal</code> 方法，检查顶点 <code>i</code> 和 <code>i + 2</code> 组成的线段的包围盒是否和轮廓不包含这两个点的边的包围盒相交，如果不相交，表示该线段可以划分三角形，标记 <code>indices[i + 1]</code> 的最高位为 1。
<ul>
<li><code>diagonal</code> 方法最终也是通过 <code>inCone</code> 和 <code>intersect</code> 方法实现。</li>
</ul>
</li>
<li>当轮廓顶点数量超过 3 时，即可以划分成多个三角形，则进行迭代检查处理。
<ul>
<li>遍历每个顶点 <code>i</code>，如果 <code>indices[i + 1]</code> 已经标记，则计算 <code>i</code> 和 <code>i + 2</code> 组成的线段长度，记录所有长度中的最小值及对应的顶点索引。</li>
<li>如果顶点都没有标记，则通过 <code>diagonalLoose</code> 方法，再次遍历每个顶点 <code>i</code> 检查相交情况。如果不相交，同样计算 <code>i</code> 和 <code>i + 2</code> 组成的线段长度，记录所有长度中的最小值及对应的顶点索引。如果还是没有找到不相交的对角线，则当前轮廓无法再划分三角形，返回 <code>-ntris</code>。
<ul>
<li><code>diagonalLoose</code> 方法是通过 <code>inConeLoose</code> 和 <code>intersectProp</code> 方法实现，降低了对划分三角形的对角线要求，即。其中，<code>inConeLoose</code> 检查点是否在角度范围内时，增加了三个点共线的情况，<code>intersectProp</code> 方法只检查线段直接相交的情况。</li>
</ul>
</li>
<li>将长度最小值对应的顶点索引 <code>i</code> 及其后续两个顶点 <code>i + 1</code> 和 <code>i + 2</code>，依次加入到 <code>tris</code> 中，作为一个划分的三角形，并从轮廓点中移除 <code>i + 1</code> 顶点。</li>
<li>对顶点 <code>i - 1</code> 和 <code>i</code>，通过 <code>diagonal</code> 方法，重新检查相交情况进行标记。</li>
<li>继续进行迭代划分，直到不能再划分为止。
<img src="/img/Algorithm/NavmeshNavigation/Nav_5.gif?raw=true" alt=Nav_5.png>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id=查找多边形公共边>查找多边形公共边</h2>
<ul>
<li><code>getPolyMergeValue</code> 的实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastMesh.cpp

...

static int getPolyMergeValue(unsigned short* pa, unsigned short* pb,
							 const unsigned short* verts, int&amp; ea, int&amp; eb,
							 const int nvp)
{
	const int na = countPolyVerts(pa, nvp);
	const int nb = countPolyVerts(pb, nvp);
	
	// If the merged polygon would be too big, do not merge.
	if (na+nb-2 &gt; nvp)
		return -1;
	
	// Check if the polygons share an edge.
	ea = -1;
	eb = -1;
	
	for (int i = 0; i &lt; na; ++i)
	{
		unsigned short va0 = pa[i];
		unsigned short va1 = pa[(i+1) % na];
		if (va0 &gt; va1)
			rcSwap(va0, va1);
		for (int j = 0; j &lt; nb; ++j)
		{
			unsigned short vb0 = pb[j];
			unsigned short vb1 = pb[(j+1) % nb];
			if (vb0 &gt; vb1)
				rcSwap(vb0, vb1);
			if (va0 == vb0 &amp;&amp; va1 == vb1)
			{
				ea = i;
				eb = j;
				break;
			}
		}
	}
	
	// No common edge, cannot merge.
	if (ea == -1 || eb == -1)
		return -1;
	
	// Check to see if the merged polygon would be convex.
	unsigned short va, vb, vc;
	
	va = pa[(ea+na-1) % na];
	vb = pa[ea];
	vc = pb[(eb+2) % nb];
	if (!uleft(&amp;verts[va*3], &amp;verts[vb*3], &amp;verts[vc*3]))
		return -1;
	
	va = pb[(eb+nb-1) % nb];
	vb = pb[eb];
	vc = pa[(ea+2) % na];
	if (!uleft(&amp;verts[va*3], &amp;verts[vb*3], &amp;verts[vc*3]))
		return -1;
	
	va = pa[ea];
	vb = pa[(ea+1)%na];
	
	int dx = (int)verts[va*3+0] - (int)verts[vb*3+0];
	int dy = (int)verts[va*3+2] - (int)verts[vb*3+2];
	
	return dx*dx + dy*dy;
}

...
</code></pre><ul>
<li><code>getPolyMergeValue</code> 查找公共边的步骤如下：
<ul>
<li>检查两个多边形合并后的顶点数量，如果超过 <code>nvp</code> 则不能合并。</li>
<li>遍历第一个多边形的每条边，从第二个多边形中查找是否有相同的边，找到则记录边对应的顶点索引。</li>
<li>检查公共边合并后新的两个角是否为凸角，如果是则计算公共边距离平方返回，表示该公共边可以合并。检查方式为：
<ul>
<li>检查第二个多边形中公共边的下一个顶点，是否在第一个多边形公共边的上一个顶点及第一个顶点组成的向量右侧。</li>
<li>检查第一个多边形中公共边的下一个顶点，是否在第二个多边形公共边的上一个顶点及第一个顶点组成的向量右侧。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id=移除边界顶点>移除边界顶点</h2>
<ul>
<li>合并完成后，对于处在 <code>borderSize</code> 范围内的顶点，通过 <code>canRemoveVertex</code> 检查是否能移除，其实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastMesh.cpp

...

static bool canRemoveVertex(rcContext* ctx, rcPolyMesh&amp; mesh, const unsigned short rem)
{
	const int nvp = mesh.nvp;
	
	// Count number of polygons to remove.
	int numTouchedVerts = 0;
	int numRemainingEdges = 0;
	for (int i = 0; i &lt; mesh.npolys; ++i)
	{
		unsigned short* p = &amp;mesh.polys[i*nvp*2];
		const int nv = countPolyVerts(p, nvp);
		int numRemoved = 0;
		int numVerts = 0;
		for (int j = 0; j &lt; nv; ++j)
		{
			if (p[j] == rem)
			{
				numTouchedVerts++;
				numRemoved++;
			}
			numVerts++;
		}
		if (numRemoved)
		{
			numRemainingEdges += numVerts-(numRemoved+1);
		}
	}
	
	// There would be too few edges remaining to create a polygon.
	// This can happen for example when a tip of a triangle is marked
	// as deletion, but there are no other polys that share the vertex.
	// In this case, the vertex should not be removed.
	if (numRemainingEdges &lt;= 2)
		return false;
	
	// Find edges which share the removed vertex.
	const int maxEdges = numTouchedVerts*2;
	int nedges = 0;
	rcScopedDelete&lt;int&gt; edges((int*)rcAlloc(sizeof(int)*maxEdges*3, RC_ALLOC_TEMP));
	if (!edges)
	{
		ctx-&gt;log(RC_LOG_WARNING, &quot;canRemoveVertex: Out of memory 'edges' (%d).&quot;, maxEdges*3);
		return false;
	}
		
	for (int i = 0; i &lt; mesh.npolys; ++i)
	{
		unsigned short* p = &amp;mesh.polys[i*nvp*2];
		const int nv = countPolyVerts(p, nvp);

		// Collect edges which touches the removed vertex.
		for (int j = 0, k = nv-1; j &lt; nv; k = j++)
		{
			if (p[j] == rem || p[k] == rem)
			{
				// Arrange edge so that a=rem.
				int a = p[j], b = p[k];
				if (b == rem)
					rcSwap(a,b);
					
				// Check if the edge exists
				bool exists = false;
				for (int m = 0; m &lt; nedges; ++m)
				{
					int* e = &amp;edges[m*3];
					if (e[1] == b)
					{
						// Exists, increment vertex share count.
						e[2]++;
						exists = true;
					}
				}
				// Add new edge.
				if (!exists)
				{
					int* e = &amp;edges[nedges*3];
					e[0] = a;
					e[1] = b;
					e[2] = 1;
					nedges++;
				}
			}
		}
	}

	// There should be no more than 2 open edges.
	// This catches the case that two non-adjacent polygons
	// share the removed vertex. In that case, do not remove the vertex.
	int numOpenEdges = 0;
	for (int i = 0; i &lt; nedges; ++i)
	{
		if (edges[i*3+2] &lt; 2)
			numOpenEdges++;
	}
	if (numOpenEdges &gt; 2)
		return false;
	
	return true;
}

...
</code></pre><ul>
<li><code>canRemoveVertex</code> 的检查过程如下：
<ul>
<li>遍历 <code>mesh</code> 中的所有多边形，统计顶点总数和包含待移除的顶点数量，计算移除顶点后的剩余边数，确保不能小于 2。</li>
<li>遍历 <code>mesh</code> 的每个多边形，记录包含待移除顶点的边的出现次数，如果出现次数大于 2，则该边为公共边，否则为开放边。</li>
<li>检查包含待移除顶点的所有边，如果出现超过 2 条开放边，则表示该顶点移除会出现多个开口，会破坏多边形结构，因此不能移除。</li>
</ul>
</li>
<li>移除顶点的方法 <code>removeVertex</code> 的实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastMesh.cpp

...

static bool removeVertex(rcContext* ctx, rcPolyMesh&amp; mesh, const unsigned short rem, const int maxTris)
{
	const int nvp = mesh.nvp;

	// Count number of polygons to remove.
	int numRemovedVerts = 0;
	for (int i = 0; i &lt; mesh.npolys; ++i)
	{
		unsigned short* p = &amp;mesh.polys[i*nvp*2];
		const int nv = countPolyVerts(p, nvp);
		for (int j = 0; j &lt; nv; ++j)
		{
			if (p[j] == rem)
				numRemovedVerts++;
		}
	}
	
	int nedges = 0;
	rcScopedDelete&lt;int&gt; edges((int*)rcAlloc(sizeof(int)*numRemovedVerts*nvp*4, RC_ALLOC_TEMP));
	if (!edges)
	{
		ctx-&gt;log(RC_LOG_WARNING, &quot;removeVertex: Out of memory 'edges' (%d).&quot;, numRemovedVerts*nvp*4);
		return false;
	}

	int nhole = 0;
	rcScopedDelete&lt;int&gt; hole((int*)rcAlloc(sizeof(int)*numRemovedVerts*nvp, RC_ALLOC_TEMP));
	if (!hole)
	{
		ctx-&gt;log(RC_LOG_WARNING, &quot;removeVertex: Out of memory 'hole' (%d).&quot;, numRemovedVerts*nvp);
		return false;
	}

	int nhreg = 0;
	rcScopedDelete&lt;int&gt; hreg((int*)rcAlloc(sizeof(int)*numRemovedVerts*nvp, RC_ALLOC_TEMP));
	if (!hreg)
	{
		ctx-&gt;log(RC_LOG_WARNING, &quot;removeVertex: Out of memory 'hreg' (%d).&quot;, numRemovedVerts*nvp);
		return false;
	}

	int nharea = 0;
	rcScopedDelete&lt;int&gt; harea((int*)rcAlloc(sizeof(int)*numRemovedVerts*nvp, RC_ALLOC_TEMP));
	if (!harea)
	{
		ctx-&gt;log(RC_LOG_WARNING, &quot;removeVertex: Out of memory 'harea' (%d).&quot;, numRemovedVerts*nvp);
		return false;
	}
	
	for (int i = 0; i &lt; mesh.npolys; ++i)
	{
		unsigned short* p = &amp;mesh.polys[i*nvp*2];
		const int nv = countPolyVerts(p, nvp);
		bool hasRem = false;
		for (int j = 0; j &lt; nv; ++j)
			if (p[j] == rem) hasRem = true;
		if (hasRem)
		{
			// Collect edges which does not touch the removed vertex.
			for (int j = 0, k = nv-1; j &lt; nv; k = j++)
			{
				if (p[j] != rem &amp;&amp; p[k] != rem)
				{
					int* e = &amp;edges[nedges*4];
					e[0] = p[k];
					e[1] = p[j];
					e[2] = mesh.regs[i];
					e[3] = mesh.areas[i];
					nedges++;
				}
			}
			// Remove the polygon.
			unsigned short* p2 = &amp;mesh.polys[(mesh.npolys-1)*nvp*2];
			if (p != p2)
				memcpy(p,p2,sizeof(unsigned short)*nvp);
			memset(p+nvp,0xff,sizeof(unsigned short)*nvp);
			mesh.regs[i] = mesh.regs[mesh.npolys-1];
			mesh.areas[i] = mesh.areas[mesh.npolys-1];
			mesh.npolys--;
			--i;
		}
	}
	
	// Remove vertex.
	for (int i = (int)rem; i &lt; mesh.nverts - 1; ++i)
	{
		mesh.verts[i*3+0] = mesh.verts[(i+1)*3+0];
		mesh.verts[i*3+1] = mesh.verts[(i+1)*3+1];
		mesh.verts[i*3+2] = mesh.verts[(i+1)*3+2];
	}
	mesh.nverts--;

	// Adjust indices to match the removed vertex layout.
	for (int i = 0; i &lt; mesh.npolys; ++i)
	{
		unsigned short* p = &amp;mesh.polys[i*nvp*2];
		const int nv = countPolyVerts(p, nvp);
		for (int j = 0; j &lt; nv; ++j)
			if (p[j] &gt; rem) p[j]--;
	}
	for (int i = 0; i &lt; nedges; ++i)
	{
		if (edges[i*4+0] &gt; rem) edges[i*4+0]--;
		if (edges[i*4+1] &gt; rem) edges[i*4+1]--;
	}

	if (nedges == 0)
		return true;

	// Start with one vertex, keep appending connected
	// segments to the start and end of the hole.
	pushBack(edges[0], hole, nhole);
	pushBack(edges[2], hreg, nhreg);
	pushBack(edges[3], harea, nharea);
	
	while (nedges)
	{
		bool match = false;
		
		for (int i = 0; i &lt; nedges; ++i)
		{
			const int ea = edges[i*4+0];
			const int eb = edges[i*4+1];
			const int r = edges[i*4+2];
			const int a = edges[i*4+3];
			bool add = false;
			if (hole[0] == eb)
			{
				// The segment matches the beginning of the hole boundary.
				pushFront(ea, hole, nhole);
				pushFront(r, hreg, nhreg);
				pushFront(a, harea, nharea);
				add = true;
			}
			else if (hole[nhole-1] == ea)
			{
				// The segment matches the end of the hole boundary.
				pushBack(eb, hole, nhole);
				pushBack(r, hreg, nhreg);
				pushBack(a, harea, nharea);
				add = true;
			}
			if (add)
			{
				// The edge segment was added, remove it.
				edges[i*4+0] = edges[(nedges-1)*4+0];
				edges[i*4+1] = edges[(nedges-1)*4+1];
				edges[i*4+2] = edges[(nedges-1)*4+2];
				edges[i*4+3] = edges[(nedges-1)*4+3];
				--nedges;
				match = true;
				--i;
			}
		}
		
		if (!match)
			break;
	}

	rcScopedDelete&lt;int&gt; tris((int*)rcAlloc(sizeof(int)*nhole*3, RC_ALLOC_TEMP));
	if (!tris)
	{
		ctx-&gt;log(RC_LOG_WARNING, &quot;removeVertex: Out of memory 'tris' (%d).&quot;, nhole*3);
		return false;
	}

	rcScopedDelete&lt;int&gt; tverts((int*)rcAlloc(sizeof(int)*nhole*4, RC_ALLOC_TEMP));
	if (!tverts)
	{
		ctx-&gt;log(RC_LOG_WARNING, &quot;removeVertex: Out of memory 'tverts' (%d).&quot;, nhole*4);
		return false;
	}

	rcScopedDelete&lt;int&gt; thole((int*)rcAlloc(sizeof(int)*nhole, RC_ALLOC_TEMP));
	if (!thole)
	{
		ctx-&gt;log(RC_LOG_WARNING, &quot;removeVertex: Out of memory 'thole' (%d).&quot;, nhole);
		return false;
	}

	// Generate temp vertex array for triangulation.
	for (int i = 0; i &lt; nhole; ++i)
	{
		const int pi = hole[i];
		tverts[i*4+0] = mesh.verts[pi*3+0];
		tverts[i*4+1] = mesh.verts[pi*3+1];
		tverts[i*4+2] = mesh.verts[pi*3+2];
		tverts[i*4+3] = 0;
		thole[i] = i;
	}

	// Triangulate the hole.
	int ntris = triangulate(nhole, &amp;tverts[0], &amp;thole[0], tris);
	if (ntris &lt; 0)
	{
		ntris = -ntris;
		ctx-&gt;log(RC_LOG_WARNING, &quot;removeVertex: triangulate() returned bad results.&quot;);
	}
	
	// Merge the hole triangles back to polygons.
	rcScopedDelete&lt;unsigned short&gt; polys((unsigned short*)rcAlloc(sizeof(unsigned short)*(ntris+1)*nvp, RC_ALLOC_TEMP));
	if (!polys)
	{
		ctx-&gt;log(RC_LOG_ERROR, &quot;removeVertex: Out of memory 'polys' (%d).&quot;, (ntris+1)*nvp);
		return false;
	}
	rcScopedDelete&lt;unsigned short&gt; pregs((unsigned short*)rcAlloc(sizeof(unsigned short)*ntris, RC_ALLOC_TEMP));
	if (!pregs)
	{
		ctx-&gt;log(RC_LOG_ERROR, &quot;removeVertex: Out of memory 'pregs' (%d).&quot;, ntris);
		return false;
	}
	rcScopedDelete&lt;unsigned char&gt; pareas((unsigned char*)rcAlloc(sizeof(unsigned char)*ntris, RC_ALLOC_TEMP));
	if (!pareas)
	{
		ctx-&gt;log(RC_LOG_ERROR, &quot;removeVertex: Out of memory 'pareas' (%d).&quot;, ntris);
		return false;
	}
	
	unsigned short* tmpPoly = &amp;polys[ntris*nvp];
			
	// Build initial polygons.
	int npolys = 0;
	memset(polys, 0xff, ntris*nvp*sizeof(unsigned short));
	for (int j = 0; j &lt; ntris; ++j)
	{
		int* t = &amp;tris[j*3];
		if (t[0] != t[1] &amp;&amp; t[0] != t[2] &amp;&amp; t[1] != t[2])
		{
			polys[npolys*nvp+0] = (unsigned short)hole[t[0]];
			polys[npolys*nvp+1] = (unsigned short)hole[t[1]];
			polys[npolys*nvp+2] = (unsigned short)hole[t[2]];

			// If this polygon covers multiple region types then
			// mark it as such
			if (hreg[t[0]] != hreg[t[1]] || hreg[t[1]] != hreg[t[2]])
				pregs[npolys] = RC_MULTIPLE_REGS;
			else
				pregs[npolys] = (unsigned short)hreg[t[0]];

			pareas[npolys] = (unsigned char)harea[t[0]];
			npolys++;
		}
	}
	if (!npolys)
		return true;
	
	// Merge polygons.
	if (nvp &gt; 3)
	{
		for (;;)
		{
			// Find best polygons to merge.
			int bestMergeVal = 0;
			int bestPa = 0, bestPb = 0, bestEa = 0, bestEb = 0;
			
			for (int j = 0; j &lt; npolys-1; ++j)
			{
				unsigned short* pj = &amp;polys[j*nvp];
				for (int k = j+1; k &lt; npolys; ++k)
				{
					unsigned short* pk = &amp;polys[k*nvp];
					int ea, eb;
					int v = getPolyMergeValue(pj, pk, mesh.verts, ea, eb, nvp);
					if (v &gt; bestMergeVal)
					{
						bestMergeVal = v;
						bestPa = j;
						bestPb = k;
						bestEa = ea;
						bestEb = eb;
					}
				}
			}
			
			if (bestMergeVal &gt; 0)
			{
				// Found best, merge.
				unsigned short* pa = &amp;polys[bestPa*nvp];
				unsigned short* pb = &amp;polys[bestPb*nvp];
				mergePolyVerts(pa, pb, bestEa, bestEb, tmpPoly, nvp);
				if (pregs[bestPa] != pregs[bestPb])
					pregs[bestPa] = RC_MULTIPLE_REGS;

				unsigned short* last = &amp;polys[(npolys-1)*nvp];
				if (pb != last)
					memcpy(pb, last, sizeof(unsigned short)*nvp);
				pregs[bestPb] = pregs[npolys-1];
				pareas[bestPb] = pareas[npolys-1];
				npolys--;
			}
			else
			{
				// Could not merge any polygons, stop.
				break;
			}
		}
	}
	
	// Store polygons.
	for (int i = 0; i &lt; npolys; ++i)
	{
		if (mesh.npolys &gt;= maxTris) break;
		unsigned short* p = &amp;mesh.polys[mesh.npolys*nvp*2];
		memset(p,0xff,sizeof(unsigned short)*nvp*2);
		for (int j = 0; j &lt; nvp; ++j)
			p[j] = polys[i*nvp+j];
		mesh.regs[mesh.npolys] = pregs[i];
		mesh.areas[mesh.npolys] = pareas[i];
		mesh.npolys++;
		if (mesh.npolys &gt; maxTris)
		{
			ctx-&gt;log(RC_LOG_ERROR, &quot;removeVertex: Too many polygons %d (max:%d).&quot;, mesh.npolys, maxTris);
			return false;
		}
	}
	
	return true;
}

...
</code></pre><ul>
<li><code>removeVertex</code> 移除的主要步骤如下：
<ul>
<li>遍历 <code>mesh</code> 的所有多边形，将所有包含待移除顶点的边记录到 <code>edges</code> 中，并将该多边形从 <code>mesh.polys</code> 中移除。</li>
<li>将目标顶点从 <code>mesh</code> 的 <code>verts</code> 中移除，且更新 <code>mesh.polys</code> 和 <code>edges</code> 中的顶点索引。</li>
<li>以 <code>edges</code> 的第一条边的两个顶点为左侧点和右侧点，遍历 <code>edges</code> 中的剩余边，找到和左侧点相邻的边，将其的左侧点作为左侧点，找到和右侧点相邻的边，将其右侧点作为右侧点，最终得到一组重新排序的顶点。</li>
<li>将排序后的顶点，通过 <code>triangulate</code> 方法划分成三角形。</li>
<li>将三角形加入到临时数组 <code>polys</code> 中，并记录对应的 <code>region</code> 和 <code>area</code> 到 <code>pregs</code> 和 <code>pareas</code> 中。如果三角形的 <code>region</code> 不同，则将 <code>pregs</code> 中对应的值设置为 <code>RC_MULTIPLE_REGS</code>。</li>
<li>如果每个多边形的最大顶点数 <code>nvp</code> 大于 3，则进行多边形合并。通过 <code>getPolyMergeValue</code> 方法找到公共边，<code>mergePolyVerts</code> 方法进行合并。如果两个多边形的 <code>region</code> 不同，则合并后的多边形的 <code>region</code> 设置为 <code>RC_MULTIPLE_REGS</code>。</li>
<li>将合并后的多边形 <code>polys</code> 加入到 <code>mesh.polys</code> 中，同时更新 <code>mesh.regs</code> 和 <code>mesh.areas</code>。</li>
</ul>
</li>
</ul>
<h2 id=计算多边形邻居>计算多边形邻居</h2>
<ul>
<li>计算多边形邻居时，使用了 <code>rcEdge</code> 记录边的信息，其结构如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastMesh.cpp

...

struct rcEdge
{
	unsigned short vert[2];				/// 边的两个顶点的索引
	unsigned short polyEdge[2];			/// 如果边的起始点索引比终点小，则 polyEdge[0] 为起始点在当前多边形中的第几个顶点。如果此时边为公共边，则 polyEdge[1] 为终点在邻居多边形中的第几个顶点
	unsigned short poly[2];				/// 两个顶点各自对应的多边形索引
};

...
</code></pre><ul>
<li><code>buildMeshAdjacency</code> 的实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastMesh.cpp

...

static bool buildMeshAdjacency(unsigned short* polys, const int npolys,
							   const int nverts, const int vertsPerPoly)
{
	// Based on code by Eric Lengyel from:
	// https://web.archive.org/web/20080704083314/http://www.terathon.com/code/edges.php
	
	int maxEdgeCount = npolys*vertsPerPoly;
	unsigned short* firstEdge = (unsigned short*)rcAlloc(sizeof(unsigned short)*(nverts + maxEdgeCount), RC_ALLOC_TEMP);
	if (!firstEdge)
		return false;
	unsigned short* nextEdge = firstEdge + nverts;
	int edgeCount = 0;
	
	rcEdge* edges = (rcEdge*)rcAlloc(sizeof(rcEdge)*maxEdgeCount, RC_ALLOC_TEMP);
	if (!edges)
	{
		rcFree(firstEdge);
		return false;
	}
	
	for (int i = 0; i &lt; nverts; i++)
		firstEdge[i] = RC_MESH_NULL_IDX;
	
	for (int i = 0; i &lt; npolys; ++i)
	{
		unsigned short* t = &amp;polys[i*vertsPerPoly*2];
		for (int j = 0; j &lt; vertsPerPoly; ++j)
		{
			if (t[j] == RC_MESH_NULL_IDX) break;
			unsigned short v0 = t[j];
			unsigned short v1 = (j+1 &gt;= vertsPerPoly || t[j+1] == RC_MESH_NULL_IDX) ? t[0] : t[j+1];
			if (v0 &lt; v1)
			{
				rcEdge&amp; edge = edges[edgeCount];
				edge.vert[0] = v0;
				edge.vert[1] = v1;
				edge.poly[0] = (unsigned short)i;
				edge.polyEdge[0] = (unsigned short)j;
				edge.poly[1] = (unsigned short)i;
				edge.polyEdge[1] = 0;
				// Insert edge
				nextEdge[edgeCount] = firstEdge[v0];
				firstEdge[v0] = (unsigned short)edgeCount;
				edgeCount++;
			}
		}
	}
	
	for (int i = 0; i &lt; npolys; ++i)
	{
		unsigned short* t = &amp;polys[i*vertsPerPoly*2];
		for (int j = 0; j &lt; vertsPerPoly; ++j)
		{
			if (t[j] == RC_MESH_NULL_IDX) break;
			unsigned short v0 = t[j];
			unsigned short v1 = (j+1 &gt;= vertsPerPoly || t[j+1] == RC_MESH_NULL_IDX) ? t[0] : t[j+1];
			if (v0 &gt; v1)
			{
				for (unsigned short e = firstEdge[v1]; e != RC_MESH_NULL_IDX; e = nextEdge[e])
				{
					rcEdge&amp; edge = edges[e];
					if (edge.vert[1] == v0 &amp;&amp; edge.poly[0] == edge.poly[1])
					{
						edge.poly[1] = (unsigned short)i;
						edge.polyEdge[1] = (unsigned short)j;
						break;
					}
				}
			}
		}
	}
	
	// Store adjacency
	for (int i = 0; i &lt; edgeCount; ++i)
	{
		const rcEdge&amp; e = edges[i];
		if (e.poly[0] != e.poly[1])
		{
			unsigned short* p0 = &amp;polys[e.poly[0]*vertsPerPoly*2];
			unsigned short* p1 = &amp;polys[e.poly[1]*vertsPerPoly*2];
			p0[vertsPerPoly + e.polyEdge[0]] = e.poly[1];
			p1[vertsPerPoly + e.polyEdge[1]] = e.poly[0];
		}
	}
	
	rcFree(firstEdge);
	rcFree(edges);
	
	return true;
}

...
</code></pre><ul>
<li><code>buildMeshAdjacency</code> 的主要步骤如下：
<ul>
<li>对每一个多边形，遍历其所有顶点，获取每个顶点为起始点的边，将起始点比终点索引小的边记录到 <code>edges</code> 中。
<ul>
<li><code>edge.vert[0]</code> 设置为起始顶点的索引，<code>edge.vert[1]</code> 设置为终点顶点的索引。</li>
<li><code>edge.poly[0]</code> 和 <code>edge.poly[1]</code> 都设置为当前多边形的索引。</li>
<li><code>edge.polyEdge[0]</code> 设置为起始点在当前多边形中的第几个顶点，<code>edge.polyEdge[1]</code> 设置为 0 。</li>
<li>将具有相同起始点的边通过 <code>nextEdge</code> 连接起来。</li>
</ul>
</li>
<li>对每一个多边形，遍历其所有顶点，获取每个顶点为起始点的边，对起始点比终点索引大的边进行检查，如果该边在 <code>edges</code> 中，则更新边的信息。
<ul>
<li><code>edge.poly[1]</code> 设置为当前多边形的索引，即为 <code>edge.poly[0]</code> 的邻居多边形。</li>
<li><code>edge.polyEdge[1]</code> 设置为 <code>edge.vert[1]</code> 在邻居多边形中的第几个顶点。</li>
</ul>
</li>
<li>遍历 <code>edges</code> 中的边，如果两个多边形的索引不同，则该边为公共边，需要将相邻信息记录到各自所属的多边形中，即 <code>mesh.polys</code> 中，其中 <code>mesh.polys[i * nvp * 2 + j]</code> 为多边形 <code>i</code> 的第 <code>j</code> 个顶点，则邻居信息需要记录在 <code>mesh.polys[i * nvp * 2 + nvp + j]</code> 中，
<ul>
<li><code>mesh.polys[edge.poly[0] * nvp * 2 + nvp + edge.polyEdge[0]]</code> 设置为 <code>edge.poly[1]</code>，即 <code>edge.poly[0]</code> 的第 <code>edge.polyEdge[0]</code> 个顶点的邻居多边形为 <code>edge.poly[1]</code>。</li>
<li><code>mesh.polys[edge.poly[1] * nvp * 2 + nvp + edge.polyEdge[1]]</code> 设置为 <code>edge.poly[0]</code>，即 <code>edge.poly[1]</code> 的第 <code>edge.polyEdge[1]</code> 个顶点的邻居多边形为 <code>edge.poly[0]</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id=七创建细节网格>七、创建细节网格</h1>
<ul>
<li>七、创建细节网格过程，使用 <code>rcPolyMeshDetail</code> 结构保存细节网格数据，其定义如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Include/Recast.h

struct rcPolyMeshDetail
{
	...
	
	unsigned int* meshes;	/// 所有子网格数据，长度为 4 * nmeshes，每个多边形对应一个子网格，占 4 个数据，分别为：之前所有子网格的总顶点数、当前子网格顶点数、之前所有子网格的三角面总数、当前子网格的三角面数
	float* verts;			/// 所有子网格顶点数据，长度为 3 * nverts
	unsigned char* tris;	/// 所有子网格的三角面顶点索引，长度为 3 * ntris，每个三角面占 4 个数据，分别为：三个顶点的索引、三条边是否为初始网格边的标记
	int nmeshes;			/// 子网格数量
	int nverts;				/// 子网格总顶点数量
	int ntris;				/// 子网格总三角面数量
	
	...
};

</code></pre><ul>
<li>创建细节网格使用 <code>rcBuildPolyMeshDetail</code> 方法，其实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastMeshDetail.cpp

...

bool rcBuildPolyMeshDetail(rcContext* ctx, const rcPolyMesh&amp; mesh, const rcCompactHeightfield&amp; chf,
						   const float sampleDist, const float sampleMaxError,
						   rcPolyMeshDetail&amp; dmesh)
{
	rcAssert(ctx);
	
	rcScopedTimer timer(ctx, RC_TIMER_BUILD_POLYMESHDETAIL);
	
	if (mesh.nverts == 0 || mesh.npolys == 0)
		return true;
	
	const int nvp = mesh.nvp;
	const float cs = mesh.cs;
	const float ch = mesh.ch;
	const float* orig = mesh.bmin;
	const int borderSize = mesh.borderSize;
	const int heightSearchRadius = rcMax(1, (int)ceilf(mesh.maxEdgeError));
	
	rcTempVector&lt;int&gt; edges(64);
	rcTempVector&lt;int&gt; tris(512);
	rcTempVector&lt;int&gt; arr(512);
	rcTempVector&lt;int&gt; samples(512);
	float verts[256*3];
	rcHeightPatch hp;
	int nPolyVerts = 0;
	int maxhw = 0, maxhh = 0;
	
	rcScopedDelete&lt;int&gt; bounds((int*)rcAlloc(sizeof(int)*mesh.npolys*4, RC_ALLOC_TEMP));
	if (!bounds)
	{
		ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildPolyMeshDetail: Out of memory 'bounds' (%d).&quot;, mesh.npolys*4);
		return false;
	}
	rcScopedDelete&lt;float&gt; poly((float*)rcAlloc(sizeof(float)*nvp*3, RC_ALLOC_TEMP));
	if (!poly)
	{
		ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildPolyMeshDetail: Out of memory 'poly' (%d).&quot;, nvp*3);
		return false;
	}
	
	// Find max size for a polygon area.
	for (int i = 0; i &lt; mesh.npolys; ++i)
	{
		const unsigned short* p = &amp;mesh.polys[i*nvp*2];
		int&amp; xmin = bounds[i*4+0];
		int&amp; xmax = bounds[i*4+1];
		int&amp; ymin = bounds[i*4+2];
		int&amp; ymax = bounds[i*4+3];
		xmin = chf.width;
		xmax = 0;
		ymin = chf.height;
		ymax = 0;
		for (int j = 0; j &lt; nvp; ++j)
		{
			if(p[j] == RC_MESH_NULL_IDX) break;
			const unsigned short* v = &amp;mesh.verts[p[j]*3];
			xmin = rcMin(xmin, (int)v[0]);
			xmax = rcMax(xmax, (int)v[0]);
			ymin = rcMin(ymin, (int)v[2]);
			ymax = rcMax(ymax, (int)v[2]);
			nPolyVerts++;
		}
		xmin = rcMax(0,xmin-1);
		xmax = rcMin(chf.width,xmax+1);
		ymin = rcMax(0,ymin-1);
		ymax = rcMin(chf.height,ymax+1);
		if (xmin &gt;= xmax || ymin &gt;= ymax) continue;
		maxhw = rcMax(maxhw, xmax-xmin);
		maxhh = rcMax(maxhh, ymax-ymin);
	}
	
	hp.data = (unsigned short*)rcAlloc(sizeof(unsigned short)*maxhw*maxhh, RC_ALLOC_TEMP);
	if (!hp.data)
	{
		ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildPolyMeshDetail: Out of memory 'hp.data' (%d).&quot;, maxhw*maxhh);
		return false;
	}
	
	dmesh.nmeshes = mesh.npolys;
	dmesh.nverts = 0;
	dmesh.ntris = 0;
	dmesh.meshes = (unsigned int*)rcAlloc(sizeof(unsigned int)*dmesh.nmeshes*4, RC_ALLOC_PERM);
	if (!dmesh.meshes)
	{
		ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildPolyMeshDetail: Out of memory 'dmesh.meshes' (%d).&quot;, dmesh.nmeshes*4);
		return false;
	}
	
	int vcap = nPolyVerts+nPolyVerts/2;
	int tcap = vcap*2;
	
	dmesh.nverts = 0;
	dmesh.verts = (float*)rcAlloc(sizeof(float)*vcap*3, RC_ALLOC_PERM);
	if (!dmesh.verts)
	{
		ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildPolyMeshDetail: Out of memory 'dmesh.verts' (%d).&quot;, vcap*3);
		return false;
	}
	dmesh.ntris = 0;
	dmesh.tris = (unsigned char*)rcAlloc(sizeof(unsigned char)*tcap*4, RC_ALLOC_PERM);
	if (!dmesh.tris)
	{
		ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildPolyMeshDetail: Out of memory 'dmesh.tris' (%d).&quot;, tcap*4);
		return false;
	}
	
	for (int i = 0; i &lt; mesh.npolys; ++i)
	{
		const unsigned short* p = &amp;mesh.polys[i*nvp*2];
		
		// Store polygon vertices for processing.
		int npoly = 0;
		for (int j = 0; j &lt; nvp; ++j)
		{
			if(p[j] == RC_MESH_NULL_IDX) break;
			const unsigned short* v = &amp;mesh.verts[p[j]*3];
			poly[j*3+0] = v[0]*cs;
			poly[j*3+1] = v[1]*ch;
			poly[j*3+2] = v[2]*cs;
			npoly++;
		}
		
		// Get the height data from the area of the polygon.
		hp.xmin = bounds[i*4+0];
		hp.ymin = bounds[i*4+2];
		hp.width = bounds[i*4+1]-bounds[i*4+0];
		hp.height = bounds[i*4+3]-bounds[i*4+2];
		getHeightData(ctx, chf, p, npoly, mesh.verts, borderSize, hp, arr, mesh.regs[i]);
		
		// Build detail mesh.
		int nverts = 0;
		if (!buildPolyDetail(ctx, poly, npoly,
							 sampleDist, sampleMaxError,
							 heightSearchRadius, chf, hp,
							 verts, nverts, tris,
							 edges, samples))
		{
			return false;
		}
		
		// Move detail verts to world space.
		for (int j = 0; j &lt; nverts; ++j)
		{
			verts[j*3+0] += orig[0];
			verts[j*3+1] += orig[1] + chf.ch; // Is this offset necessary?
			verts[j*3+2] += orig[2];
		}
		// Offset poly too, will be used to flag checking.
		for (int j = 0; j &lt; npoly; ++j)
		{
			poly[j*3+0] += orig[0];
			poly[j*3+1] += orig[1];
			poly[j*3+2] += orig[2];
		}
		
		// Store detail submesh.
		const int ntris = static_cast&lt;int&gt;(tris.size()) / 4;
		
		dmesh.meshes[i*4+0] = (unsigned int)dmesh.nverts;
		dmesh.meshes[i*4+1] = (unsigned int)nverts;
		dmesh.meshes[i*4+2] = (unsigned int)dmesh.ntris;
		dmesh.meshes[i*4+3] = (unsigned int)ntris;
		
		// Store vertices, allocate more memory if necessary.
		if (dmesh.nverts+nverts &gt; vcap)
		{
			while (dmesh.nverts+nverts &gt; vcap)
				vcap += 256;
			
			float* newv = (float*)rcAlloc(sizeof(float)*vcap*3, RC_ALLOC_PERM);
			if (!newv)
			{
				ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildPolyMeshDetail: Out of memory 'newv' (%d).&quot;, vcap*3);
				return false;
			}
			if (dmesh.nverts)
				memcpy(newv, dmesh.verts, sizeof(float)*3*dmesh.nverts);
			rcFree(dmesh.verts);
			dmesh.verts = newv;
		}
		for (int j = 0; j &lt; nverts; ++j)
		{
			dmesh.verts[dmesh.nverts*3+0] = verts[j*3+0];
			dmesh.verts[dmesh.nverts*3+1] = verts[j*3+1];
			dmesh.verts[dmesh.nverts*3+2] = verts[j*3+2];
			dmesh.nverts++;
		}
		
		// Store triangles, allocate more memory if necessary.
		if (dmesh.ntris+ntris &gt; tcap)
		{
			while (dmesh.ntris+ntris &gt; tcap)
				tcap += 256;
			unsigned char* newt = (unsigned char*)rcAlloc(sizeof(unsigned char)*tcap*4, RC_ALLOC_PERM);
			if (!newt)
			{
				ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildPolyMeshDetail: Out of memory 'newt' (%d).&quot;, tcap*4);
				return false;
			}
			if (dmesh.ntris)
				memcpy(newt, dmesh.tris, sizeof(unsigned char)*4*dmesh.ntris);
			rcFree(dmesh.tris);
			dmesh.tris = newt;
		}
		for (int j = 0; j &lt; ntris; ++j)
		{
			const int* t = &amp;tris[j*4];
			dmesh.tris[dmesh.ntris*4+0] = (unsigned char)t[0];
			dmesh.tris[dmesh.ntris*4+1] = (unsigned char)t[1];
			dmesh.tris[dmesh.ntris*4+2] = (unsigned char)t[2];
			dmesh.tris[dmesh.ntris*4+3] = (unsigned char)t[3];
			dmesh.ntris++;
		}
	}
	
	return true;
}

...

</code></pre><ul>
<li>网格细节的数据存储在 <code>rcPolyMeshDetail</code> 结构的 <code>dmesh</code> ，创建细节网格的主要步骤如下：
<ul>
<li>使用 <code>rcPolyMesh</code> 网格初始化参数，包括单元格大小 <code>mesh.cs</code> 、单元格高度 <code>mesh.ch</code> 、包围盒最小值 <code>mesh.bmin</code> 、borderSize 大小 <code>mesh.borderSize</code> 等。</li>
<li>遍历网格的每个多边形，找到其中的最大宽高尺寸。</li>
<li>创建 <code>tris</code> 数组，用于记录细化后的三角面索引信息。</li>
<li>创建 <code>verts</code> 数组，用于记录细化后的网格顶点坐标。</li>
<li>创建 <code>poly</code> 数组，用于记录多边形的顶点坐标。</li>
<li>遍历网格的每个多边形，对每个多边形进行处理。
<ul>
<li>遍历多边形的每个顶点，获取顶点的单元格坐标，并乘上单元格大小或单元格高度，转化成相对的世界坐标，存入 <code>poly</code> 中。
<ul>
<li>第二步光栅化后，得到的 <code>span</code> 坐标为偏移了高度场的 <code>bmin</code> 的坐标，而第五步得到轮廓后的顶点坐标，则是在此基础上加上了 <code>borderSize</code> 的偏移，即偏移了 <code>rcPolyMesh.bmin</code>（同 <code>rcContourSet.bmin</code>）。</li>
</ul>
</li>
<li>通过 <code>getHeightData</code> 方法，获取多边形的高度信息。</li>
<li>通过 <code>buildPolyDetail</code> 方法，构建多边形的细节网格，将数据存入 <code>tris</code> 和 <code>verts</code>。</li>
<li>将 <code>verts</code> 的坐标转化成世界坐标，即加上 <code>mesh.bmin</code> 的偏移，其中 <code>y</code> 坐标额外加上 <code>chf.ch</code> ，即加上单元格的高度。</li>
<li>将 <code>poly</code> 的坐标转化成世界坐标，即加上 <code>mesh.bmin</code> 的偏移。</li>
<li>设置当前多边形的细节子网格信息。
<ul>
<li><code>dmesh.meshes[i*4+0]</code> 为之前所有多边形子网格的总顶点数。</li>
<li><code>dmesh.meshes[i*4+1]</code> 为当前多边形子网格的顶点数。</li>
<li><code>dmesh.meshes[i*4+2]</code> 为之前所有多边形子网格的总三角面数。</li>
<li><code>dmesh.meshes[i*4+3]</code> 为当前多边形子网格的三角面数。</li>
</ul>
</li>
<li>将 <code>verts</code> 加入到 <code>dmesh.verts</code> 中，并更新 <code>dmesh.nverts</code> 。</li>
<li>将 <code>tris</code> 加入到 <code>dmesh.tris</code> 中，并更新 <code>dmesh.ntris</code> 。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id=获取高度信息>获取高度信息</h2>
<ul>
<li>获取高度信息方法 <code>getHeightData</code> 的实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastMeshDetail.cpp

...

static void getHeightData(rcContext* ctx, const rcCompactHeightfield&amp; chf,
						  const unsigned short* poly, const int npoly,
						  const unsigned short* verts, const int bs,
						  rcHeightPatch&amp; hp, rcTempVector&lt;int&gt;&amp; queue,
						  int region)
{
	// Note: Reads to the compact heightfield are offset by border size (bs)
	// since border size offset is already removed from the polymesh vertices.
	
	queue.clear();
	// Set all heights to RC_UNSET_HEIGHT.
	memset(hp.data, 0xff, sizeof(unsigned short)*hp.width*hp.height);

	bool empty = true;
	
	// We cannot sample from this poly if it was created from polys
	// of different regions. If it was then it could potentially be overlapping
	// with polys of that region and the heights sampled here could be wrong.
	if (region != RC_MULTIPLE_REGS)
	{
		// Copy the height from the same region, and mark region borders
		// as seed points to fill the rest.
		for (int hy = 0; hy &lt; hp.height; hy++)
		{
			int y = hp.ymin + hy + bs;
			for (int hx = 0; hx &lt; hp.width; hx++)
			{
				int x = hp.xmin + hx + bs;
				const rcCompactCell&amp; c = chf.cells[x + y*chf.width];
				for (int i = (int)c.index, ni = (int)(c.index + c.count); i &lt; ni; ++i)
				{
					const rcCompactSpan&amp; s = chf.spans[i];
					if (s.reg == region)
					{
						// Store height
						hp.data[hx + hy*hp.width] = s.y;
						empty = false;

						// If any of the neighbours is not in same region,
						// add the current location as flood fill start
						bool border = false;
						for (int dir = 0; dir &lt; 4; ++dir)
						{
							if (rcGetCon(s, dir) != RC_NOT_CONNECTED)
							{
								const int ax = x + rcGetDirOffsetX(dir);
								const int ay = y + rcGetDirOffsetY(dir);
								const int ai = (int)chf.cells[ax + ay*chf.width].index + rcGetCon(s, dir);
								const rcCompactSpan&amp; as = chf.spans[ai];
								if (as.reg != region)
								{
									border = true;
									break;
								}
							}
						}
						if (border)
							push3(queue, x, y, i);
						break;
					}
				}
			}
		}
	}
	
	// if the polygon does not contain any points from the current region (rare, but happens)
	// or if it could potentially be overlapping polygons of the same region,
	// then use the center as the seed point.
	if (empty)
		seedArrayWithPolyCenter(ctx, chf, poly, npoly, verts, bs, hp, queue);
	
	static const int RETRACT_SIZE = 256;
	int head = 0;
	
	// We assume the seed is centered in the polygon, so a BFS to collect
	// height data will ensure we do not move onto overlapping polygons and
	// sample wrong heights.
	while (head*3 &lt; queue.size())
	{
		int cx = queue[head*3+0];
		int cy = queue[head*3+1];
		int ci = queue[head*3+2];
		head++;
		if (head &gt;= RETRACT_SIZE)
		{
			head = 0;
			if (queue.size() &gt; RETRACT_SIZE*3)
				memmove(&amp;queue[0], &amp;queue[RETRACT_SIZE*3], sizeof(int)*(queue.size()-RETRACT_SIZE*3));
			queue.resize(queue.size()-RETRACT_SIZE*3);
		}
		
		const rcCompactSpan&amp; cs = chf.spans[ci];
		for (int dir = 0; dir &lt; 4; ++dir)
		{
			if (rcGetCon(cs, dir) == RC_NOT_CONNECTED) continue;
			
			const int ax = cx + rcGetDirOffsetX(dir);
			const int ay = cy + rcGetDirOffsetY(dir);
			const int hx = ax - hp.xmin - bs;
			const int hy = ay - hp.ymin - bs;
			
			if ((unsigned int)hx &gt;= (unsigned int)hp.width || (unsigned int)hy &gt;= (unsigned int)hp.height)
				continue;
			
			if (hp.data[hx + hy*hp.width] != RC_UNSET_HEIGHT)
				continue;
			
			const int ai = (int)chf.cells[ax + ay*chf.width].index + rcGetCon(cs, dir);
			const rcCompactSpan&amp; as = chf.spans[ai];
			
			hp.data[hx + hy*hp.width] = as.y;

			
			push3(queue, ax, ay, ai);
		}
	}
}

...
</code></pre><ul>
<li>获取高度信息的步骤如下：
<ul>
<li>如果当前 <code>region</code> 不与多个 <code>region</code> 相连，即不为 <code>RC_MULTIPLE_REGS</code>，则遍历当前多边形包围盒内每个 <code>cell</code> 的 <code>span</code>，对 <code>region</code> 和多边形 <code>region</code> 相同的 <code>span</code> 进行处理。
<ul>
<li>记录当前 <code>cell</code> 对应的高度为 <code>span.y</code>。</li>
<li>遍历四个方向的邻居 <code>span</code>，如果邻居的 <code>region</code> 和当前 <code>region</code> 不同，则将当前 <code>cell</code> 以多边形包围盒最小点为原点的坐标和 <code>span</code> 索引加入到 <code>queue</code> 中。</li>
</ul>
</li>
<li>如果所有 <code>span</code> 的 <code>region</code> 都和当前 <code>region</code> 不相同，则使用 <code>seedArrayWithPolyCenter</code> 方法将多边形的中心点加入到 <code>queue</code> 中。</li>
<li>对 <code>queue</code> 中的每个 <code>span</code> 索引，检查其四个方向的邻居，如果为可行走，且不超过多边形包围盒，同时高度没有记录过，则记录该邻居高度 <code>span.y</code> ，并将邻居位置加入到 <code>queue</code> 中。即从当前 <code>region</code> 开始扩散，直到所有 <code>span</code> 都处理完，则得到当前多边形包围盒内的所有高度信息。</li>
</ul>
</li>
</ul>
<h2 id=建立多边形细节>建立多边形细节</h2>
<ul>
<li>建立多边形细节方法 <code>buildPolyDetail</code> 的实现如下：</li>
</ul>
<pre tabindex=0><code>// Recast/Source/RecastMeshDetail.cpp

static bool buildPolyDetail(rcContext* ctx, const float* in, const int nin,
							const float sampleDist, const float sampleMaxError,
							const int heightSearchRadius, const rcCompactHeightfield&amp; chf,
							const rcHeightPatch&amp; hp, float* verts, int&amp; nverts,
							rcTempVector&lt;int&gt;&amp; tris, rcTempVector&lt;int&gt;&amp; edges, rcTempVector&lt;int&gt;&amp; samples)
{
	static const int MAX_VERTS = 127;
	static const int MAX_TRIS = 255;	// Max tris for delaunay is 2n-2-k (n=num verts, k=num hull verts).
	static const int MAX_VERTS_PER_EDGE = 32;
	float edge[(MAX_VERTS_PER_EDGE+1)*3];
	int hull[MAX_VERTS];
	int nhull = 0;
	
	nverts = nin;
	
	for (int i = 0; i &lt; nin; ++i)
		rcVcopy(&amp;verts[i*3], &amp;in[i*3]);
	
	edges.clear();
	tris.clear();
	
	const float cs = chf.cs;
	const float ics = 1.0f/cs;
	
	// Calculate minimum extents of the polygon based on input data.
	float minExtent = polyMinExtent(verts, nverts);
	
	// Tessellate outlines.
	// This is done in separate pass in order to ensure
	// seamless height values across the ply boundaries.
	if (sampleDist &gt; 0)
	{
		for (int i = 0, j = nin-1; i &lt; nin; j=i++)
		{
			const float* vj = &amp;in[j*3];
			const float* vi = &amp;in[i*3];
			bool swapped = false;
			// Make sure the segments are always handled in same order
			// using lexological sort or else there will be seams.
			if (fabsf(vj[0]-vi[0]) &lt; 1e-6f)
			{
				if (vj[2] &gt; vi[2])
				{
					rcSwap(vj,vi);
					swapped = true;
				}
			}
			else
			{
				if (vj[0] &gt; vi[0])
				{
					rcSwap(vj,vi);
					swapped = true;
				}
			}
			// Create samples along the edge.
			float dx = vi[0] - vj[0];
			float dy = vi[1] - vj[1];
			float dz = vi[2] - vj[2];
			float d = sqrtf(dx*dx + dz*dz);
			int nn = 1 + (int)floorf(d/sampleDist);
			if (nn &gt;= MAX_VERTS_PER_EDGE) nn = MAX_VERTS_PER_EDGE-1;
			if (nverts+nn &gt;= MAX_VERTS)
				nn = MAX_VERTS-1-nverts;
			
			for (int k = 0; k &lt;= nn; ++k)
			{
				float u = (float)k/(float)nn;
				float* pos = &amp;edge[k*3];
				pos[0] = vj[0] + dx*u;
				pos[1] = vj[1] + dy*u;
				pos[2] = vj[2] + dz*u;
				pos[1] = getHeight(pos[0],pos[1],pos[2], cs, ics, chf.ch, heightSearchRadius, hp)*chf.ch;
			}
			// Simplify samples.
			int idx[MAX_VERTS_PER_EDGE] = {0,nn};
			int nidx = 2;
			for (int k = 0; k &lt; nidx-1; )
			{
				const int a = idx[k];
				const int b = idx[k+1];
				const float* va = &amp;edge[a*3];
				const float* vb = &amp;edge[b*3];
				// Find maximum deviation along the segment.
				float maxd = 0;
				int maxi = -1;
				for (int m = a+1; m &lt; b; ++m)
				{
					float dev = distancePtSeg(&amp;edge[m*3],va,vb);
					if (dev &gt; maxd)
					{
						maxd = dev;
						maxi = m;
					}
				}
				// If the max deviation is larger than accepted error,
				// add new point, else continue to next segment.
				if (maxi != -1 &amp;&amp; maxd &gt; rcSqr(sampleMaxError))
				{
					for (int m = nidx; m &gt; k; --m)
						idx[m] = idx[m-1];
					idx[k+1] = maxi;
					nidx++; 
				}
				else
				{
					++k;
				}
			}
			
			hull[nhull++] = j;
			// Add new vertices.
			if (swapped)
			{
				for (int k = nidx-2; k &gt; 0; --k)
				{
					rcVcopy(&amp;verts[nverts*3], &amp;edge[idx[k]*3]);
					hull[nhull++] = nverts;
					nverts++;
				}
			}
			else
			{
				for (int k = 1; k &lt; nidx-1; ++k)
				{
					rcVcopy(&amp;verts[nverts*3], &amp;edge[idx[k]*3]);
					hull[nhull++] = nverts;
					nverts++;
				}
			}
		}
	}
	
	// If the polygon minimum extent is small (sliver or small triangle), do not try to add internal points.
	if (minExtent &lt; sampleDist*2)
	{
		triangulateHull(nverts, verts, nhull, hull, nin, tris);
		setTriFlags(tris, nhull, hull);
		return true;
	}
	
	// Tessellate the base mesh.
	// We're using the triangulateHull instead of delaunayHull as it tends to
	// create a bit better triangulation for long thin triangles when there
	// are no internal points.
	triangulateHull(nverts, verts, nhull, hull, nin, tris);
	
	if (tris.size() == 0)
	{
		// Could not triangulate the poly, make sure there is some valid data there.
		ctx-&gt;log(RC_LOG_WARNING, &quot;buildPolyDetail: Could not triangulate polygon (%d verts).&quot;, nverts);
		return true;
	}
	
	if (sampleDist &gt; 0)
	{
		// Create sample locations in a grid.
		float bmin[3], bmax[3];
		rcVcopy(bmin, in);
		rcVcopy(bmax, in);
		for (int i = 1; i &lt; nin; ++i)
		{
			rcVmin(bmin, &amp;in[i*3]);
			rcVmax(bmax, &amp;in[i*3]);
		}
		int x0 = (int)floorf(bmin[0]/sampleDist);
		int x1 = (int)ceilf(bmax[0]/sampleDist);
		int z0 = (int)floorf(bmin[2]/sampleDist);
		int z1 = (int)ceilf(bmax[2]/sampleDist);
		samples.clear();
		for (int z = z0; z &lt; z1; ++z) 
		{
			for (int x = x0; x &lt; x1; ++x)
			{
				float pt[3];
				pt[0] = x*sampleDist;
				pt[1] = (bmax[1]+bmin[1])*0.5f;
				pt[2] = z*sampleDist;
				// Make sure the samples are not too close to the edges.
				if (distToPoly(nin,in,pt) &gt; -sampleDist/2) continue;
				samples.push_back(x);
				samples.push_back(getHeight(pt[0], pt[1], pt[2], cs, ics, chf.ch, heightSearchRadius, hp));
				samples.push_back(z);
				samples.push_back(0); // Not added
			}
		}
		
		// Add the samples starting from the one that has the most
		// error. The procedure stops when all samples are added
		// or when the max error is within treshold.
		const int nsamples = static_cast&lt;int&gt;(samples.size()) / 4;
		for (int iter = 0; iter &lt; nsamples; ++iter)
		{
			if (nverts &gt;= MAX_VERTS)
				break;
			
			// Find sample with most error.
			float bestpt[3] = {0,0,0};
			float bestd = 0;
			int besti = -1;
			for (int i = 0; i &lt; nsamples; ++i)
			{
				const int* s = &amp;samples[i*4];
				if (s[3]) continue; // skip added.
				float pt[3];
				// The sample location is jittered to get rid of some bad triangulations
				// which are cause by symmetrical data from the grid structure.
				pt[0] = s[0]*sampleDist + getJitterX(i)*cs*0.1f;
				pt[1] = s[1]*chf.ch;
				pt[2] = s[2]*sampleDist + getJitterY(i)*cs*0.1f;
				float d = distToTriMesh(pt, verts, nverts, &amp;tris[0], static_cast&lt;int&gt;(tris.size()) / 4);
				if (d &lt; 0) continue; // did not hit the mesh.
				if (d &gt; bestd)
				{
					bestd = d;
					besti = i;
					rcVcopy(bestpt,pt);
				}
			}
			// If the max error is within accepted threshold, stop tesselating.
			if (bestd &lt;= sampleMaxError || besti == -1)
				break;
			// Mark sample as added.
			samples[besti*4+3] = 1;
			// Add the new sample point.
			rcVcopy(&amp;verts[nverts*3],bestpt);
			nverts++;
			
			// Create new triangulation.
			// TODO: Incremental add instead of full rebuild.
			edges.clear();
			tris.clear();
			delaunayHull(ctx, nverts, verts, nhull, hull, tris, edges);
		}
	}
	
	const int ntris = static_cast&lt;int&gt;(tris.size()) / 4;
	if (ntris &gt; MAX_TRIS)
	{
		tris.resize(MAX_TRIS*4);
		ctx-&gt;log(RC_LOG_ERROR, &quot;rcBuildPolyMeshDetail: Shrinking triangle count from %d to max %d.&quot;, ntris, MAX_TRIS);
	}

	setTriFlags(tris, nhull, hull);
	
	return true;
}

...
</code></pre><h1 id=八创建导航数据>八、创建导航数据</h1>
<h1 id=参考>参考</h1>
<ul>
<li><a href=https://github.com/recastnavigation/recastnavigation>Github - Recast Navigation</a></li>
</ul>
<hr>
<ul class=pager>
<li class=previous>
<a href=/post/algorithm/algorithm_navmeshnavigation_1/ data-toggle=tooltip data-placement=top title="算法篇 — NavMesh 导航 — （1）寻路">&larr;
Previous Post</a>
</li>
</ul>
<div id=disqus-comment></div>
</div>
<div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container">
<div class=side-catalog>
<hr class="hidden-sm hidden-xs">
<h5>
<a class=catalog-toggle href=#>CATALOG</a>
</h5>
<ul class=catalog-body></ul>
</div>
</div>
<div class="col-lg-11 col-lg-offset-1
col-md-10 col-md-offset-1
sidebar-container">
</div>
</div>
</div>
</article>
<footer>
<div class=container>
<div class=row>
<div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
<ul class="list-inline text-center">
</ul>
<p class="copyright text-muted">
Copyright &copy; Xun's Blog 2025
<br>
<a href=https://themes.gohugo.io/hugo-theme-cleanwhite>CleanWhite Hugo Theme</a> by <a href=https://zhaohuabing.com>Huabing</a> |
<iframe style=margin-left:2px;margin-bottom:-5px frameborder=0 scrolling=0 width=100px height=20px src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true"></iframe>
</p>
</div>
</div>
</div>
</footer>
<script>function loadAsync(f,b){var c=document,d='script',a=c.createElement(d),e=c.getElementsByTagName(d)[0];a.src=f,b&&a.addEventListener('load',function(a){b(null,a)},!1),e.parentNode.insertBefore(a,e)}</script>
<script>$('#tag_cloud').length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:'#bbbbee',end:'#0085a1'}},$('#tag_cloud a').tagcloud()})</script>
<script>loadAsync("https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.js",function(){var a=document.querySelector("nav");a&&FastClick.attach(a)})</script>
<script type=text/javascript>function generateCatalog(a){_containerSelector='div.post-container';var h=$(_containerSelector),c,d,e,f,g,b;return c=h.find('h1,h2,h3,h4,h5,h6'),$(a).html(''),c.each(function(){d=$(this).prop('tagName').toLowerCase(),g="#"+$(this).prop('id'),e=$(this).text(),b=$('<a href="'+g+'" rel="nofollow">'+e+'</a>'),f=$('<li class="'+d+'_nav"></li>').append(b),$(a).append(f)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(a){a.preventDefault(),$('.side-catalog').toggleClass("fold")}),loadAsync("/js/jquery.nav.js",function(){$('.catalog-body').onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script>
</body>
</html>
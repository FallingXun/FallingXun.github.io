<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Xun's Blog | Lua篇 (1) — ToLua</title><meta name=viewport content="width=device-width,initial-scale=1"><link href="https://fonts.googleapis.com/css?family=Open+Sans" rel=stylesheet><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.1/css/bulma.min.css><link rel=stylesheet href=http://example.org/css/blog.css></head><body><nav class="navbar is-fixed-top" role=navigation aria-label="main navigation"><div class=navbar-brand><a class=navbar-item href=http://example.org/>Home</a></div></nav><section class="hero is-info is-medium"><div class=hero-body style=background-image:url(http://example.org/img/bg-blog.jpg)><div class="container has-text-centered"><br><h1 class="title is-size-1">Lua篇 (1) — ToLua</h1></div></div></section><div class=container><div class=section><div class=columns><div class="column is-9"><div class="tile is-child box"><div class=content><h2 id=lua-通用>Lua 通用</h2><ul><li><p>DoString/DoFile 和 Require 都是将脚本加载到lua虚拟机并存到全局表中， DoString/DoFile每次调用都会执行脚本对象，而Require会检查对象是否已经加载过,如果加载过则不会再次执行。</p></li><li><p>由于热更需求的出现，Unity传统的CSharp开发渐渐变成了CSharp+Lua开发。从语言角度看，在CSharp侧，对象基本都是以class的形式存在，而在Lua侧，则基本上都是以table的形式存在。尽管大部分情况下，两种语言都各自运行相对独立的模块，但是总避免不了要有交互，因此就需要解决CSharp和Lua之间的交互问题。</p></li></ul><hr><h2 id=tolua>ToLua</h2><h3 id=初始化>初始化</h3><h4 id=创建luastate>创建LuaState</h4><blockquote><p>Lua状态机创建方法主要实现如下</p></blockquote><pre><code>	public LuaState()            
	{
		...
    	InitTypeTraits();
    	InitStackTraits();
    	L = LuaNewState();            
    	LuaException.Init(L);
    	stateMap.Add(L, this);                        
    	OpenToLuaLibs();            
    	ToLua.OpenLibs(L);
    	OpenBaseLibs();
    	...
	}        
</code></pre><ul><li>InitTypeTraits()<ul><li>注册常用类型检查函数</li></ul></li><li>InitStackTraits()<ul><li>注册常用类型数据入栈和栈上数据弹出解析函数</li></ul></li><li>OpenToLuaLibs()<ul><li>打开指定的标准库，注册方法到全局表，包括package、preload、loadlib、seeall、module、require等</li><li>创建int64和uint64的table，注册到registry表中的LUA_RIDX_INT64和LUA_RIDX_UINT64中</li><li>注册其他到全局表，如：Mathf、tolua、gettag、settag等</li></ul></li><li>ToLua.OpenLibs(L)<ul><li>往全局表中注册print、dofile、loadfile方法</li><li>往tolua表中注册isnull（判断是否为Lua侧的nil或者CSharp侧null）、typeof、tolstring（CSharp侧的数据转lua字符串）、toarray</li></ul></li><li>OpenBaseLibs()<ul><li>注册System、LuaInterface、UnityEngine模块，其中List和Dictionary没有注册创建方法</li><li>创建Layer表到全局表中，将LayerMask的层级添加到Layer表中</li><li>初始化反射相关，加载mscorlib和UnityEngine程序集并缓存，注册反射相关方法到tolua表中，包括findtype、loadassembly、getmethod、getconstructor、gettypemethod、getfield、getproperty、createinstance</li><li>注册CSharp反射相关Wrap的初始化方法，key值为tolua.reflection</li></ul></li></ul><h4 id=初始化相关库>初始化相关库</h4><blockquote><p>lua侧需要使用的相关库函数，要进行初始化</p></blockquote><ul><li>luaopen_pb</li><li>luaopen_struct</li><li>luaopen_lpeg</li><li>cjson（可选）</li><li>&mldr;</li></ul><h4 id=绑定>绑定</h4><blockquote><p>CSharp的相关方法要进行绑定，即注册到lua侧</p></blockquote><pre><code>    protected virtual void Bind()
    {        
        LuaBinder.Bind(luaState);
        DelegateFactory.Init();   
        LuaCoroutine.Register(luaState, this);        
    }
</code></pre><pre><code>public static class LuaBinder
{
    ... 

	public static void Bind(LuaState L)
	{
        ...
		L.BeginModule(&quot;UnityEngine&quot;);
		UnityEngine_ComponentWrap.Register(L);
		UnityEngine_TransformWrap.Register(L);
		...
        L.BeginModule(&quot;Events&quot;);
		L.RegFunction(&quot;UnityAction&quot;, UnityEngine_Events_UnityAction);
		L.EndModule();
        ...
		L.EndModule();
		L.BeginPreLoad();
		L.AddPreLoad(&quot;UnityEngine.MeshRenderer&quot;, LuaOpen_UnityEngine_MeshRenderer, typeof(UnityEngine.MeshRenderer));
		L.AddPreLoad(&quot;UnityEngine.BoxCollider&quot;, LuaOpen_UnityEngine_BoxCollider, typeof(UnityEngine.BoxCollider));
		...
		L.EndPreLoad();
		...
	}

    ...
</code></pre><ul><li>LuaBinder.Bind 主要的方法有：<ul><li>L.BeginModule(&mldr;)<ul><li>调用lua的tolua_beginmodule方法，将CSharp中的namespace转化为table表示。如：namespace为A.B，则会创建table A存到全局表中，table B存到table A中，B.name = &ldquo;A.B&rdquo;</li></ul></li><li>L.EndModule()<ul><li>调用lua的tolua_endmodule方法，将栈上的table弹出（beginmodule执行完后栈上会留下当前table），结束module创建，并更新stringbuffer。</li></ul></li><li>XXXWrap.Register(L)<ul><li>XXXWrap：CSharp侧的类生成的Wrap文件，用于将CSharp类注册到lua中。生成格式为 命名空间_类名 + Wrap，如：命名空间为A.B，类名为C，则生成的Wrap为 A_B_CWrap。</li></ul></li><li>L.BeginClass(&mldr;)<ul><li>如果基类没有注册过，则在Lua侧创建一个table，放到registry表（索引为LUA_REGISTRYINDEX）中。</li><li>在CSharp建立table和基类的映射关系（metaMap、typeMap、genericSet）。</li><li>调用lua的tolua_beginclass方法，创建一个table（tb_loaded），放到registry表中的已加载表（索引为LUA_RIDX_LOADED）中，key值为命名空间+类名，如：A.B.C。</li><li>如果当前类没有创建过table，则创建一个新的table（tb_type）。</li><li>将基类table设置为当前类table的metatable。</li><li>注册元方法__call为class_new_event，主要实现获取元表里的New方法，并将参数传入后调起。</li><li>设置__index和__newindex元方法。</li><li>CSharp注册__gc元方法为CSharp的Collect方法。</li><li>在CSharp侧建立table和当前类的映射关系。</li></ul></li><li>L.EndClass()<ul><li>将当前类的table（tb_type）设置为LUA_RIDX_LOADED中table（tb_loaded）的metatable，再将LUA_RIDX_LOADED中table（tb_loaded）设置到当前module的table中，key值为类名，即module中不会直接创建当前类的table，而是持有当前类table的引用。因此获取数据时，则是通过查找LUA_RIDX_LOADED中table（tb_loaded），触发当前类table（tb_type）的__index方法获取数据的。</li></ul></li><li>L.RegFunction(&mldr;)<ul><li>将CSharp类方法转成LuaCSFunction，再获取方法指针。</li><li>调用lua的tolua_function，将方法注册到当前类的table中，key值为方法名。</li></ul></li><li>L.RegVar(&mldr;)<ul><li>将CSharp类的public变量和属性转成get和set的LuaCSFunction，再获取方法指针。</li><li>调用lua的tolua_variable，创建get和set的table，存入当前类的table中，key值为lightuserdata的&gettag和&settag</li><li>把get和set的方法存入各自的table中，key值为属性名</li></ul></li><li>L.BeginPreLoad()<ul><li>获取全局表中的package，找到表里的preload，将preload表入栈。</li></ul></li><li>L.AddPreLoad(&mldr;)<ul><li>CSharp侧将类型type加入preLoadMap字典中，值为对应的LuaCSFunction。</li><li>将LuaCSFunction压入preload表中，key值为命名空间 + 类名，如:A.B。</li><li>调用lua的tolua_addpreload方法，将命名空间作为module在全局表上创建对应的table。</li><li>在CSharp侧将命名空间加入moduleSet，保证相同命名空间只创建一次table。</li></ul></li><li>L.EndPreLoad()<ul><li>将package和preload出栈。实际上并没有直接注册lua表，而是等到调用对应的LuaCSFunstion时，再通过BeginPreModule和EndPreModule进行注册。</li></ul></li><li>L.BeginEnum(&mldr;)<ul><li>调用lua的tolua_beginenum，创建一个table（tb_loaded）加入loaded中</li><li>创建一个table（tb_enum），放入registry表中</li><li>设置table（tb_enum）的name、__index、__newindex、__gc</li><li>在CSharp侧建立table（tb_enum）和当前类的映射关系。</li><li>完成BeginEnum后，将Enum的每个值作为变量注册到table（tb_enum）中，设置get方法</li><li>所有Enum变量注册完后，注册IntToEnum方法到table（tb_enum）中，可将int转成lua侧的Enum表示</li></ul></li><li>L.EndEnum()<ul><li>将当前Enum的table（tb_enum）设置为LUA_RIDX_LOADED中table（tb_loaded）的metatable，再将LUA_RIDX_LOADED中table（tb_loaded）设置到当前module的table中，key值为Enum名。</li><li>完成EndEnum后，设置CSharp的ypeTraits.Check和StackTraits.Push</li></ul></li></ul></li></ul><blockquote><p>以UnityEngine.Component和UnityEngine.Space为例，进行绑定后,Lua侧的大致表结构如下</p></blockquote><pre><code>	_G = {
		UnityEngine = {
			Component =  LUA_REGISTRYINDEX表中LUA_RIDX_LOADED表的UnityEngine.Component,
			Space = LUA_REGISTRYINDEX表中LUA_RIDX_LOADED表的UnityEngine.Space,
			name = &quot;UnityEngine&quot;

			...
		}
		
		...
	}

	-10000（即 LUA_REGISTRYINDEX） = {

		...

		26(即 LUA_RIDX_LOADED) {
			UnityEngine.Component 
				table = {},
				metatable = ref_Component
				
			UnityEngine.Space 
				table = {},
				metatable = ref_SpaceEnum
		},	

		...

		ref_Component（分配的id，UnityEngine.Component）
			table = {
				name = &quot;UnityEngine.Component&quot;,
				ref = ref_Component分配的id,
				&amp;tag = 1,

				GetComponent = CSharp的UnityEngine_ComponentWrap.GetComponent,
				TryGetComponent = CSharp的UnityEngine_ComponentWrap.TryGetComponent,
				...
				New = CSharp的UnityEngine_ComponentWrap._CreateUnityEngine_Component,

				&amp;gettag = {
					transform = CSharp的UnityEngine_ComponentWrap.get_transform,
					gameObject = CSharp的UnityEngine_ComponentWrap.get_gameObject,
					tag = CSharp的UnityEngine_ComponentWrap.get_tag
				},

				&amp;settag = {
					tag = CSharp的UnityEngine_ComponentWrap.set_tag
				},

				__call = tolua.c中的class_new_event,
				__index = tolua.c中的class_index_event,
				__newindex = tolua.c中的class_newindex_event,
				__gc = CSharp的LuaState.Collect,
				__eq = CSharp的UnityEngine_ComponentWrap.op_Equality,
				__tostring = CSharp的ToLua.op_ToString
			},
			metatable = ref_UObject
		
		ref_UObject（分配的id，UnityEngine.Object）
			table = {
				...
			},
			metatable = {
				...
			}
		
		ref_SpaceEnum（分配的id，UnityEngine.Space）
			table = {
				name = &quot;Space&quot;
				__index = tolua.c中的enum_index_event,
				__newindex = tolua.c中的enum_newindex_event,
				__gc = CSharp的LuaState.Collect,
			},
		...
	}

	...
</code></pre><pre><code>public class DelegateFactory
{
	public static void Init()
	{
		Register();
	}

	public static void Register()
	{
		dict.Clear();
		dict.Add(typeof(System.Action), factory.System_Action);
		dict.Add(typeof(UnityEngine.Events.UnityAction), factory.UnityEngine_Events_UnityAction);
		...

		DelegateTraits&lt;System.Action&gt;.Init(factory.System_Action);
		DelegateTraits&lt;UnityEngine.Events.UnityAction&gt;.Init(factory.UnityEngine_Events_UnityAction);
		...

		TypeTraits&lt;System.Action&gt;.Init(factory.Check_System_Action);
		TypeTraits&lt;UnityEngine.Events.UnityAction&gt;.Init(factory.Check_UnityEngine_Events_UnityAction);
		...

		StackTraits&lt;System.Action&gt;.Push = factory.Push_System_Action;
		StackTraits&lt;UnityEngine.Events.UnityAction&gt;.Push = factory.Push_UnityEngine_Events_UnityAction;
		...
	}
}
</code></pre><ul><li>DelegateFactory.Init<ul><li>完成委托类型的注册<ul><li>dict.Add(&mldr;)<ul><li>在CSharp侧，将委托类型和委托创建方法加入字典中</li></ul></li><li>DelegateTraits.Init(&mldr;)<ul><li>在CSharp侧，使用泛型记录委托创建方法，可直接调用</li></ul></li><li>TypeTraits.Init(&mldr;)<ul><li>在CSharp侧，使用泛型将委托的类型检查方法添加到对应类型的Check</li></ul></li><li>StackTraits.Push = &mldr;<ul><li>在CSharp侧，使用泛型将委托的入栈方法添加到对应类型的Push</li></ul></li></ul></li><li>委托创建方法，继承LuaDelegate，流程为<ul><li>先创建LuaDelegate对象，将LuaFunction设置到LuaDelegate的func中</li><li>设置LuaDelegate的method为CSharp的Call或CallWithSelf</li><li>以LuaFunction的ref为key，将LuaDelegate以弱引用形式（WeakReference)缓存到delegateMap中</li></ul></li></ul></li></ul><h3 id=调用>调用</h3><h4 id=lua调用csharp对象>Lua调用CSharp对象</h4><ul><li>Lua侧获取一个CSharp侧对象，常用有几种方式<ul><li>CSharp侧将对象注册到Lua的对应table</li><li>使用CSharp的静态方法，如：GameObject.Find 等</li><li>使用对象的CSharp的new创建</li></ul></li><li>无论使用那种方式，最终都是通过 ToLua.PushUserData 方法来建立映射关系</li></ul><pre><code>	public static void PushUserData(IntPtr L, object o, int reference)
    {
        int index;
        ObjectTranslator translator = ObjectTranslator.Get(L);
		// 检查CSharp是否已经对这个对象建立了索引
        if (translator.Getudata(o, out index))
        {
			// 将索引对应的userdata压到Lua栈上
            if (LuaDLL.tolua_pushudata(L, index))
            {
                return;
            }

            translator.Destroyudata(index);
        }
		// CSharp侧为object创建索引index_GameObject
        index = translator.AddObject(o);
		// 在Lua侧创建userdata，userdata的值设置为index_GameObject
        LuaDLL.tolua_pushnewudata(L, reference, index);
    }
</code></pre><ul><li>CSharp调用lua的tolua_pushnewudata创建userdata，主要流程为<ul><li>创建一个userdata结构（userdata_GameObject），值为index_GameObject，类型为LUA_TUSERDATA</li><li>将ref_GameObject设置为userdata_GameObject的metabtable</li><li>将userdata_GameObject存到LUA_REGISTRYINDEX表中的LUA_RIDX_UBOX表，key值为index_GameObject，和userdata_GameObject的值一致</li><li>保留userdata_GameObject在栈顶（tolua_pushudata方法也是从LUA_RIDX_UBOX表中查找userdata_GameObject并压入栈，即userdata_GameObject位于栈顶）</li></ul></li><li>此时，Lua栈顶放着userdata_GameObject，而我们要对此GameObject进行操作时，如获取GameObject的activeSelf，则<ul><li>查找TestPanel表的GameObject_A，拿到userdata_GameObject</li><li>调用userdata_GameObject.activeSelf，即查询metatable的__index</li><li>找到CSharp的UnityEngine_GameObjectWrap.get_activeSelf方法并调用</li><li>ToLua.ToObject调用lua的tolua_rawnetobj方法，查询当前栈上的userdata的值，即CSharp侧的GameObject对象对应的index_GameObject</li><li>从ObjectTranslator中获取对应的GameObject，拿到activeSelf值</li><li>调用lua_pushboolean将activeSelf传到lua侧</li></ul></li></ul><pre><code>	local state = TestPanel.GameObject_A.activeSelf
</code></pre><pre><code>	// UnityEngine_GameObjectWrap.cs

	...

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int get_activeSelf(IntPtr L)
	{
		object o = null;

		try
		{
			o = ToLua.ToObject(L, 1);
			UnityEngine.GameObject obj = (UnityEngine.GameObject)o;
			bool ret = obj.activeSelf;
			LuaDLL.lua_pushboolean(L, ret);
			return 1;
		}
		catch(Exception e)
		{
			return LuaDLL.toluaL_exception(L, e, o, &quot;attempt to index activeSelf on a nil value&quot;);
		}
	}

	...
</code></pre><pre><code>	// ToLua.cs

	...

	public static object ToObject(IntPtr L, int stackPos)
    {
        int udata = LuaDLL.tolua_rawnetobj(L, stackPos);

        if (udata != -1)
        {
            ObjectTranslator translator = ObjectTranslator.Get(L);
            return translator.GetObject(udata);
        }

        return null;
    }

	...
</code></pre><ul><li>Lua侧此时的结构大致如下所示</li></ul><pre><code>	_G = {

		TestPanel = {
				GameObject_A : userdata_GameObject（从 LUA_RIDX_UBOX 中获取）
				...
			}
	}

	-10000（即 LUA_REGISTRYINDEX） = {
		...

		4（即 LUA_RIDX_UBOX） = {

			__mode = v （弱表，value为弱引用）

			index_GameObject（CSharp侧的一个UnityEngine.GameObject，index为ObjectTranslator分配）= userdata_GameObject {
					
					（头部 Udata*）{
						...
						tt = LUA_TUSERDATA
						metatable = LUA_REGISTRYINDEX.ref_GameObject
					}
					（用户自定义数据 user domain*）{
						index_GameObject
					}
				}
		}

		ref_GameObject（分配的id，UnityEngine.GameObject）
			table = {
				...
				&amp;gettag = {
					...
					activeSelf = CSharp的UnityEngine_GameObjectWrap.get_activeSelf,
					...
				},
			},
			metatable = ref_UObject


		...
	}
</code></pre><ul><li>当我们的TestPanel不再使用时，TestPanel表会删除（TestPanel = nil)，此时整个table会变成可回收，而表里的变量也同样会标记成可回收，即userdata_GameObject也触发了luaL_unref方法，移除了userdata_GameObject引用，此时userdata_GameObject只有在 LUA_RIDX_UBOX 中有引用，此时的结构如下：</li></ul><pre><code>Lua侧
	_G = {

	}

	-10000（即 LUA_REGISTRYINDEX） = {
		...

		4（即 LUA_RIDX_UBOX） = {
			
			index_GameObject（CSharp侧的一个UnityEngine.GameObject，index为ObjectTranslator分配）= userdata_GameObject {
					
					（头部 Udata*）{
						...
						tt = LUA_TUSERDATA
						metatable = LUA_REGISTRYINDEX.ref_GameObject
					}
					（用户自定义数据 user domain*）{
						index_GameObject
					}
				}
			
			...
		}
		...
	}

CSharp侧
	ObjectTranslator.objectsBackMap = {
		{ go , index_GameObject },
		...
	}

	ObjectTranslator.objects[index_GameObject] = go
</code></pre><ul><li>由于 LUA_RIDX_UBOX 表为值弱表，所以当lua gc触发时，userdata_GameObject由于没有其他引用，所以会被回收，并调起 userdata_GameObject.metatable的.__gc （即 LUA_REGISTRYINDEX.ref_GameObject.__gc） 方法，从而调起CSharp的LuaState.Collect方法，删除 ObjectTranslator.objects 和 ObjectTranslator.objectsBackMap 的引用</li><li>为了释放已经销毁的UnityEngine.Object的引用关系，CSharp侧提供了一个 LuaState.StepCollect() 方法，放在Update中触发，可以检查已经销毁的对象，移除 ObjectTranslator.objectsBackMap 的已销毁对象，避免字典频繁扩容</li></ul><h3 id=csharp调用lua对象>CSharp调用Lua对象</h3><h3 id=无gc传值实现>无GC传值实现</h3><h3 id=泛型实现>泛型实现</h3></div></div></div><div class="column is-3"><div class=card><div class=card-content><h1 class="title is-5">Tags</h1><div class=tags><span class=tag><a href=http://example.org/tags/googleplay>googleplay</a></span>
<span class=tag><a href=http://example.org/tags/gp>gp</a></span>
<span class=tag><a href=http://example.org/tags/lua>lua</a></span>
<span class=tag><a href=http://example.org/tags/tmp>tmp</a></span>
<span class=tag><a href=http://example.org/tags/tolua>tolua</a></span>
<span class=tag><a href=http://example.org/tags/unity%E5%A0%86%E5%86%85%E5%AD%98>unity堆内存</a></span>
<span class=tag><a href=http://example.org/tags/%E4%BC%98%E5%8C%96>优化</a></span>
<span class=tag><a href=http://example.org/tags/%E6%8A%95%E5%BD%B1>投影</a></span>
<span class=tag><a href=http://example.org/tags/%E6%8F%8F%E8%BE%B9>描边</a></span>
<span class=tag><a href=http://example.org/tags/%E6%94%AF%E4%BB%98>支付</a></span>
<span class=tag><a href=http://example.org/tags/%E7%99%BB%E5%BD%95>登录</a></span>
<span class=tag><a href=http://example.org/tags/%E7%A6%BB%E7%BA%BF>离线</a></span></div></div></div><br><div class=card><div class=card-content><h1 class="title is-5">Recent posts</h1></div></div><br><br><div class=card><div class=card-content><h1 class="title is-5">Archives</h1></div></div></div></div></div></div><footer class="footer has-background-grey-darker has-text-white"><div class="content has-text-centered"><p><span class="icon is-large"><a href=https://twitter.com/ class=mysocial rel=me><i class="fab fa-twitter fa-3x"></i></a></span>&nbsp;&nbsp;
<span class="icon is-large"><a href=https://www.youtube.com/ class=mysocial rel=me><i class="fab fa-youtube fa-3x"></i></a></span>&nbsp;&nbsp;
<span class="icon is-large"><a href=https://github.com/ class=mysocial rel=me><i class="fab fa-github fa-3x"></i></a></span>&nbsp;&nbsp;<br><br>Copyright &copy; Xun's Blog 2021 - Theme by <a href=https://jeffprod.com class=mysocial>JeffProd.com</a>
- <a class=mysocial href=http://example.org/about>About</a></p></div></footer><script defer src=https://use.fontawesome.com/releases/v5.1.0/js/all.js></script></body></html>